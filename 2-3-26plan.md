# 2-3-26 Plan — Next Efficiency Steps (ZMLX)

This plan consolidates the review findings into a focused, measurable next-step list. The goal is decode wins without regressions, with logged multi-run medians and metadata per `docs/ROADMAP.md`.

## Prioritized Experiments

1. **Isolate `gather_qmm_swiglu` overhead with Qwen3 shapes**
   - Why: The fused SwiGLU path regressed to ~34 tok/s. We need a shape/stride microbench to see if `mx.gather_qmm_swiglu` is the bottleneck or if the wrapper induces overhead.
   - Files:
     - Add new script: `benchmarks/microbench_gather_qmm_dispatch.py` (new).
     - Reference: `src/zmlx/patch/patterns/moe_mlp.py` (`_fused_switch_mlp_call`).
   - Method:
     - Reproduce the same shapes/expansion used in Qwen3 decode (`B=1, M=1`).
     - Compare: `mx.gather_qmm_swiglu` vs separate gate/up projections.
   - Success criteria:
     - Identify whether the slowdown is kernel-bound (Metal) or wrapper-bound (Python/shape prep).
   - Logging:
     - Add JSON results under `benchmarks/results/` with model/shape and MLX version.

2. **Eliminate runtime checks in `moe_mlp` patched call**
   - Why: Qwen3 gating+combine regresses ~4.5%, likely due to per-token runtime checks.
   - Files:
     - `src/zmlx/patch/patterns/moe_mlp.py` (move checks into patch-time closure).
     - Add test update for token-gate if behavior changes.
   - Method:
     - Resolve `_is_qwen3`, `_is_lfm2`, `_try_fused_downproj_combine` once at patch time.
     - Hot-path should be a straight call with no conditional branches.
   - Success criteria:
     - No regression vs baseline on Qwen3 gating+combine (≥ 1.00x decode).

3. **SLIME fast-reject epsilon sweep (threadgroup=0)**
   - Why: `epsilon=100` (skip refinement) showed 1.33x in microbench; need the knee between 10 and 100.
   - Files:
     - `benchmarks/bench_progressive_swiglu.py`.
   - Method:
     - Sweep eps ∈ {10, 15, 20, 30, 50, 75, 100} with TG=0.
   - Success criteria:
     - Find highest speed with bounded error and minimum accuracy risk (log rel_err + refine rate).
   - Logging:
     - Append to `benchmarks/results/slime_runs.json`.

4. **Bisect Qwen3 fused SwiGLU regression**
   - Why: Need to confirm if up/gate fusion is solely responsible.
   - Files:
     - `benchmarks/bench_moe_e2e.py`.
   - Method:
     - Run with `--fused-max-tokens 0` (disable fused up/gate, keep other patches).
   - Success criteria:
     - If decode returns to baseline, regression isolated to fused up/gate.
   - Logging:
     - JSON output in `benchmarks/results/`.

## Execution Order (Suggested)

1. `gather_qmm_swiglu` microbench (Experiment 1)
2. `moe_mlp` hot-path cleanup (Experiment 2)
3. Qwen3 bisect run (Experiment 4)
4. SLIME epsilon sweep (Experiment 3)

## Reporting & Guardrails

- All wins must be multi-run medians with metadata (model, eps, TG, bits, group_size, MLX version, git SHA).
- If any decode win regresses prefill, document the tradeoff or revert.
- Update `docs/ROADMAP.md` only after results are stable.

