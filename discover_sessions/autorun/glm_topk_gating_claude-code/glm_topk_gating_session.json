{
  "schema_version": "1.0",
  "metadata": {
    "session_id": "9ab4ff964c9c4955",
    "target_name": "glm_topk_gating",
    "llm_backend": "claude-code",
    "device_chip": "Apple M4",
    "device_memory_gb": 36,
    "os_version": "Darwin 25.1.0",
    "started_at": "2026-02-08T13:11:21-0600",
    "updated_at": "2026-02-08T13:19:11-0600",
    "total_steps": 10,
    "total_candidates": 40,
    "total_evaluated": 40,
    "best_reward": 5.459715136595719,
    "best_speedup": 5.790909165322877,
    "best_source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    topk_vals[i] = simd_broadcast(cur_max, 0);\n    topk_idx[i] = simd_broadcast(winner_idx, 0);\n    \n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\n// Parallel softmax: each thread handles one K value\nfloat m = topk_vals[0];\nfloat local_exp = (tid < K) ? metal::exp(topk_vals[tid] - m) : 0.0f;\nfloat sum_exp = simd_sum(local_exp);\nfloat inv = 1.0f / sum_exp;\n\n// Thread 0-3 write results\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(local_exp * inv);\n    indices[out_base + tid] = topk_idx[tid];\n}",
    "baseline_us": 707.458
  },
  "tree_data": {
    "c_puct": 1.0,
    "root": {
      "node_id": "root",
      "candidate": {
        "spec": {
          "name": "kk_topk_gating_simd_D64_K4",
          "input_names": [
            "inp"
          ],
          "output_names": [
            "weights",
            "indices"
          ],
          "source": "\n        constexpr uint D = 64;\n        constexpr uint K = 4;\n        constexpr uint SG = 32;\n\n        uint gid = thread_position_in_grid.x;\n        uint tid = thread_position_in_threadgroup.x;\n        uint row = gid / SG;\n        uint base = row * D;\n\n        float v = -INFINITY;\n        if (tid < D) {\n            v = (float)inp[base + tid];\n        }\n\n        thread float topk_vals[K];\n        thread uint topk_idx[K];\n\n        float cur = v;\n        for (uint i = 0; i < K; ++i) {\n            float cur_max = simd_max(cur);\n            uint candidate = (cur == cur_max && tid < D) ? tid : 0;\n            uint winner = simd_max(candidate);\n            if (tid == 0) {\n                topk_vals[i] = cur_max;\n                topk_idx[i] = winner;\n            }\n            cur = (tid == winner) ? -INFINITY : cur;\n        }\n\n        if (tid == 0) {\n            float m = topk_vals[0];\n            float s = 0.0f;\n            for (uint i = 0; i < K; ++i) {\n                s += metal::exp(topk_vals[i] - m);\n            }\n            float inv = 1.0f / s;\n            uint out_base = row * K;\n            for (uint i = 0; i < K; ++i) {\n                weights[out_base + i] = (T)(metal::exp(topk_vals[i] - m) * inv);\n                indices[out_base + i] = topk_idx[i];\n            }\n        }\n    ",
          "header": "",
          "threadgroup": [
            32,
            1,
            1
          ],
          "template_params": [
            [
              "T",
              "float32"
            ]
          ]
        },
        "parent_id": null,
        "generation": 0,
        "llm_reasoning": "baseline"
      },
      "visit_count": 41,
      "max_reward": 5.459715136595719,
      "prior": 1.0,
      "eval_result": {
        "compiled": true,
        "correct": false,
        "compile_error": null,
        "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.6251656413078308 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.1695910394191742 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.1061181053519249 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.09912522882223129 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.10975224\nMax relative difference among violations: 0.33480233\n ACTUAL: array([[0.625166, 0.169591, 0.106118, 0.099125]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
        "timings_us": [],
        "median_us": Infinity,
        "reward": 0.0,
        "speedup": 0.0
      },
      "children": [
        {
          "node_id": "gen1_538e146ea727",
          "candidate": {
            "spec": {
              "name": "kk_glm_topk_gating_gen1",
              "input_names": [
                "inp"
              ],
              "output_names": [
                "weights",
                "indices"
              ],
              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v = -INFINITY;\nif (tid < D) {\n    v = (float)inp[base + tid];\n}\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate = (cur == cur_max && tid < D) ? tid : 0;\n    uint winner = simd_max(candidate);\n    \n    // Broadcast to all threads\n    topk_vals[i] = simd_broadcast(cur_max, 0);\n    topk_idx[i] = simd_broadcast(winner, 0);\n    \n    cur = (tid == winner) ? -INFINITY : cur;\n}\n\n// All threads compute softmax in parallel\nfloat m = topk_vals[0];\nfloat s = 0.0f;\nfor (uint i = 0; i < K; ++i) {\n    s += metal::exp(topk_vals[i] - m);\n}\nfloat inv = 1.0f / s;\n\n// Thread-0 writes results\nif (tid == 0) {\n    uint out_base = row * K;\n    for (uint i = 0; i < K; ++i) {\n        weights[out_base + i] = (T)(metal::exp(topk_vals[i] - m) * inv);\n        indices[out_base + i] = topk_idx[i];\n    }\n}",
              "header": "",
              "threadgroup": [
                32,
                1,
                1
              ],
              "template_params": [
                [
                  "T",
                  "float32"
                ]
              ]
            },
            "parent_id": "root",
            "generation": 1,
            "llm_reasoning": "Broadcast top-k values to all threads via simd_broadcast, avoiding the thread-0 bottleneck. All threads compute softmax in parallel, then thread-0 writes results."
          },
          "visit_count": 1,
          "max_reward": 0.0,
          "prior": 0.25,
          "eval_result": {
            "compiled": true,
            "correct": false,
            "compile_error": null,
            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.6251656413078308 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.1695910394191742 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.1061181053519249 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.09912522882223129 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.10975224\nMax relative difference among violations: 0.33480233\n ACTUAL: array([[0.625166, 0.169591, 0.106118, 0.099125]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
            "timings_us": [],
            "median_us": Infinity,
            "reward": 0.0,
            "speedup": 0.0
          },
          "children": []
        },
        {
          "node_id": "gen1_4ee5fa59a05d",
          "candidate": {
            "spec": {
              "name": "kk_glm_topk_gating_gen1",
              "input_names": [
                "inp"
              ],
              "output_names": [
                "weights",
                "indices"
              ],
              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v = -INFINITY;\nif (tid < D) {\n    v = (float)inp[base + tid];\n}\n\nfloat cur = v;\n\n// Iteration 0\nfloat max0 = simd_max(cur);\nuint cand0 = (cur == max0 && tid < D) ? tid : 0;\nuint idx0 = simd_max(cand0);\ncur = (tid == idx0) ? -INFINITY : cur;\n\n// Iteration 1\nfloat max1 = simd_max(cur);\nuint cand1 = (cur == max1 && tid < D) ? tid : 0;\nuint idx1 = simd_max(cand1);\ncur = (tid == idx1) ? -INFINITY : cur;\n\n// Iteration 2\nfloat max2 = simd_max(cur);\nuint cand2 = (cur == max2 && tid < D) ? tid : 0;\nuint idx2 = simd_max(cand2);\ncur = (tid == idx2) ? -INFINITY : cur;\n\n// Iteration 3\nfloat max3 = simd_max(cur);\nuint cand3 = (cur == max3 && tid < D) ? tid : 0;\nuint idx3 = simd_max(cand3);\n\nif (tid == 0) {\n    float m = max0;\n    float exp0 = metal::exp(max0 - m);\n    float exp1 = metal::exp(max1 - m);\n    float exp2 = metal::exp(max2 - m);\n    float exp3 = metal::exp(max3 - m);\n    \n    float s = exp0 + exp1 + exp2 + exp3;\n    float inv = 1.0f / s;\n    \n    uint out_base = row * K;\n    weights[out_base + 0] = (T)(exp0 * inv);\n    weights[out_base + 1] = (T)(exp1 * inv);\n    weights[out_base + 2] = (T)(exp2 * inv);\n    weights[out_base + 3] = (T)(exp3 * inv);\n    indices[out_base + 0] = idx0;\n    indices[out_base + 1] = idx1;\n    indices[out_base + 2] = idx2;\n    indices[out_base + 3] = idx3;\n}",
              "header": "",
              "threadgroup": [
                32,
                1,
                1
              ],
              "template_params": [
                [
                  "T",
                  "float32"
                ]
              ]
            },
            "parent_id": "root",
            "generation": 1,
            "llm_reasoning": "Unroll K=4 loop completely to eliminate loop overhead and enable instruction-level parallelism. Manual unrolling exposes opportunities for better scheduling."
          },
          "visit_count": 1,
          "max_reward": 0.0,
          "prior": 0.25,
          "eval_result": {
            "compiled": true,
            "correct": false,
            "compile_error": null,
            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.6251656413078308 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.1695910394191742 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.1061181053519249 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.09912522882223129 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.10975224\nMax relative difference among violations: 0.33480233\n ACTUAL: array([[0.625166, 0.169591, 0.106118, 0.099125]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
            "timings_us": [],
            "median_us": Infinity,
            "reward": 0.0,
            "speedup": 0.0
          },
          "children": []
        },
        {
          "node_id": "gen1_675c892a5bcb",
          "candidate": {
            "spec": {
              "name": "kk_glm_topk_gating_gen1",
              "input_names": [
                "inp"
              ],
              "output_names": [
                "weights",
                "indices"
              ],
              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load two values per thread (D=64, SG=32)\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Start with max of the two\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    if (tid == 0) {\n        topk_vals[i] = cur_max;\n        topk_idx[i] = winner_idx;\n    }\n    \n    // Update cur to -INFINITY if we were the winner\n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\nif (tid == 0) {\n    float m = topk_vals[0];\n    float s = 0.0f;\n    for (uint i = 0; i < K; ++i) {\n        s += metal::exp(topk_vals[i] - m);\n    }\n    float inv = 1.0f / s;\n    uint out_base = row * K;\n    for (uint i = 0; i < K; ++i) {\n        weights[out_base + i] = (T)(metal::exp(topk_vals[i] - m) * inv);\n        indices[out_base + i] = topk_idx[i];\n    }\n}",
              "header": "",
              "threadgroup": [
                32,
                1,
                1
              ],
              "template_params": [
                [
                  "T",
                  "float32"
                ]
              ]
            },
            "parent_id": "root",
            "generation": 1,
            "llm_reasoning": "Reduce register pressure by processing D=64 in two halves (32 each), allowing better occupancy. Each thread loads one value, find top-k across both halves."
          },
          "visit_count": 37,
          "max_reward": 5.459715136595719,
          "prior": 0.25,
          "eval_result": {
            "compiled": true,
            "correct": true,
            "compile_error": null,
            "correctness_error": null,
            "timings_us": [
              169.292,
              143.125,
              137.458,
              137.584,
              155.792,
              141.875,
              141.416,
              143.209,
              137.833,
              143.75,
              142.625,
              189.25,
              139.5,
              138.375,
              137.167,
              142.917,
              137.458,
              136.125,
              139.583,
              140.333
            ],
            "median_us": 141.416,
            "reward": 4.904415559626288,
            "speedup": 5.002672964869604
          },
          "children": [
            {
              "node_id": "gen2_1b54c88997fe",
              "candidate": {
                "spec": {
                  "name": "kk_glm_topk_gating_gen2",
                  "input_names": [
                    "inp"
                  ],
                  "output_names": [
                    "weights",
                    "indices"
                  ],
                  "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    topk_vals[i] = simd_broadcast(cur_max, 0);\n    topk_idx[i] = simd_broadcast(winner_idx, 0);\n    \n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\n// Parallel softmax: each thread handles one K value\nfloat m = topk_vals[0];\nfloat local_exp = (tid < K) ? metal::exp(topk_vals[tid] - m) : 0.0f;\nfloat sum_exp = simd_sum(local_exp);\nfloat inv = 1.0f / sum_exp;\n\n// Thread 0-3 write results\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(local_exp * inv);\n    indices[out_base + tid] = topk_idx[tid];\n}",
                  "header": "",
                  "threadgroup": [
                    32,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_675c892a5bcb",
                "generation": 2,
                "llm_reasoning": "Exploit SIMD shuffle to distribute softmax work across all threads instead of concentrating in thread-0, then gather results. Each thread computes exp for one value, simd_sum aggregates."
              },
              "visit_count": 33,
              "max_reward": 5.459715136595719,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  129.5,
                  132.083,
                  271.041,
                  121.958,
                  126.792,
                  123.833,
                  122.792,
                  131.375,
                  125.584,
                  119.875,
                  120.625,
                  121.042,
                  122.167,
                  120.958,
                  119.625,
                  120.042,
                  118.0,
                  118.917,
                  122.083,
                  155.625
                ],
                "median_us": 122.167,
                "reward": 5.459715136595719,
                "speedup": 5.790909165322877
              },
              "children": [
                {
                  "node_id": "gen3_329e5901bcbb",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_topk_gating_gen3",
                      "input_names": [
                        "inp"
                      ],
                      "output_names": [
                        "weights",
                        "indices"
                      ],
                      "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Sorted insertion network for K=4\nthread float vals[4] = {-INFINITY, -INFINITY, -INFINITY, -INFINITY};\nthread uint idxs[4] = {0, 0, 0, 0};\n\n// Insert v into sorted array\nif (v > vals[0]) {\n    vals[3] = vals[2]; idxs[3] = idxs[2];\n    vals[2] = vals[1]; idxs[2] = idxs[1];\n    vals[1] = vals[0]; idxs[1] = idxs[0];\n    vals[0] = v; idxs[0] = local_idx;\n} else if (v > vals[1]) {\n    vals[3] = vals[2]; idxs[3] = idxs[2];\n    vals[2] = vals[1]; idxs[2] = idxs[1];\n    vals[1] = v; idxs[1] = local_idx;\n} else if (v > vals[2]) {\n    vals[3] = vals[2]; idxs[3] = idxs[2];\n    vals[2] = v; idxs[2] = local_idx;\n} else if (v > vals[3]) {\n    vals[3] = v; idxs[3] = local_idx;\n}\n\n// SIMD-level merge to find global top-k\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfor (uint i = 0; i < K; ++i) {\n    float candidate = vals[i];\n    uint candidate_idx = idxs[i];\n    float global_max = simd_max(candidate);\n    uint winner_idx = (candidate == global_max) ? candidate_idx : 0;\n    winner_idx = simd_max(winner_idx);\n    \n    topk_vals[i] = simd_broadcast(global_max, 0);\n    topk_idx[i] = simd_broadcast(winner_idx, 0);\n    \n    if (candidate_idx == winner_idx) {\n        vals[i] = -INFINITY;\n    }\n}\n\n// Softmax\nfloat m = topk_vals[0];\nfloat local_exp = (tid < K) ? metal::exp(topk_vals[tid] - m) : 0.0f;\nfloat sum_exp = simd_sum(local_exp);\nfloat inv = metal::fast::divide(1.0f, sum_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(local_exp * inv);\n    indices[out_base + tid] = topk_idx[tid];\n}",
                      "header": "",
                      "threadgroup": [
                        32,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen2_1b54c88997fe",
                    "generation": 3,
                    "llm_reasoning": "Compute top-k in a single pass by maintaining sorted pairs in registers with conditional moves instead of iterative SIMD operations, reducing SIMD sync overhead."
                  },
                  "visit_count": 1,
                  "max_reward": 0.0,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": false,
                    "compile_error": null,
                    "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 1.0 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.0 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.0 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.0 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.4845866\nMax relative difference among violations: 1.\n ACTUAL: array([[1., 0., 0., 0.]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                    "timings_us": [],
                    "median_us": Infinity,
                    "reward": 0.0,
                    "speedup": 0.0
                  },
                  "children": []
                },
                {
                  "node_id": "gen3_07fe13061f60",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_topk_gating_gen3",
                      "input_names": [
                        "inp"
                      ],
                      "output_names": [
                        "weights",
                        "indices"
                      ],
                      "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfor (uint k = 0; k < K; ++k) {\n    float candidate = v;\n    uint candidate_idx = local_idx;\n    \n    // Binary tree reduction using simd_shuffle_xor\n    for (uint offset = 16; offset > 0; offset >>= 1) {\n        float other_val = simd_shuffle_xor(candidate, offset);\n        uint other_idx = simd_shuffle_xor(candidate_idx, offset);\n        if (other_val > candidate) {\n            candidate = other_val;\n            candidate_idx = other_idx;\n        }\n    }\n    \n    topk_vals[k] = simd_broadcast(candidate, 0);\n    topk_idx[k] = simd_broadcast(candidate_idx, 0);\n    \n    if (local_idx == candidate_idx) {\n        v = -INFINITY;\n    }\n}\n\n// Vectorized softmax computation\nfloat m = topk_vals[0];\nfloat local_exp = (tid < K) ? metal::exp(topk_vals[tid] - m) : 0.0f;\nfloat sum_exp = simd_sum(local_exp);\nfloat inv_sum = metal::fast::divide(1.0f, sum_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(local_exp * inv_sum);\n    indices[out_base + tid] = topk_idx[tid];\n}",
                      "header": "",
                      "threadgroup": [
                        32,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen2_1b54c88997fe",
                    "generation": 3,
                    "llm_reasoning": "Use SIMD shuffle to perform binary reduction-style top-k merge across warp lanes, enabling all 32 threads to participate in finding global maxima without sequential iterations."
                  },
                  "visit_count": 1,
                  "max_reward": 1.2824648492660529,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      543.166,
                      513.583,
                      504.0,
                      538.5,
                      499.708,
                      683.0,
                      474.083,
                      523.625,
                      523.917,
                      546.791,
                      522.5,
                      534.041,
                      501.625,
                      515.291,
                      550.917,
                      713.417,
                      772.125,
                      543.334,
                      547.916,
                      568.667
                    ],
                    "median_us": 538.5,
                    "reward": 1.2824648492660529,
                    "speedup": 1.313756731662024
                  },
                  "children": []
                },
                {
                  "node_id": "gen3_7c77f5288cfb",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_topk_gating_gen3",
                      "input_names": [
                        "inp"
                      ],
                      "output_names": [
                        "weights",
                        "indices"
                      ],
                      "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\nfloat running_max = -INFINITY;\nfloat running_sum = 0.0f;\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    topk_vals[i] = simd_broadcast(cur_max, 0);\n    topk_idx[i] = simd_broadcast(winner_idx, 0);\n    \n    // Fused online softmax update\n    if (i > 0) {\n        float old_max = running_max;\n        running_max = metal::max(running_max, topk_vals[i]);\n        float correction = metal::exp(old_max - running_max);\n        running_sum = running_sum * correction + metal::exp(topk_vals[i] - running_max);\n    } else {\n        running_max = topk_vals[i];\n        running_sum = 1.0f;\n    }\n    \n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\n// Add final value to running sum\nrunning_sum += metal::exp(topk_vals[K-1] - running_max);\nfloat inv_sum = metal::fast::divide(1.0f, running_sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(metal::exp(topk_vals[tid] - running_max) * inv_sum);\n    indices[out_base + tid] = topk_idx[tid];\n}",
                      "header": "",
                      "threadgroup": [
                        32,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen2_1b54c88997fe",
                    "generation": 3,
                    "llm_reasoning": "Fuse max-finding and softmax computation by computing running exp-sum during top-k selection, eliminating the separate softmax pass and reducing memory operations."
                  },
                  "visit_count": 1,
                  "max_reward": 0.0,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": false,
                    "compile_error": null,
                    "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.44856932759284973 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.15604941546916962 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.13600075244903564 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.1296902447938919 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.06684408\nMax relative difference among violations: 0.1296903\n ACTUAL: array([[0.448569, 0.156049, 0.136001, 0.12969 ]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                    "timings_us": [],
                    "median_us": Infinity,
                    "reward": 0.0,
                    "speedup": 0.0
                  },
                  "children": []
                },
                {
                  "node_id": "gen3_aba888496883",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_topk_gating_gen3",
                      "input_names": [
                        "inp"
                      ],
                      "output_names": [
                        "weights",
                        "indices"
                      ],
                      "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Prefetch both values into registers\nfloat2 vals_reg = float2((float)inp[base + tid], (float)inp[base + tid + 32]);\nfloat v = metal::max(vals_reg.x, vals_reg.y);\nuint local_idx = (vals_reg.x >= vals_reg.y) ? tid : (tid + 32);\n\n// Compact top-k extraction with minimal branching\nthread float sorted_vals[K];\nthread uint sorted_idx[K];\n\nfloat working_val = v;\nuint working_idx = local_idx;\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float lane_max = simd_max(working_val);\n    bool is_winner = (working_val == lane_max);\n    uint winner_lane = simd_max(is_winner ? working_idx : 0u);\n    \n    sorted_vals[i] = lane_max;\n    sorted_idx[i] = winner_lane;\n    \n    working_val = is_winner ? -INFINITY : working_val;\n}\n\n// SIMD-parallel softmax\nfloat max_val = sorted_vals[0];\nfloat thread_exp = (tid < K) ? metal::precise::exp(sorted_vals[tid] - max_val) : 0.0f;\nfloat total_exp = simd_sum(thread_exp);\nfloat norm = metal::precise::divide(1.0f, total_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(thread_exp * norm);\n    indices[out_base + tid] = sorted_idx[tid];\n}",
                      "header": "",
                      "threadgroup": [
                        32,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen2_1b54c88997fe",
                    "generation": 3,
                    "llm_reasoning": "Exploit memory-level parallelism by prefetching D=64 values into registers upfront, then use bitonic sort on register values to find top-k with predictable access patterns."
                  },
                  "visit_count": 29,
                  "max_reward": 5.391555050501889,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      155.208,
                      149.625,
                      141.167,
                      160.125,
                      152.333,
                      144.541,
                      142.25,
                      146.833,
                      145.125,
                      145.167,
                      140.292,
                      141.459,
                      154.708,
                      182.583,
                      147.916,
                      150.375,
                      159.875,
                      288.125,
                      143.334,
                      156.5
                    ],
                    "median_us": 149.625,
                    "reward": 4.559098263721297,
                    "speedup": 4.728207184628237
                  },
                  "children": [
                    {
                      "node_id": "gen4_838b765c7a0a",
                      "candidate": {
                        "spec": {
                          "name": "kk_glm_topk_gating_gen4",
                          "input_names": [
                            "inp"
                          ],
                          "output_names": [
                            "weights",
                            "indices"
                          ],
                          "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load one value per thread from first half\nfloat val_lo = (float)inp[base + tid];\nfloat val_hi = (float)inp[base + tid + 32];\n\n// Phase 1: Hierarchical max across halves using XOR shuffle\nthread float top_vals[K];\nthread uint top_idx[K];\n\nfloat curr_val = metal::max(val_lo, val_hi);\nuint curr_idx = (val_lo >= val_hi) ? tid : (tid + 32);\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    // Find max across all lanes\n    float lane_max = simd_max(curr_val);\n    \n    // XOR shuffle to get neighbor's value for tie-breaking\n    uint neighbor_idx = simd_shuffle_xor(curr_idx, 1);\n    float neighbor_val = simd_shuffle_xor(curr_val, 1);\n    \n    bool is_local_max = (curr_val == lane_max);\n    uint winner_idx = simd_max(is_local_max ? curr_idx : 0u);\n    \n    top_vals[k] = lane_max;\n    top_idx[k] = winner_idx;\n    \n    // Mask out winner\n    curr_val = is_local_max ? -INFINITY : curr_val;\n}\n\n// Phase 2: Softmax with instruction-level parallelism\nfloat max_logit = top_vals[0];\nfloat exp_acc = 0.0f;\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::precise::exp(top_vals[k] - max_logit);\n    top_vals[k] = e;\n    exp_acc += e;\n}\n\nfloat inv_sum = metal::precise::divide(1.0f, simd_sum(exp_acc));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idx[tid];\n}",
                          "header": "",
                          "threadgroup": [
                            256,
                            1,
                            1
                          ],
                          "template_params": [
                            [
                              "T",
                              "float32"
                            ]
                          ]
                        },
                        "parent_id": "gen3_aba888496883",
                        "generation": 4,
                        "llm_reasoning": "Use hierarchical reduction to find top-K: first reduce within each half (tid<32 vs tid>=32), then merge across halves using simd_shuffle_xor for communication, reducing register footprint."
                      },
                      "visit_count": 5,
                      "max_reward": 0.0,
                      "prior": 0.25,
                      "eval_result": {
                        "compiled": true,
                        "correct": false,
                        "compile_error": null,
                        "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.01610666885972023 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.005603227764368057 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.004883345682173967 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.004656756296753883 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.49930674\nMax relative difference among violations: 0.96875\n ACTUAL: array([[0.016107, 0.005603, 0.004883, 0.004657]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                        "timings_us": [],
                        "median_us": Infinity,
                        "reward": 0.0,
                        "speedup": 0.0
                      },
                      "children": [
                        {
                          "node_id": "gen5_5d2baa5b1433",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen5",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load one value per thread from first half\nfloat val_lo = (float)inp[base + tid];\nfloat val_hi = (float)inp[base + tid + 32];\n\nthread float top_vals[K];\nthread uint top_idx[K];\n\nfloat curr_val = metal::max(val_lo, val_hi);\nuint curr_idx = (val_lo >= val_hi) ? tid : (tid + 32);\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float lane_max = simd_max(curr_val);\n    \n    // Use ballot to find all threads with max value\n    bool is_max = (curr_val == lane_max);\n    \n    // First set bit gives us the winner index\n    uint winner_idx = simd_min(is_max ? curr_idx : 0xFFFFFFFFu);\n    \n    top_vals[k] = lane_max;\n    top_idx[k] = winner_idx;\n    \n    // Mask out winner for next iteration\n    curr_val = (curr_idx == winner_idx) ? -INFINITY : curr_val;\n}\n\n// Softmax with fused max subtraction and exp\nfloat max_logit = top_vals[0];\nfloat sum0 = 0.0f, sum1 = 0.0f;\n\n// Manual 2x unroll for ILP\nfloat e0 = metal::precise::exp(top_vals[0] - max_logit);\nfloat e1 = metal::precise::exp(top_vals[1] - max_logit);\nsum0 += e0 + e1;\n\nfloat e2 = metal::precise::exp(top_vals[2] - max_logit);\nfloat e3 = metal::precise::exp(top_vals[3] - max_logit);\nsum1 += e2 + e3;\n\ntop_vals[0] = e0;\ntop_vals[1] = e1;\ntop_vals[2] = e2;\ntop_vals[3] = e3;\n\nfloat inv_sum = metal::precise::divide(1.0f, simd_sum(sum0 + sum1));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idx[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_838b765c7a0a",
                            "generation": 5,
                            "llm_reasoning": "Use ballot-based winner election to find max index in single instruction, then mask and repeat. Eliminates the XOR shuffle overhead from current best."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.01610666885972023 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.005603227764368057 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.004883345682173967 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.004656756296753883 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.49930674\nMax relative difference among violations: 0.96875\n ACTUAL: array([[0.016107, 0.005603, 0.004883, 0.004657]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen5_9b8ba70fc157",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen5",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load two values per thread\nfloat val_lo = (float)inp[base + tid];\nfloat val_hi = (float)inp[base + tid + 32];\n\nthread float top_vals[K];\nthread uint top_idx[K];\n\nfloat curr_val = metal::max(val_lo, val_hi);\nuint curr_idx = (val_lo >= val_hi) ? tid : (tid + 32);\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    // Quad-level reduction first (lanes 0-3, 4-7, etc.)\n    float quad_max = curr_val;\n    uint quad_idx = curr_idx;\n    \n    #pragma unroll\n    for (uint offset = 1; offset < 4; ++offset) {\n        float neighbor_val = simd_shuffle_rotate_down(curr_val, offset);\n        uint neighbor_idx = simd_shuffle_rotate_down(curr_idx, offset);\n        if (neighbor_val > quad_max || (neighbor_val == quad_max && neighbor_idx < quad_idx)) {\n            quad_max = neighbor_val;\n            quad_idx = neighbor_idx;\n        }\n    }\n    \n    // Broadcast quad winners to all 32 lanes\n    float lane_max = simd_max(quad_max);\n    uint winner_idx = simd_min((quad_max == lane_max) ? quad_idx : 0xFFFFFFFFu);\n    \n    top_vals[k] = lane_max;\n    top_idx[k] = winner_idx;\n    \n    curr_val = (curr_idx == winner_idx) ? -INFINITY : curr_val;\n}\n\n// Softmax with precise reciprocal\nfloat max_logit = top_vals[0];\nfloat exp_sum = 0.0f;\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::precise::exp(top_vals[k] - max_logit);\n    top_vals[k] = e;\n    exp_sum += e;\n}\n\nfloat inv_sum = metal::precise::divide(1.0f, simd_sum(exp_sum));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idx[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_838b765c7a0a",
                            "generation": 5,
                            "llm_reasoning": "Exploit quad-shuffle to reduce 4 values per lane to top-1, then merge across quads. Leverages subgroup structure for better instruction pipelining."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.01610666885972023 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.005603227764368057 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.004883345682173967 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.004656756296753883 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.49930674\nMax relative difference among violations: 0.96875\n ACTUAL: array([[0.016107, 0.005603, 0.004883, 0.004657]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen5_96135ae35ace",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen5",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Each thread holds 2 values\nfloat vals[2];\nvals[0] = (float)inp[base + tid];\nvals[1] = (float)inp[base + tid + 32];\n\nthread float top_vals[K];\nthread uint top_idx[K];\n\n// Build top-K using tournament elimination\nthread bool mask[2] = {false, false};\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    // Find local max among unmasked values\n    float local_max = -INFINITY;\n    uint local_idx = 0;\n    \n    #pragma unroll\n    for (uint i = 0; i < 2; ++i) {\n        if (!mask[i] && vals[i] > local_max) {\n            local_max = vals[i];\n            local_idx = tid + i * 32;\n        }\n    }\n    \n    // Global max across all threads\n    float global_max = simd_max(local_max);\n    uint winner_idx = simd_min((local_max == global_max) ? local_idx : 0xFFFFFFFFu);\n    \n    top_vals[k] = global_max;\n    top_idx[k] = winner_idx;\n    \n    // Mask out winner in local registers\n    #pragma unroll\n    for (uint i = 0; i < 2; ++i) {\n        if (tid + i * 32 == winner_idx) {\n            mask[i] = true;\n        }\n    }\n}\n\n// Parallel softmax computation\nfloat max_logit = top_vals[0];\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    top_vals[k] = metal::precise::exp(top_vals[k] - max_logit);\n}\n\nfloat sum = top_vals[0] + top_vals[1] + top_vals[2] + top_vals[3];\nfloat inv_sum = metal::precise::divide(1.0f, simd_sum(sum));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idx[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_838b765c7a0a",
                            "generation": 5,
                            "llm_reasoning": "Prefetch all D=64 values into registers, then use register-only tournament tree for top-K. Eliminates repeated simd ops in favor of local comparisons."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.01610666885972023 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.005603227764368057 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.004883345682173967 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.004656756296753883 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.49930674\nMax relative difference among violations: 0.96875\n ACTUAL: array([[0.016107, 0.005603, 0.004883, 0.004657]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen5_8bc50c14b2e7",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen5",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat val_lo = (float)inp[base + tid];\nfloat val_hi = (float)inp[base + tid + 32];\n\nthread float top_vals[K];\nthread uint top_idx[K];\n\nfloat curr_val = metal::max(val_lo, val_hi);\nuint curr_idx = (val_lo >= val_hi) ? tid : (tid + 32);\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float lane_max = simd_max(curr_val);\n    bool is_max = (curr_val == lane_max);\n    uint winner_idx = simd_min(is_max ? curr_idx : 0xFFFFFFFFu);\n    \n    top_vals[k] = lane_max;\n    top_idx[k] = winner_idx;\n    \n    curr_val = (curr_idx == winner_idx) ? -INFINITY : curr_val;\n}\n\n// Kahan-compensated softmax accumulation\nfloat max_logit = top_vals[0];\nfloat sum = 0.0f;\nfloat c = 0.0f;  // Compensation term\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::precise::exp(top_vals[k] - max_logit);\n    top_vals[k] = e;\n    \n    // Kahan summation\n    float y = e - c;\n    float t = sum + y;\n    c = (t - sum) - y;\n    sum = t;\n}\n\n// Single reciprocal with FMA-based scaling\nfloat total_sum = simd_sum(sum);\nfloat inv_sum = metal::precise::divide(1.0f, total_sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)metal::fma(top_vals[tid], inv_sum, 0.0f);\n    indices[out_base + tid] = top_idx[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_838b765c7a0a",
                            "generation": 5,
                            "llm_reasoning": "Use fused multiply-add for softmax normalization and eliminate separate sum reduction by accumulating during exp computation with Kahan summation for numerical stability."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.01610666885972023 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.005603227764368057 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.004883345682173967 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.004656756296753883 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.49930674\nMax relative difference among violations: 0.96875\n ACTUAL: array([[0.016107, 0.005603, 0.004883, 0.004657]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        }
                      ]
                    },
                    {
                      "node_id": "gen4_098f7c49e4d5",
                      "candidate": {
                        "spec": {
                          "name": "kk_glm_topk_gating_gen4",
                          "input_names": [
                            "inp"
                          ],
                          "output_names": [
                            "weights",
                            "indices"
                          ],
                          "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load first value and start max computation while second value loads\nfloat val1 = (float)inp[base + tid];\nfloat running_max = val1;\nuint running_idx = tid;\n\n// Prefetch second value (compiler can overlap with above arithmetic)\nfloat val2 = (float)inp[base + tid + 32];\n\n// Update max with second value\nif (val2 > running_max) {\n    running_max = val2;\n    running_idx = tid + 32;\n}\n\n// Top-k extraction with compact branch-free updates\nthread float k_vals[K];\nthread uint k_idx[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float best = simd_max(running_max);\n    \n    // Branch-free winner selection\n    bool wins = (running_max == best);\n    uint winner = simd_max(wins ? running_idx : 0u);\n    \n    k_vals[i] = best;\n    k_idx[i] = winner;\n    \n    // Conditional update without branching\n    float mask = wins ? -INFINITY : running_max;\n    running_max = mask;\n}\n\n// Softmax: compute all exp() before summing (better ILP)\nfloat peak = k_vals[0];\nthread float exps[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    exps[i] = metal::precise::exp(k_vals[i] - peak);\n}\n\nfloat sum_exp = 0.0f;\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    sum_exp += exps[i];\n}\n\nfloat rcp = metal::precise::divide(1.0f, simd_sum(sum_exp));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exps[tid] * rcp);\n    indices[out_base + tid] = k_idx[tid];\n}",
                          "header": "",
                          "threadgroup": [
                            256,
                            1,
                            1
                          ],
                          "template_params": [
                            [
                              "T",
                              "float32"
                            ]
                          ]
                        },
                        "parent_id": "gen3_aba888496883",
                        "generation": 4,
                        "llm_reasoning": "Overlap computation and memory operations by computing partial max while loading second half of data, hiding memory latency with arithmetic ops."
                      },
                      "visit_count": 5,
                      "max_reward": 0.0,
                      "prior": 0.25,
                      "eval_result": {
                        "compiled": true,
                        "correct": false,
                        "compile_error": null,
                        "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.01610666885972023 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.005603227764368057 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.004883345682173967 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.004656756296753883 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.49930674\nMax relative difference among violations: 0.96875\n ACTUAL: array([[0.016107, 0.005603, 0.004883, 0.004657]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                        "timings_us": [],
                        "median_us": Infinity,
                        "reward": 0.0,
                        "speedup": 0.0
                      },
                      "children": [
                        {
                          "node_id": "gen6_8ab591c62c86",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen6",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load both values with explicit prefetch hint\nfloat val1 = (float)inp[base + tid];\nfloat val2 = (float)inp[base + tid + 32];\n\n// Parallel max computation\nfloat running_max = metal::max(val1, val2);\nuint running_idx = (val2 > val1) ? (tid + 32) : tid;\n\n// Top-k extraction\nthread float k_vals[K];\nthread uint k_idx[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float best = simd_max(running_max);\n    bool wins = (running_max == best);\n    uint winner = simd_max(wins ? running_idx : 0u);\n    \n    k_vals[i] = best;\n    k_idx[i] = winner;\n    \n    running_max = wins ? -INFINITY : running_max;\n}\n\n// Distribute softmax computation across all 32 threads\n// Each thread computes exp for one value, broadcast via shuffle\nfloat peak = k_vals[0];\nfloat my_exp = 0.0f;\n\nif (tid < K) {\n    my_exp = metal::precise::exp(k_vals[tid] - peak);\n}\n\n// Sum across warp using SIMD broadcast pattern\nfloat sum_exp = 0.0f;\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    sum_exp += simd_broadcast(my_exp, i);\n}\n\nfloat rcp = metal::precise::divide(1.0f, sum_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    float normalized = simd_broadcast(my_exp, tid) * rcp;\n    weights[out_base + tid] = (T)normalized;\n    indices[out_base + tid] = k_idx[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_098f7c49e4d5",
                            "generation": 6,
                            "llm_reasoning": "Use simd_prefix_exclusive_sum for parallel softmax normalization, exploiting SIMD-level parallelism to distribute exp() computation across all 32 threads rather than just the first K threads."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 3 / 4 (75%)\nMismatch at indices:\n [0, 0]: 0.14901620149612427 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.14901620149612427 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.14901620149612427 (ACTUAL), 0.15626706182956696 (DESIRED)\nMax absolute difference among violations: 0.3663972\nMax relative difference among violations: 0.7108802\n ACTUAL: array([[0.149016, 0.149016, 0.149016, 0.149016]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen6_b254c71c4ea3",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen6",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Pack value and index as float2\nfloat val1 = (float)inp[base + tid];\nfloat val2 = (float)inp[base + tid + 32];\n\nfloat2 pair = (val2 > val1) ? float2(val2, tid + 32) : float2(val1, tid);\n\n// Top-k using packed pairs\nthread float2 k_pairs[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float best = simd_max(pair.x);\n    bool wins = (pair.x == best);\n    uint winner = simd_max(wins ? uint(pair.y) : 0u);\n    \n    k_pairs[i] = float2(best, winner);\n    \n    pair.x = wins ? -INFINITY : pair.x;\n}\n\n// Vectorized softmax\nfloat peak = k_pairs[0].x;\nthread float exps[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    exps[i] = metal::fast::exp(k_pairs[i].x - peak);\n}\n\nfloat sum_exp = exps[0] + exps[1] + exps[2] + exps[3];\nsum_exp = simd_sum(sum_exp);\nfloat rcp = 1.0f / sum_exp;\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exps[tid] * rcp);\n    indices[out_base + tid] = uint(k_pairs[tid].y);\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_098f7c49e4d5",
                            "generation": 6,
                            "llm_reasoning": "Pack value and index into float2 to reduce register pressure and enable paired operations, using vector ALU units for simultaneous value/index updates during top-k selection."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.01610666885972023 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.005603227764368057 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.004883345682173967 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.004656756296753883 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.49930674\nMax relative difference among violations: 0.96875\n ACTUAL: array([[0.016107, 0.005603, 0.004883, 0.004657]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen6_0be9027da778",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen6",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Each thread loads 2 values, compares locally\nfloat val1 = (float)inp[base + tid];\nfloat val2 = (float)inp[base + tid + 32];\n\nfloat local_max = metal::max(val1, val2);\nuint local_idx = (val2 > val1) ? (tid + 32) : tid;\n\n// Use quad shuffle for hierarchical max-finding\n// First reduce within quads (4 threads)\nfloat quad_max = local_max;\nuint quad_idx = local_idx;\n\n#pragma unroll\nfor (uint offset = 1; offset < 4; offset *= 2) {\n    float other_val = simd_shuffle_down(quad_max, offset);\n    uint other_idx = simd_shuffle_down(quad_idx, offset);\n    if (other_val > quad_max) {\n        quad_max = other_val;\n        quad_idx = other_idx;\n    }\n}\n\n// Broadcast quad results to all threads in quad\nfloat running_max = simd_shuffle(quad_max, tid & ~3u);\nuint running_idx = simd_shuffle(quad_idx, tid & ~3u);\n\n// Top-k selection\nthread float k_vals[K];\nthread uint k_idx[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float best = simd_max(running_max);\n    bool wins = (running_max == best);\n    uint winner = simd_max(wins ? running_idx : 0u);\n    \n    k_vals[i] = best;\n    k_idx[i] = winner;\n    \n    running_max = wins ? -INFINITY : running_max;\n}\n\n// Fast approximate softmax\nfloat peak = k_vals[0];\nfloat sum_exp = 0.0f;\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    sum_exp += metal::fast::exp(k_vals[i] - peak);\n}\n\nfloat rcp = metal::fast::divide(1.0f, simd_sum(sum_exp));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(metal::fast::exp(k_vals[tid] - peak) * rcp);\n    indices[out_base + tid] = k_idx[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_098f7c49e4d5",
                            "generation": 6,
                            "llm_reasoning": "Exploit quad-group operations (simd4) to perform 8-way parallel reduction for D=64, processing 8 values per iteration instead of 2, then merge quad results using shuffle operations."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.01610666885972023 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.005603227764368057 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.004883345682173967 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.004656756296753883 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.49930674\nMax relative difference among violations: 0.96875\n ACTUAL: array([[0.016107, 0.005603, 0.004883, 0.004657]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen6_feed010c072d",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen6",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat val1 = (float)inp[base + tid];\nfloat val2 = (float)inp[base + tid + 32];\n\nfloat running_max = metal::max(val1, val2);\nuint running_idx = (val2 > val1) ? (tid + 32) : tid;\n\nthread float k_vals[K];\nthread uint k_idx[K];\n\n// First pass: find global peak\nfloat peak = simd_max(running_max);\n\n// Second pass: top-k with fused exp computation\nfloat running_exp_sum = 0.0f;\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float best = simd_max(running_max);\n    bool wins = (running_max == best);\n    uint winner = simd_max(wins ? running_idx : 0u);\n    \n    k_vals[i] = best;\n    k_idx[i] = winner;\n    \n    // Immediately compute exp and accumulate\n    float exp_val = metal::precise::exp(best - peak);\n    running_exp_sum += exp_val;\n    \n    running_max = wins ? -INFINITY : running_max;\n}\n\n// Sum is already accumulated, just normalize\nfloat sum_all = simd_sum(running_exp_sum);\nfloat rcp = metal::precise::divide(1.0f, sum_all);\n\nif (tid < K) {\n    uint out_base = row * K;\n    float exp_val = metal::precise::exp(k_vals[tid] - peak);\n    weights[out_base + tid] = (T)(exp_val * rcp);\n    indices[out_base + tid] = k_idx[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_098f7c49e4d5",
                            "generation": 6,
                            "llm_reasoning": "Interleave top-k selection with softmax accumulation by maintaining running exp-sum during selection phase, eliminating the separate softmax pass and improving instruction-level parallelism."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.01610666885972023 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.005603227764368057 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.004883345682173967 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.004656756296753883 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.49930674\nMax relative difference among violations: 0.96875\n ACTUAL: array([[0.016107, 0.005603, 0.004883, 0.004657]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        }
                      ]
                    },
                    {
                      "node_id": "gen4_a88cc417f0b6",
                      "candidate": {
                        "spec": {
                          "name": "kk_glm_topk_gating_gen4",
                          "input_names": [
                            "inp"
                          ],
                          "output_names": [
                            "weights",
                            "indices"
                          ],
                          "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load both values\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat my_val = metal::max(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Bitonic sort network for K=4 using SIMD shuffles\n// Stage 1: pairs (distance 1)\nfloat p1_val = simd_shuffle_xor(my_val, 1);\nuint p1_idx = simd_shuffle_xor(my_idx, 1);\nbool swap1 = ((tid & 1) == 0) ? (my_val < p1_val) : (my_val > p1_val);\nfloat s1_val = swap1 ? p1_val : my_val;\nuint s1_idx = swap1 ? p1_idx : my_idx;\n\n// Stage 2: pairs (distance 2) then (distance 1)\nfloat p2_val = simd_shuffle_xor(s1_val, 2);\nuint p2_idx = simd_shuffle_xor(s1_idx, 2);\nbool swap2 = ((tid & 2) == 0) ? (s1_val < p2_val) : (s1_val > p2_val);\nfloat s2_val = swap2 ? p2_val : s1_val;\nuint s2_idx = swap2 ? p2_idx : s1_idx;\n\nfloat p3_val = simd_shuffle_xor(s2_val, 1);\nuint p3_idx = simd_shuffle_xor(s2_idx, 1);\nbool swap3 = ((tid & 1) == 0) ? (s2_val < p3_val) : (s2_val > p3_val);\nfloat sorted_val = swap3 ? p3_val : s2_val;\nuint sorted_idx = swap3 ? p3_idx : s2_idx;\n\n// Top-4 are in first 4 threads (descending order)\nif (tid < K) {\n    float max_logit = simd_broadcast(sorted_val, 0);\n    float exp_val = metal::precise::exp(sorted_val - max_logit);\n    float sum_exp = simd_sum(exp_val);\n    float norm_weight = exp_val * metal::precise::divide(1.0f, sum_exp);\n    \n    uint out_base = row * K;\n    weights[out_base + tid] = (T)norm_weight;\n    indices[out_base + tid] = sorted_idx;\n}",
                          "header": "",
                          "threadgroup": [
                            256,
                            1,
                            1
                          ],
                          "template_params": [
                            [
                              "T",
                              "float32"
                            ]
                          ]
                        },
                        "parent_id": "gen3_aba888496883",
                        "generation": 4,
                        "llm_reasoning": "Use bitonic sorting network for top-K selection with fixed K=4, enabling fully unrolled comparator network that's branchless and highly predictable for GPU execution."
                      },
                      "visit_count": 5,
                      "max_reward": 0.0,
                      "prior": 0.25,
                      "eval_result": {
                        "compiled": true,
                        "correct": false,
                        "compile_error": null,
                        "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.3712911605834961 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.16707904636859894 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.31831198930740356 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.1433178335428238 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.16204493\nMax relative difference among violations: 1.0369743\n ACTUAL: array([[0.371291, 0.167079, 0.318312, 0.143318]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                        "timings_us": [],
                        "median_us": Infinity,
                        "reward": 0.0,
                        "speedup": 0.0
                      },
                      "children": [
                        {
                          "node_id": "gen7_715f2f4b6fad",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen7",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Specialized work assignment: each thread handles 2 values from its half\nuint half = tid / 16;  // 0 or 1\nuint local_tid = tid % 16;\nuint idx0 = half * 32 + local_tid;\nuint idx1 = idx0 + 16;\n\nfloat v0 = (float)inp[base + idx0];\nfloat v1 = (float)inp[base + idx1];\n\n// Each thread maintains top-2 from its pair\nfloat top0_val = metal::max(v0, v1);\nfloat top1_val = metal::min(v0, v1);\nuint top0_idx = (v0 >= v1) ? idx0 : idx1;\nuint top1_idx = (v0 < v1) ? idx0 : idx1;\n\n// Within each half (16 threads), find top-2 using shuffle reduction\nfor (uint stride = 8; stride >= 1; stride >>= 1) {\n    float peer0 = simd_shuffle_down(top0_val, stride);\n    float peer1 = simd_shuffle_down(top1_val, stride);\n    uint pidx0 = simd_shuffle_down(top0_idx, stride);\n    uint pidx1 = simd_shuffle_down(top1_idx, stride);\n    \n    if (local_tid < stride) {\n        // Merge two top-2 lists into one top-2\n        float vals[4] = {top0_val, top1_val, peer0, peer1};\n        uint idxs[4] = {top0_idx, top1_idx, pidx0, pidx1};\n        \n        // Simple 4-element sort for top-2\n        for (uint i = 0; i < 3; i++) {\n            for (uint j = i + 1; j < 4; j++) {\n                if (vals[j] > vals[i]) {\n                    float tmp_v = vals[i]; vals[i] = vals[j]; vals[j] = tmp_v;\n                    uint tmp_i = idxs[i]; idxs[i] = idxs[j]; idxs[j] = tmp_i;\n                }\n            }\n        }\n        top0_val = vals[0]; top0_idx = idxs[0];\n        top1_val = vals[1]; top1_idx = idxs[1];\n    }\n}\n\n// Broadcast half-results: thread 0 has top-2 from [0:32], thread 16 has top-2 from [32:64]\nfloat h0_v0 = simd_broadcast(top0_val, 0);\nfloat h0_v1 = simd_broadcast(top1_val, 0);\nuint h0_i0 = simd_broadcast(top0_idx, 0);\nuint h0_i1 = simd_broadcast(top1_idx, 0);\n\nfloat h1_v0 = simd_broadcast(top0_val, 16);\nfloat h1_v1 = simd_broadcast(top1_val, 16);\nuint h1_i0 = simd_broadcast(top0_idx, 16);\nuint h1_i1 = simd_broadcast(top1_idx, 16);\n\n// All threads merge 4 candidates to get global top-4\nfloat vals[4] = {h0_v0, h0_v1, h1_v0, h1_v1};\nuint idxs[4] = {h0_i0, h0_i1, h1_i0, h1_i1};\n\n// Sorting network for 4 elements (5 comparisons)\nif (vals[1] > vals[0]) { float tv = vals[0]; vals[0] = vals[1]; vals[1] = tv; uint ti = idxs[0]; idxs[0] = idxs[1]; idxs[1] = ti; }\nif (vals[3] > vals[2]) { float tv = vals[2]; vals[2] = vals[3]; vals[3] = tv; uint ti = idxs[2]; idxs[2] = idxs[3]; idxs[3] = ti; }\nif (vals[2] > vals[0]) { float tv = vals[0]; vals[0] = vals[2]; vals[2] = tv; uint ti = idxs[0]; idxs[0] = idxs[2]; idxs[2] = ti; }\nif (vals[3] > vals[1]) { float tv = vals[1]; vals[1] = vals[3]; vals[3] = tv; uint ti = idxs[1]; idxs[1] = idxs[3]; idxs[3] = ti; }\nif (vals[2] > vals[1]) { float tv = vals[1]; vals[1] = vals[2]; vals[2] = tv; uint ti = idxs[1]; idxs[1] = idxs[2]; idxs[2] = ti; }\n\n// Softmax over top-4 (all threads compute same result)\nfloat max_logit = vals[0];\nfloat sum_exp = 0.0f;\nfloat exp_vals[4];\nfor (uint i = 0; i < K; i++) {\n    exp_vals[i] = metal::precise::exp(vals[i] - max_logit);\n    sum_exp += exp_vals[i];\n}\nfloat inv_sum = metal::precise::divide(1.0f, sum_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_vals[tid] * inv_sum);\n    indices[out_base + tid] = idxs[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_a88cc417f0b6",
                            "generation": 7,
                            "llm_reasoning": "Assign specialized roles across the warp: threads 0-15 handle first half of D=64, threads 16-31 handle second half. Each group finds local top-2, then merge across groups using shuffle to get global top-4. This reduces shuffle operations compared to full bitonic sort."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "[metal::Device] Unable to build metal library from source\nmlx/backend/metal/kernels/utils.h:502:6: error: cannot combine with previous 'type-name' declaration specifier\nuint half = tid / 16;  // 0 or 1\n     ^\nmlx/backend/metal/kernels/utils.h:502:11: error: expected unqualified-id\nuint half = tid / 16;  // 0 or 1\n          ^\nmlx/backend/metal/kernels/utils.h:504:18: error: expected '(' for function-style cast or type construction\nuint idx0 = half * 32 + local_tid;\n            ~~~~ ^\n\n",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen7_2d49e0c7ce86",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen7",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Initialize with local sort\nbool local_swap = v1 > v0;\nfloat my_val = local_swap ? v1 : v0;\nuint my_idx = local_swap ? (tid + 32) : tid;\n\n// Odd-even merge network optimized for K=4\n// We only need to sort enough to guarantee top-4 end up in first 4 positions\n\n// Distance 16: merge two 16-element halves\nfloat p16 = simd_shuffle_xor(my_val, 16);\nuint i16 = simd_shuffle_xor(my_idx, 16);\nbool dir16 = (tid & 16) == 0;\nbool swap16 = dir16 ? (my_val < p16) : (my_val > p16);\nmy_val = swap16 ? p16 : my_val;\nmy_idx = swap16 ? i16 : my_idx;\n\n// Distance 8\nfloat p8 = simd_shuffle_xor(my_val, 8);\nuint i8 = simd_shuffle_xor(my_idx, 8);\nbool dir8 = (tid & 8) == 0;\nbool swap8 = dir8 ? (my_val < p8) : (my_val > p8);\nmy_val = swap8 ? p8 : my_val;\nmy_idx = swap8 ? i8 : my_idx;\n\n// Distance 4 (critical for top-4)\nfloat p4 = simd_shuffle_xor(my_val, 4);\nuint i4 = simd_shuffle_xor(my_idx, 4);\nbool dir4 = (tid & 4) == 0;\nbool swap4 = dir4 ? (my_val < p4) : (my_val > p4);\nmy_val = swap4 ? p4 : my_val;\nmy_idx = swap4 ? i4 : my_idx;\n\n// Distance 2\nfloat p2 = simd_shuffle_xor(my_val, 2);\nuint i2 = simd_shuffle_xor(my_idx, 2);\nbool dir2 = (tid & 2) == 0;\nbool swap2 = dir2 ? (my_val < p2) : (my_val > p2);\nmy_val = swap2 ? p2 : my_val;\nmy_idx = swap2 ? i2 : my_idx;\n\n// Distance 1\nfloat p1 = simd_shuffle_xor(my_val, 1);\nuint i1 = simd_shuffle_xor(my_idx, 1);\nbool dir1 = (tid & 1) == 0;\nbool swap1 = dir1 ? (my_val < p1) : (my_val > p1);\nmy_val = swap1 ? p1 : my_val;\nmy_idx = swap1 ? i1 : my_idx;\n\n// Final cleanup pass for guaranteed top-4\nif (tid < 8) {\n    float p4b = simd_shuffle_xor(my_val, 4);\n    uint i4b = simd_shuffle_xor(my_idx, 4);\n    bool swap4b = (tid < 4) ? (my_val < p4b) : (my_val > p4b);\n    my_val = swap4b ? p4b : my_val;\n    my_idx = swap4b ? i4b : my_idx;\n}\n\nif (tid < K) {\n    // Softmax distributed across K threads\n    float max_logit = simd_broadcast(my_val, 0);\n    float exp_val = metal::precise::exp(my_val - max_logit);\n    float sum_exp = simd_sum(exp_val);\n    \n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_val * metal::precise::divide(1.0f, sum_exp));\n    indices[out_base + tid] = my_idx;\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_a88cc417f0b6",
                            "generation": 7,
                            "llm_reasoning": "Use odd-even merge sort network which has better instruction-level parallelism than bitonic for small K. Predicate all swaps to minimize branch divergence. Process D=64 by having each thread compare its two values, then merge sorted pairs hierarchically."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 2 / 4 (50%)\nMismatch at indices:\n [0, 1]: 0.15626706182956696 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.17930328845977783 (ACTUAL), 0.15626706182956696 (DESIRED)\nMax absolute difference among violations: 0.02303623\nMax relative difference among violations: 0.14741576\n ACTUAL: array([[0.515413, 0.156267, 0.179303, 0.149016]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen7_e249dff05730",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen7",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat my_val = metal::max(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\nbool alive = true;\n\n// Tournament round 1: 32\u219216 (compare with distance 1)\nfloat peer = simd_shuffle_xor(my_val, 1);\nuint peer_idx = simd_shuffle_xor(my_idx, 1);\nif ((tid & 1) == 1) {\n    alive = (my_val > peer);\n} else {\n    if (peer > my_val) {\n        my_val = peer;\n        my_idx = peer_idx;\n    }\n}\n\n// Round 2: 16\u21928 (distance 2, only even threads from round 1)\nif (alive && (tid & 1) == 0) {\n    peer = simd_shuffle_xor(my_val, 2);\n    peer_idx = simd_shuffle_xor(my_idx, 2);\n    if ((tid & 2) == 2) {\n        alive = (my_val > peer);\n    } else if (peer > my_val) {\n        my_val = peer;\n        my_idx = peer_idx;\n    }\n}\n\n// Round 3: 8\u21924 (distance 4)\nif (alive && (tid & 3) == 0) {\n    peer = simd_shuffle_xor(my_val, 4);\n    peer_idx = simd_shuffle_xor(my_idx, 4);\n    if ((tid & 4) == 4) {\n        alive = (my_val > peer);\n    } else if (peer > my_val) {\n        my_val = peer;\n        my_idx = peer_idx;\n    }\n}\n\n// Round 4: 4\u2192top-4 finalists (keep all, just sort)\nif (tid < 8) {\n    peer = simd_shuffle_xor(my_val, 4);\n    peer_idx = simd_shuffle_xor(my_idx, 4);\n    bool should_swap = ((tid & 4) == 0) ? (my_val < peer) : (my_val > peer);\n    if (should_swap) {\n        my_val = peer;\n        my_idx = peer_idx;\n    }\n}\n\n// Final sort among top-4 using 3-stage bitonic\nif (tid < 4) {\n    // Stage 1: pairs\n    peer = simd_shuffle_xor(my_val, 1);\n    peer_idx = simd_shuffle_xor(my_idx, 1);\n    bool s1 = ((tid & 1) == 0) ? (my_val < peer) : (my_val > peer);\n    if (s1) { my_val = peer; my_idx = peer_idx; }\n    \n    // Stage 2: distance 2 then 1\n    peer = simd_shuffle_xor(my_val, 2);\n    peer_idx = simd_shuffle_xor(my_idx, 2);\n    bool s2 = ((tid & 2) == 0) ? (my_val < peer) : (my_val > peer);\n    if (s2) { my_val = peer; my_idx = peer_idx; }\n    \n    peer = simd_shuffle_xor(my_val, 1);\n    peer_idx = simd_shuffle_xor(my_idx, 1);\n    bool s3 = ((tid & 1) == 0) ? (my_val < peer) : (my_val > peer);\n    if (s3) { my_val = peer; my_idx = peer_idx; }\n    \n    // Softmax (only 4 threads active)\n    float max_logit = simd_broadcast(my_val, 0);\n    float exp_val = metal::precise::exp(my_val - max_logit);\n    float sum_exp = exp_val;\n    sum_exp += simd_shuffle(exp_val, 1);\n    sum_exp += simd_shuffle(exp_val, 2);\n    sum_exp += simd_shuffle(exp_val, 3);\n    \n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_val * metal::precise::divide(1.0f, sum_exp));\n    indices[out_base + tid] = my_idx;\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_a88cc417f0b6",
                            "generation": 7,
                            "llm_reasoning": "Exploit that we only need top-4 by using a tournament-style elimination with early exit. Each thread loads 2 values, performs 5 tournament rounds (32\u219216\u21928\u21924\u21922\u21921 winners per round), but only threads in top-4 participate in softmax. Reduces wasted computation on non-winning threads."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.40585166215896606 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.16263628005981445 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.40585166215896606 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.10928569734096527 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.2495846\nMax relative difference among violations: 1.597167\n ACTUAL: array([[0.405852, 0.162636, 0.405852, 0.109286]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen7_37a6bdb871a4",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen7",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Each thread gets max of its two values\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat my_val = metal::max(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Compute rank by counting how many peers have strictly greater values\nuint rank = 0;\nfor (uint offset = 1; offset < SG; offset <<= 1) {\n    float peer_val = simd_shuffle_xor(my_val, offset);\n    // Count peers strictly greater\n    if (peer_val > my_val) rank++;\n    // Tie-breaking: if equal, lower index wins\n    else if (peer_val == my_val) {\n        uint peer_idx = simd_shuffle_xor(my_idx, offset);\n        if (peer_idx < my_idx) rank++;\n    }\n}\n\n// Threads with rank < K are in top-K\nif (rank < K) {\n    // Gather all top-4 values for softmax via broadcasts\n    // Find which thread has each rank\n    float topk_vals[K];\n    uint topk_idxs[K];\n    \n    for (uint r = 0; r < K; r++) {\n        // Broadcast from thread with this rank\n        for (uint scan_tid = 0; scan_tid < SG; scan_tid++) {\n            uint peer_rank = simd_broadcast(rank, scan_tid);\n            if (peer_rank == r) {\n                topk_vals[r] = simd_broadcast(my_val, scan_tid);\n                topk_idxs[r] = simd_broadcast(my_idx, scan_tid);\n                break;\n            }\n        }\n    }\n    \n    // Softmax over gathered top-4\n    float max_logit = topk_vals[0];  // rank 0 has max value\n    float sum_exp = 0.0f;\n    float exp_vals[K];\n    for (uint i = 0; i < K; i++) {\n        exp_vals[i] = metal::precise::exp(topk_vals[i] - max_logit);\n        sum_exp += exp_vals[i];\n    }\n    float inv_sum = metal::precise::divide(1.0f, sum_exp);\n    \n    // Each top-4 thread writes its own output\n    uint out_base = row * K;\n    weights[out_base + rank] = (T)(exp_vals[rank] * inv_sum);\n    indices[out_base + rank] = my_idx;\n}",
                              "header": "",
                              "threadgroup": [
                                32,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_a88cc417f0b6",
                            "generation": 7,
                            "llm_reasoning": "Use rank-based selection instead of value sorting. Each thread computes how many values are greater than its own using SIMD ballot-style comparison, determines if it's in top-4 by rank, then only top-4 threads participate in softmax. Reduces comparison operations for K=4 case."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.17088639736175537 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.4697912037372589 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.22682783007621765 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.13249461352825165 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.344527\nMax relative difference among violations: 1.6200925\n ACTUAL: array([[0.170886, 0.469791, 0.226828, 0.132495]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        }
                      ]
                    },
                    {
                      "node_id": "gen4_921af78bb7b6",
                      "candidate": {
                        "spec": {
                          "name": "kk_glm_topk_gating_gen4",
                          "input_names": [
                            "inp"
                          ],
                          "output_names": [
                            "weights",
                            "indices"
                          ],
                          "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Initialize with first 2 values per thread\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Build initial top-K with min-heap property\nthread float heap_vals[K];\nthread uint heap_idx[K];\n\nfloat my_max = metal::max(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Find top-K across SIMD group using reduction\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float global_max = simd_max(my_max);\n    bool is_winner = (my_max == global_max);\n    uint winner_lane = simd_max(is_winner ? my_idx : 0u);\n    \n    heap_vals[k] = global_max;\n    heap_idx[k] = winner_lane;\n    \n    // Branch-free invalidation\n    my_max = metal::select(my_max, -INFINITY, is_winner);\n}\n\n// Softmax with fused accumulation\nfloat logit_max = heap_vals[0];\nfloat running_sum = 0.0f;\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float delta = heap_vals[k] - logit_max;\n    heap_vals[k] = metal::fast::exp(delta);\n    running_sum += heap_vals[k];\n}\n\nfloat total = simd_sum(running_sum);\nfloat scale = metal::fast::divide(1.0f, total);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(heap_vals[tid] * scale);\n    indices[out_base + tid] = heap_idx[tid];\n}",
                          "header": "",
                          "threadgroup": [
                            256,
                            1,
                            1
                          ],
                          "template_params": [
                            [
                              "T",
                              "float32"
                            ]
                          ]
                        },
                        "parent_id": "gen3_aba888496883",
                        "generation": 4,
                        "llm_reasoning": "Exploit fast path for small K=4 by maintaining a min-heap of top-K in registers during single-pass scan, avoiding full sorting overhead with branch-free heap updates."
                      },
                      "visit_count": 13,
                      "max_reward": 5.391555050501889,
                      "prior": 0.25,
                      "eval_result": {
                        "compiled": true,
                        "correct": false,
                        "compile_error": null,
                        "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.01610666885972023 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.005603227764368057 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.004883345682173967 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.004656756296753883 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.49930674\nMax relative difference among violations: 0.96875\n ACTUAL: array([[0.016107, 0.005603, 0.004883, 0.004657]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                        "timings_us": [],
                        "median_us": Infinity,
                        "reward": 0.0,
                        "speedup": 0.0
                      },
                      "children": [
                        {
                          "node_id": "gen8_6683d707a647",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen8",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load 2 values per thread\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Local top-2 selection\nfloat local_max0 = metal::max(v0, v1);\nfloat local_max1 = metal::min(v0, v1);\nuint local_idx0 = (v0 >= v1) ? tid : (tid + 32);\nuint local_idx1 = (v0 < v1) ? tid : (tid + 32);\n\n// Hierarchical merge using simd_shuffle (5 iterations for 32 threads)\nthread float heap_vals[K];\nthread uint heap_idx[K];\n\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float peer_max0 = simd_shuffle(local_max0, tid ^ offset);\n    uint peer_idx0 = simd_shuffle(local_idx0, tid ^ offset);\n    \n    if (peer_max0 > local_max1) {\n        if (peer_max0 > local_max0) {\n            local_max1 = local_max0;\n            local_idx1 = local_idx0;\n            local_max0 = peer_max0;\n            local_idx0 = peer_idx0;\n        } else {\n            local_max1 = peer_max0;\n            local_idx1 = peer_idx0;\n        }\n    }\n}\n\n// Broadcast top-K from lane 0\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    heap_vals[k] = simd_broadcast(k < 2 ? (k == 0 ? local_max0 : local_max1) : -INFINITY, 0);\n    heap_idx[k] = simd_broadcast(k < 2 ? (k == 0 ? local_idx0 : local_idx1) : 0u, 0);\n}\n\n// Collect remaining top-K candidates\nif (tid == 0) {\n    thread float all_vals[8];\n    thread uint all_idx[8];\n    all_vals[0] = local_max0; all_idx[0] = local_idx0;\n    all_vals[1] = local_max1; all_idx[1] = local_idx1;\n    \n    // Gather top-2 from other key lanes\n    for (uint i = 1; i < 4; ++i) {\n        all_vals[i*2] = simd_shuffle(local_max0, i * 8);\n        all_idx[i*2] = simd_shuffle(local_idx0, i * 8);\n        all_vals[i*2+1] = simd_shuffle(local_max1, i * 8);\n        all_idx[i*2+1] = simd_shuffle(local_idx1, i * 8);\n    }\n    \n    // Selection sort for top-K\n    for (uint k = 0; k < K; ++k) {\n        uint max_pos = k;\n        for (uint j = k + 1; j < 8; ++j) {\n            if (all_vals[j] > all_vals[max_pos]) max_pos = j;\n        }\n        heap_vals[k] = all_vals[max_pos];\n        heap_idx[k] = all_idx[max_pos];\n        all_vals[max_pos] = -INFINITY;\n    }\n}\n\n// Broadcast final top-K\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    heap_vals[k] = simd_broadcast(heap_vals[k], 0);\n    heap_idx[k] = simd_broadcast(heap_idx[k], 0);\n}\n\n// Softmax\nfloat logit_max = heap_vals[0];\nfloat sum_exp = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    heap_vals[k] = metal::fast::exp(heap_vals[k] - logit_max);\n    sum_exp += heap_vals[k];\n}\nfloat inv_sum = metal::fast::divide(1.0f, sum_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(heap_vals[tid] * inv_sum);\n    indices[out_base + tid] = heap_idx[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                256,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_921af78bb7b6",
                            "generation": 8,
                            "llm_reasoning": "Exploit warp-level parallelism by having each thread compute local top-K from 2 values, then merge results hierarchically using simd_shuffle for log-depth reduction."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.6860103011131287 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.23865096271038055 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.03766937926411629 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.03766937926411629 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.1705969\nMax relative difference among violations: 0.7589423\n ACTUAL: array([[0.68601 , 0.238651, 0.037669, 0.037669]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen8_11a0ea524cb3",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen8",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nthreadgroup float shared_vals[64];\nthreadgroup uint shared_idx[64];\n\n// Cooperative load into threadgroup memory\nshared_vals[tid] = (float)inp[base + tid];\nshared_vals[tid + 32] = (float)inp[base + tid + 32];\nshared_idx[tid] = tid;\nshared_idx[tid + 32] = tid + 32;\n\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nthread float heap_vals[K];\nthread uint heap_idx[K];\n\nif (tid == 0) {\n    // Initialize heap with first K elements\n    #pragma unroll\n    for (uint k = 0; k < K; ++k) {\n        heap_vals[k] = shared_vals[k];\n        heap_idx[k] = shared_idx[k];\n    }\n    \n    // Build max-heap\n    for (uint i = K; i < D; ++i) {\n        float val = shared_vals[i];\n        if (val > heap_vals[K-1]) {\n            // Insert and bubble up\n            heap_vals[K-1] = val;\n            heap_idx[K-1] = i;\n            \n            // Bubble up\n            for (uint k = K-1; k > 0; --k) {\n                if (heap_vals[k] > heap_vals[k-1]) {\n                    float tmp_v = heap_vals[k];\n                    uint tmp_i = heap_idx[k];\n                    heap_vals[k] = heap_vals[k-1];\n                    heap_idx[k] = heap_idx[k-1];\n                    heap_vals[k-1] = tmp_v;\n                    heap_idx[k-1] = tmp_i;\n                }\n            }\n        }\n    }\n}\n\n// Broadcast results\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    heap_vals[k] = simd_broadcast(heap_vals[k], 0);\n    heap_idx[k] = simd_broadcast(heap_idx[k], 0);\n}\n\n// Parallel softmax computation\nfloat logit_max = heap_vals[0];\nthread float exp_vals[K];\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    exp_vals[k] = metal::fast::exp(heap_vals[k] - logit_max);\n}\n\nfloat partial_sum = 0.0f;\nif (tid < K) {\n    partial_sum = exp_vals[tid];\n}\nfloat total_sum = simd_sum(partial_sum);\nfloat inv_sum = metal::fast::divide(1.0f, total_sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_vals[tid] * inv_sum);\n    indices[out_base + tid] = heap_idx[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                256,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_921af78bb7b6",
                            "generation": 8,
                            "llm_reasoning": "Use threadgroup memory to stage all D=64 values, enabling random access for compare-and-swap based heap construction without simd_shuffle dependencies."
                          },
                          "visit_count": 9,
                          "max_reward": 5.391555050501889,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": true,
                            "compile_error": null,
                            "correctness_error": null,
                            "timings_us": [
                              167.542,
                              153.167,
                              153.25,
                              153.375,
                              143.917,
                              161.25,
                              154.042,
                              176.167,
                              198.458,
                              159.708,
                              156.5,
                              155.583,
                              156.792,
                              152.666,
                              175.834,
                              159.375,
                              722.125,
                              485.0,
                              722.708,
                              523.125
                            ],
                            "median_us": 159.708,
                            "reward": 3.3800296694724867,
                            "speedup": 4.429696696471059
                          },
                          "children": [
                            {
                              "node_id": "gen9_cdce14a003a8",
                              "candidate": {
                                "spec": {
                                  "name": "kk_glm_topk_gating_gen9",
                                  "input_names": [
                                    "inp"
                                  ],
                                  "output_names": [
                                    "weights",
                                    "indices"
                                  ],
                                  "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Each thread loads 2 values (D=64, SG=32)\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nuint i0 = tid;\nuint i1 = tid + 32;\n\n// Parallel reduction: each thread finds its local max\nfloat local_max = fmax(v0, v1);\nuint local_idx = (v0 >= v1) ? i0 : i1;\n\n// SIMD-level top-4 using tournament tree\nthread float vals[K] = {-INFINITY, -INFINITY, -INFINITY, -INFINITY};\nthread uint idxs[K] = {0, 0, 0, 0};\n\nvals[0] = local_max;\nidxs[0] = local_idx;\n\n// Round 1: find global max via SIMD shuffle tournament\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float other_val = simd_shuffle_down(vals[0], offset);\n    uint other_idx = simd_shuffle_down(idxs[0], offset);\n    if (other_val > vals[0]) {\n        vals[0] = other_val;\n        idxs[0] = other_idx;\n    }\n}\nvals[0] = simd_broadcast(vals[0], 0);\nidxs[0] = simd_broadcast(idxs[0], 0);\n\n// Mask out winner for round 2\nbool masked0 = (local_idx == idxs[0]);\nfloat masked_max1 = masked0 ? -INFINITY : local_max;\nvals[1] = masked_max1;\nidxs[1] = masked0 ? 0 : local_idx;\n\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float other_val = simd_shuffle_down(vals[1], offset);\n    uint other_idx = simd_shuffle_down(idxs[1], offset);\n    if (other_val > vals[1]) {\n        vals[1] = other_val;\n        idxs[1] = other_idx;\n    }\n}\nvals[1] = simd_broadcast(vals[1], 0);\nidxs[1] = simd_broadcast(idxs[1], 0);\n\n// Round 3\nbool masked1 = (local_idx == idxs[0]) || (local_idx == idxs[1]);\nfloat masked_max2 = masked1 ? -INFINITY : local_max;\nvals[2] = masked_max2;\nidxs[2] = masked1 ? 0 : local_idx;\n\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float other_val = simd_shuffle_down(vals[2], offset);\n    uint other_idx = simd_shuffle_down(idxs[2], offset);\n    if (other_val > vals[2]) {\n        vals[2] = other_val;\n        idxs[2] = other_idx;\n    }\n}\nvals[2] = simd_broadcast(vals[2], 0);\nidxs[2] = simd_broadcast(idxs[2], 0);\n\n// Round 4\nbool masked2 = (local_idx == idxs[0]) || (local_idx == idxs[1]) || (local_idx == idxs[2]);\nfloat masked_max3 = masked2 ? -INFINITY : local_max;\nvals[3] = masked_max3;\nidxs[3] = masked2 ? 0 : local_idx;\n\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float other_val = simd_shuffle_down(vals[3], offset);\n    uint other_idx = simd_shuffle_down(idxs[3], offset);\n    if (other_val > vals[3]) {\n        vals[3] = other_val;\n        idxs[3] = other_idx;\n    }\n}\nvals[3] = simd_broadcast(vals[3], 0);\nidxs[3] = simd_broadcast(idxs[3], 0);\n\n// Parallel softmax\nfloat max_val = vals[0];\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::fast::exp(vals[k] - max_val);\n    vals[k] = e;\n    sum += e;\n}\nfloat inv_sum = metal::fast::divide(1.0f, sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(vals[tid] * inv_sum);\n    indices[out_base + tid] = idxs[tid];\n}",
                                  "header": "",
                                  "threadgroup": [
                                    32,
                                    1,
                                    1
                                  ],
                                  "template_params": [
                                    [
                                      "T",
                                      "float32"
                                    ]
                                  ]
                                },
                                "parent_id": "gen8_11a0ea524cb3",
                                "generation": 9,
                                "llm_reasoning": "Use dual-heap approach: maintain both max-heap (for values) and min-heap (for indices) with explicit sorting network for K=4 to eliminate conditional branches."
                              },
                              "visit_count": 1,
                              "max_reward": 1.214406567814283,
                              "prior": 0.25,
                              "eval_result": {
                                "compiled": true,
                                "correct": true,
                                "compile_error": null,
                                "correctness_error": null,
                                "timings_us": [
                                  531.5,
                                  589.084,
                                  571.75,
                                  571.875,
                                  593.875,
                                  583.666,
                                  662.666,
                                  550.708,
                                  691.75,
                                  537.333,
                                  597.541,
                                  555.0,
                                  551.625,
                                  589.167,
                                  547.75,
                                  588.458,
                                  588.916,
                                  698.75,
                                  501.958,
                                  586.667
                                ],
                                "median_us": 586.667,
                                "reward": 1.214406567814283,
                                "speedup": 1.2058936330149812
                              },
                              "children": []
                            },
                            {
                              "node_id": "gen9_f6ad3cb4c0e0",
                              "candidate": {
                                "spec": {
                                  "name": "kk_glm_topk_gating_gen9",
                                  "input_names": [
                                    "inp"
                                  ],
                                  "output_names": [
                                    "weights",
                                    "indices"
                                  ],
                                  "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load 2 values per thread\nfloat vals[2];\nvals[0] = (float)inp[base + tid];\nvals[1] = (float)inp[base + tid + 32];\n\n// Find quad-local top-1 using quad_shuffle\nuint quad_id = tid / 4;\nuint lane = tid % 4;\n\nfloat quad_max = fmax(vals[0], vals[1]);\nuint quad_idx = (vals[0] >= vals[1]) ? tid : (tid + 32);\n\n#pragma unroll\nfor (uint i = 0; i < 2; ++i) {\n    float other_val = quad_shuffle(quad_max, (lane + 1 + i) % 4);\n    uint other_idx = quad_shuffle(quad_idx, (lane + 1 + i) % 4);\n    if (other_val > quad_max) {\n        quad_max = other_val;\n        quad_idx = other_idx;\n    }\n}\n\n// Broadcast quad winners to all lanes in quad\nquad_max = quad_shuffle(quad_max, 0);\nquad_idx = quad_shuffle(quad_idx, 0);\n\n// Now we have 8 quad winners (tid 0, 4, 8, 12, 16, 20, 24, 28)\n// Merge using SIMD shuffle across quads\nfloat simd_max = quad_max;\nuint simd_idx = quad_idx;\n\nif (lane == 0) {\n    #pragma unroll\n    for (uint offset = 4; offset < 32; offset += 4) {\n        float other_val = simd_shuffle_down(simd_max, offset);\n        uint other_idx = simd_shuffle_down(simd_idx, offset);\n        if (other_val > simd_max) {\n            simd_max = other_val;\n            simd_idx = other_idx;\n        }\n    }\n}\n\n// Broadcast final top-1\nthread float top_vals[K];\nthread uint top_idxs[K];\n\ntop_vals[0] = simd_broadcast(simd_max, 0);\ntop_idxs[0] = simd_broadcast(simd_idx, 0);\n\n// Repeat for top-2, top-3, top-4 with masking\nfor (uint round = 1; round < K; ++round) {\n    bool is_masked = false;\n    #pragma unroll\n    for (uint p = 0; p < round; ++p) {\n        if (tid == top_idxs[p] || (tid + 32) == top_idxs[p]) {\n            is_masked = true;\n        }\n    }\n    \n    float masked_max = is_masked ? -INFINITY : fmax(vals[0], vals[1]);\n    uint masked_idx = is_masked ? 0 : ((vals[0] >= vals[1]) ? tid : (tid + 32));\n    \n    // Quad reduction\n    float q_max = masked_max;\n    uint q_idx = masked_idx;\n    #pragma unroll\n    for (uint i = 0; i < 2; ++i) {\n        float other = quad_shuffle(q_max, (lane + 1 + i) % 4);\n        uint other_i = quad_shuffle(q_idx, (lane + 1 + i) % 4);\n        if (other > q_max) {\n            q_max = other;\n            q_idx = other_i;\n        }\n    }\n    q_max = quad_shuffle(q_max, 0);\n    q_idx = quad_shuffle(q_idx, 0);\n    \n    // SIMD reduction\n    if (lane == 0) {\n        #pragma unroll\n        for (uint offset = 4; offset < 32; offset += 4) {\n            float other = simd_shuffle_down(q_max, offset);\n            uint other_i = simd_shuffle_down(q_idx, offset);\n            if (other > q_max) {\n                q_max = other;\n                q_idx = other_i;\n            }\n        }\n    }\n    \n    top_vals[round] = simd_broadcast(q_max, 0);\n    top_idxs[round] = simd_broadcast(q_idx, 0);\n}\n\n// Softmax\nfloat max_val = top_vals[0];\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::fast::exp(top_vals[k] - max_val);\n    top_vals[k] = e;\n    sum += e;\n}\nfloat inv_sum = metal::fast::divide(1.0f, sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idxs[tid];\n}",
                                  "header": "",
                                  "threadgroup": [
                                    32,
                                    1,
                                    1
                                  ],
                                  "template_params": [
                                    [
                                      "T",
                                      "float32"
                                    ]
                                  ]
                                },
                                "parent_id": "gen8_11a0ea524cb3",
                                "generation": 9,
                                "llm_reasoning": "Use warp-aggregated atomic voting: each thread compares all 64 values in registers, broadcasts candidate maxes via quad_shuffle, then merges quad-level winners using SIMD prefix operations."
                              },
                              "visit_count": 5,
                              "max_reward": 5.391555050501889,
                              "prior": 0.25,
                              "eval_result": {
                                "compiled": true,
                                "correct": true,
                                "compile_error": null,
                                "correctness_error": null,
                                "timings_us": [
                                  139.916,
                                  161.5,
                                  134.458,
                                  135.958,
                                  133.542,
                                  126.0,
                                  127.375,
                                  135.417,
                                  136.375,
                                  129.542,
                                  124.875,
                                  124.708,
                                  122.917,
                                  139.334,
                                  113.708,
                                  129.541,
                                  122.25,
                                  134.417,
                                  134.584,
                                  124.416
                                ],
                                "median_us": 133.542,
                                "reward": 5.391555050501889,
                                "speedup": 5.297644186847584
                              },
                              "children": [
                                {
                                  "node_id": "gen10_790bf6e10a36",
                                  "candidate": {
                                    "spec": {
                                      "name": "kk_glm_topk_gating_gen10",
                                      "input_names": [
                                        "inp"
                                      ],
                                      "output_names": [
                                        "weights",
                                        "indices"
                                      ],
                                      "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load 2 values per thread\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// XOR-based butterfly reduction for top-1\nfloat my_max = fmax(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Butterfly network using XOR shuffles (log2(32) = 5 steps)\n#pragma unroll\nfor (uint offset = 16; offset > 0; offset >>= 1) {\n    float other_val = quad_shuffle_xor(my_max, offset);\n    uint other_idx = quad_shuffle_xor(my_idx, offset);\n    if (other_val > my_max) {\n        my_max = other_val;\n        my_idx = other_idx;\n    }\n}\n\nthread float top_vals[K];\nthread uint top_idxs[K];\ntop_vals[0] = my_max;\ntop_idxs[0] = my_idx;\n\n// Subsequent rounds with masking\nfor (uint round = 1; round < K; ++round) {\n    bool masked = false;\n    #pragma unroll\n    for (uint p = 0; p < round; ++p) {\n        masked = masked || (tid == top_idxs[p]) || ((tid + 32) == top_idxs[p]);\n    }\n    \n    float curr_max = masked ? -INFINITY : fmax(v0, v1);\n    uint curr_idx = masked ? 0 : ((v0 >= v1) ? tid : (tid + 32));\n    \n    #pragma unroll\n    for (uint offset = 16; offset > 0; offset >>= 1) {\n        float other_val = quad_shuffle_xor(curr_max, offset);\n        uint other_idx = quad_shuffle_xor(curr_idx, offset);\n        if (other_val > curr_max) {\n            curr_max = other_val;\n            curr_idx = other_idx;\n        }\n    }\n    \n    top_vals[round] = curr_max;\n    top_idxs[round] = curr_idx;\n}\n\n// Softmax with fast math\nfloat max_val = top_vals[0];\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::fast::exp(top_vals[k] - max_val);\n    top_vals[k] = e;\n    sum += e;\n}\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * metal::fast::divide(1.0f, sum));\n    indices[out_base + tid] = top_idxs[tid];\n}",
                                      "header": "",
                                      "threadgroup": [
                                        32,
                                        1,
                                        1
                                      ],
                                      "template_params": [
                                        [
                                          "T",
                                          "float32"
                                        ]
                                      ]
                                    },
                                    "parent_id": "gen9_f6ad3cb4c0e0",
                                    "generation": 10,
                                    "llm_reasoning": "Use quad_shuffle_xor for lockstep parallel comparisons, eliminating sequential quad reduction loops and enabling simultaneous 4-way comparisons across all quads in a single wavefront operation."
                                  },
                                  "visit_count": 1,
                                  "max_reward": 0.0,
                                  "prior": 0.25,
                                  "eval_result": {
                                    "compiled": true,
                                    "correct": false,
                                    "compile_error": null,
                                    "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.2972598075866699 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.2548440992832184 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.22394807636737823 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.22394807636737823 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.2181536\nMax relative difference among violations: 0.5028438\n ACTUAL: array([[0.29726 , 0.254844, 0.223948, 0.223948]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                                    "timings_us": [],
                                    "median_us": Infinity,
                                    "reward": 0.0,
                                    "speedup": 0.0
                                  },
                                  "children": []
                                },
                                {
                                  "node_id": "gen10_4f3cc9bfeb14",
                                  "candidate": {
                                    "spec": {
                                      "name": "kk_glm_topk_gating_gen10",
                                      "input_names": [
                                        "inp"
                                      ],
                                      "output_names": [
                                        "weights",
                                        "indices"
                                      ],
                                      "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// First pass: estimate top-K threshold from first 32 values\nfloat threshold = v0;\n#pragma unroll\nfor (uint offset = 16; offset > 0; offset >>= 1) {\n    float other = simd_shuffle_xor(threshold, offset);\n    threshold = fmax(threshold, other);\n}\n// Broadcast max of first 32 to all threads\nthreshold = simd_broadcast(threshold, 0);\n\n// Second pass: only process v1 if it exceeds 90% of first-half max\nfloat candidates[2];\nuint candidate_idxs[2];\nuint candidate_count = 1;\ncandidates[0] = v0;\ncandidate_idxs[0] = tid;\n\nif (v1 > threshold * 0.9f) {\n    candidates[1] = v1;\n    candidate_idxs[1] = tid + 32;\n    candidate_count = 2;\n}\n\nthread float top_vals[K];\nthread uint top_idxs[K];\n\nfor (uint round = 0; round < K; ++round) {\n    float my_max = -INFINITY;\n    uint my_idx = 0;\n    \n    for (uint i = 0; i < candidate_count; ++i) {\n        bool is_masked = false;\n        #pragma unroll\n        for (uint p = 0; p < round; ++p) {\n            if (candidate_idxs[i] == top_idxs[p]) {\n                is_masked = true;\n            }\n        }\n        if (!is_masked && candidates[i] > my_max) {\n            my_max = candidates[i];\n            my_idx = candidate_idxs[i];\n        }\n    }\n    \n    #pragma unroll\n    for (uint offset = 16; offset > 0; offset >>= 1) {\n        float other_val = simd_shuffle_xor(my_max, offset);\n        uint other_idx = simd_shuffle_xor(my_idx, offset);\n        if (other_val > my_max) {\n            my_max = other_val;\n            my_idx = other_idx;\n        }\n    }\n    \n    top_vals[round] = my_max;\n    top_idxs[round] = my_idx;\n}\n\n// Softmax\nfloat max_val = top_vals[0];\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::fast::exp(top_vals[k] - max_val);\n    top_vals[k] = e;\n    sum += e;\n}\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * metal::fast::divide(1.0f, sum));\n    indices[out_base + tid] = top_idxs[tid];\n}",
                                      "header": "",
                                      "threadgroup": [
                                        32,
                                        1,
                                        1
                                      ],
                                      "template_params": [
                                        [
                                          "T",
                                          "float32"
                                        ]
                                      ]
                                    },
                                    "parent_id": "gen9_f6ad3cb4c0e0",
                                    "generation": 10,
                                    "llm_reasoning": "Exploit early-exit pruning by computing approximate magnitude thresholds from first 32 values, allowing threads to skip comparison of clearly non-competitive candidates in the second half, reducing effective search space."
                                  },
                                  "visit_count": 1,
                                  "max_reward": 0.0,
                                  "prior": 0.25,
                                  "eval_result": {
                                    "compiled": true,
                                    "correct": false,
                                    "compile_error": null,
                                    "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.6251656413078308 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.1695910394191742 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.1061181128025055 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.0991252139210701 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.10975224\nMax relative difference among violations: 0.33480245\n ACTUAL: array([[0.625166, 0.169591, 0.106118, 0.099125]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                                    "timings_us": [],
                                    "median_us": Infinity,
                                    "reward": 0.0,
                                    "speedup": 0.0
                                  },
                                  "children": []
                                },
                                {
                                  "node_id": "gen10_ee22e6d5140b",
                                  "candidate": {
                                    "spec": {
                                      "name": "kk_glm_topk_gating_gen10",
                                      "input_names": [
                                        "inp"
                                      ],
                                      "output_names": [
                                        "weights",
                                        "indices"
                                      ],
                                      "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Sort local pair\nfloat my_max = fmax(v0, v1);\nfloat my_min = fmin(v0, v1);\nuint idx_max = (v0 >= v1) ? tid : (tid + 32);\nuint idx_min = (v0 >= v1) ? (tid + 32) : tid;\n\n// Parallel bitonic sort for top-K extraction\n// Each thread holds 2 sorted elements, merge to extract K=4\n\n// Stage 1: Compare-exchange across distance 1\nfloat other_max = simd_shuffle_xor(my_max, 1);\nfloat other_min = simd_shuffle_xor(my_min, 1);\nuint other_idx_max = simd_shuffle_xor(idx_max, 1);\nuint other_idx_min = simd_shuffle_xor(idx_min, 1);\n\nbool swap = (tid & 1) ? (my_max < other_max) : (my_max > other_max);\nif (swap) {\n    float tmp = my_max; my_max = other_max; other_max = tmp;\n    uint tmp_idx = idx_max; idx_max = other_idx_max; other_idx_max = tmp_idx;\n}\n\n// Collect top-4 from tid=0,1 (holds 4 highest)\nthread float top_vals[K];\nthread uint top_idxs[K];\n\nif (tid == 0) {\n    top_vals[0] = my_max;\n    top_vals[1] = my_min;\n    top_idxs[0] = idx_max;\n    top_idxs[1] = idx_min;\n} else if (tid == 1) {\n    top_vals[2] = my_max;\n    top_vals[3] = my_min;\n    top_idxs[2] = idx_max;\n    top_idxs[3] = idx_min;\n}\n\n// Broadcast from tid 0,1 to all threads\nif (tid >= 2) {\n    top_vals[0] = simd_broadcast(top_vals[0], 0);\n    top_vals[1] = simd_broadcast(top_vals[1], 0);\n    top_vals[2] = simd_broadcast(top_vals[2], 1);\n    top_vals[3] = simd_broadcast(top_vals[3], 1);\n    top_idxs[0] = simd_broadcast(top_idxs[0], 0);\n    top_idxs[1] = simd_broadcast(top_idxs[1], 0);\n    top_idxs[2] = simd_broadcast(top_idxs[2], 1);\n    top_idxs[3] = simd_broadcast(top_idxs[3], 1);\n}\n\n// Manual 4-element sort\n#pragma unroll\nfor (uint i = 0; i < K - 1; ++i) {\n    #pragma unroll\n    for (uint j = i + 1; j < K; ++j) {\n        if (top_vals[j] > top_vals[i]) {\n            float tmp_v = top_vals[i];\n            top_vals[i] = top_vals[j];\n            top_vals[j] = tmp_v;\n            uint tmp_i = top_idxs[i];\n            top_idxs[i] = top_idxs[j];\n            top_idxs[j] = tmp_i;\n        }\n    }\n}\n\n// Softmax\nfloat max_val = top_vals[0];\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::fast::exp(top_vals[k] - max_val);\n    top_vals[k] = e;\n    sum += e;\n}\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * metal::fast::divide(1.0f, sum));\n    indices[out_base + tid] = top_idxs[tid];\n}",
                                      "header": "",
                                      "threadgroup": [
                                        32,
                                        1,
                                        1
                                      ],
                                      "template_params": [
                                        [
                                          "T",
                                          "float32"
                                        ]
                                      ]
                                    },
                                    "parent_id": "gen9_f6ad3cb4c0e0",
                                    "generation": 10,
                                    "llm_reasoning": "Use parallel prefix scan to compute cumulative max positions, enabling lock-free parallel extraction of top-K indices without iterative masking rounds, trading K sequential passes for single-pass parallel selection."
                                  },
                                  "visit_count": 1,
                                  "max_reward": 0.0,
                                  "prior": 0.25,
                                  "eval_result": {
                                    "compiled": true,
                                    "correct": false,
                                    "compile_error": null,
                                    "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.3725558817386627 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.39764443039894104 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.14498040080070496 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.07437153160572052 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.21834114\nMax relative difference among violations: 1.2177197\n ACTUAL: array([[0.372556, 0.397644, 0.14498 , 0.074372]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                                    "timings_us": [],
                                    "median_us": Infinity,
                                    "reward": 0.0,
                                    "speedup": 0.0
                                  },
                                  "children": []
                                },
                                {
                                  "node_id": "gen10_7a4816ad51d5",
                                  "candidate": {
                                    "spec": {
                                      "name": "kk_glm_topk_gating_gen10",
                                      "input_names": [
                                        "inp"
                                      ],
                                      "output_names": [
                                        "weights",
                                        "indices"
                                      ],
                                      "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\nthread float top_vals[K];\nthread uint top_idxs[K];\nthread float exp_vals[K];\nfloat running_exp_sum = 0.0f;\nfloat global_max = -INFINITY;\n\nfor (uint round = 0; round < K; ++round) {\n    bool masked_0 = false;\n    bool masked_1 = false;\n    #pragma unroll\n    for (uint p = 0; p < round; ++p) {\n        masked_0 = masked_0 || (tid == top_idxs[p]);\n        masked_1 = masked_1 || ((tid + 32) == top_idxs[p]);\n    }\n    \n    float my_max = -INFINITY;\n    uint my_idx = 0;\n    \n    if (!masked_0 && v0 > my_max) {\n        my_max = v0;\n        my_idx = tid;\n    }\n    if (!masked_1 && v1 > my_max) {\n        my_max = v1;\n        my_idx = tid + 32;\n    }\n    \n    #pragma unroll\n    for (uint offset = 16; offset > 0; offset >>= 1) {\n        float other_val = simd_shuffle_xor(my_max, offset);\n        uint other_idx = simd_shuffle_xor(my_idx, offset);\n        if (other_val > my_max) {\n            my_max = other_val;\n            my_idx = other_idx;\n        }\n    }\n    \n    top_vals[round] = my_max;\n    top_idxs[round] = my_idx;\n    \n    // Update global max and recompute all exp values\n    if (round == 0) {\n        global_max = my_max;\n    }\n    \n    if (my_max > global_max) {\n        // Rescale previous exp values\n        float scale = metal::fast::exp(global_max - my_max);\n        #pragma unroll\n        for (uint k = 0; k < round; ++k) {\n            exp_vals[k] *= scale;\n        }\n        running_exp_sum *= scale;\n        global_max = my_max;\n    }\n    \n    exp_vals[round] = metal::fast::exp(my_max - global_max);\n    running_exp_sum += exp_vals[round];\n}\n\n// Final normalization\nfloat inv_sum = metal::fast::divide(1.0f, running_exp_sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idxs[tid];\n}",
                                      "header": "",
                                      "threadgroup": [
                                        32,
                                        1,
                                        1
                                      ],
                                      "template_params": [
                                        [
                                          "T",
                                          "float32"
                                        ]
                                      ]
                                    },
                                    "parent_id": "gen9_f6ad3cb4c0e0",
                                    "generation": 10,
                                    "llm_reasoning": "Fuse top-K selection and softmax by maintaining running exp-sum during reduction rounds, avoiding second pass over top_vals array and enabling single-loop computation with interleaved exp operations for better instruction throughput."
                                  },
                                  "visit_count": 1,
                                  "max_reward": 2.8572575906448536,
                                  "prior": 0.25,
                                  "eval_result": {
                                    "compiled": true,
                                    "correct": true,
                                    "compile_error": null,
                                    "correctness_error": null,
                                    "timings_us": [
                                      604.625,
                                      608.042,
                                      507.583,
                                      570.125,
                                      619.417,
                                      589.0,
                                      575.416,
                                      141.667,
                                      164.167,
                                      194.084,
                                      181.083,
                                      152.792,
                                      276.917,
                                      138.875,
                                      144.583,
                                      137.041,
                                      136.208,
                                      135.25,
                                      138.042,
                                      138.75
                                    ],
                                    "median_us": 181.083,
                                    "reward": 2.8572575906448536,
                                    "speedup": 3.906816211350596
                                  },
                                  "children": []
                                }
                              ]
                            },
                            {
                              "node_id": "gen9_247b39725f53",
                              "candidate": {
                                "spec": {
                                  "name": "kk_glm_topk_gating_gen9",
                                  "input_names": [
                                    "inp"
                                  ],
                                  "output_names": [
                                    "weights",
                                    "indices"
                                  ],
                                  "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nuint i0 = tid;\nuint i1 = tid + 32;\n\n// Find local max first for logit normalization\nfloat local_max = fmax(v0, v1);\nfloat global_max = simd_max(local_max);\n\n// Precompute exp values relative to global max\nfloat exp0 = metal::fast::exp(v0 - global_max);\nfloat exp1 = metal::fast::exp(v1 - global_max);\n\nthread float top_vals[K];\nthread uint top_idxs[K];\nthread float top_exps[K];\n\n// Initialize\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    top_vals[k] = -INFINITY;\n    top_idxs[k] = 0;\n    top_exps[k] = 0.0f;\n}\n\n// Round 1: find top-1 and its exp\nfloat cand_val = local_max;\nuint cand_idx = (v0 >= v1) ? i0 : i1;\nfloat cand_exp = (v0 >= v1) ? exp0 : exp1;\n\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float other_val = simd_shuffle_down(cand_val, offset);\n    uint other_idx = simd_shuffle_down(cand_idx, offset);\n    float other_exp = simd_shuffle_down(cand_exp, offset);\n    if (other_val > cand_val) {\n        cand_val = other_val;\n        cand_idx = other_idx;\n        cand_exp = other_exp;\n    }\n}\ntop_vals[0] = simd_broadcast(cand_val, 0);\ntop_idxs[0] = simd_broadcast(cand_idx, 0);\ntop_exps[0] = simd_broadcast(cand_exp, 0);\n\n// Rounds 2-4 with masking\nfor (uint round = 1; round < K; ++round) {\n    bool is_winner0 = (i0 == top_idxs[round-1]);\n    bool is_winner1 = (i1 == top_idxs[round-1]);\n    \n    float next_val, next_exp;\n    uint next_idx;\n    \n    if (is_winner0 && is_winner1) {\n        next_val = -INFINITY;\n        next_idx = 0;\n        next_exp = 0.0f;\n    } else if (is_winner0) {\n        next_val = v1;\n        next_idx = i1;\n        next_exp = exp1;\n    } else if (is_winner1) {\n        next_val = v0;\n        next_idx = i0;\n        next_exp = exp0;\n    } else {\n        next_val = fmax(v0, v1);\n        next_idx = (v0 >= v1) ? i0 : i1;\n        next_exp = (v0 >= v1) ? exp0 : exp1;\n    }\n    \n    #pragma unroll\n    for (uint offset = 16; offset >= 1; offset >>= 1) {\n        float other_val = simd_shuffle_down(next_val, offset);\n        uint other_idx = simd_shuffle_down(next_idx, offset);\n        float other_exp = simd_shuffle_down(next_exp, offset);\n        if (other_val > next_val) {\n            next_val = other_val;\n            next_idx = other_idx;\n            next_exp = other_exp;\n        }\n    }\n    \n    top_vals[round] = simd_broadcast(next_val, 0);\n    top_idxs[round] = simd_broadcast(next_idx, 0);\n    top_exps[round] = simd_broadcast(next_exp, 0);\n}\n\n// Finalize softmax: sum already in exp form\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    sum += top_exps[k];\n}\nfloat inv_sum = metal::fast::divide(1.0f, sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_exps[tid] * inv_sum);\n    indices[out_base + tid] = top_idxs[tid];\n}",
                                  "header": "",
                                  "threadgroup": [
                                    32,
                                    1,
                                    1
                                  ],
                                  "template_params": [
                                    [
                                      "T",
                                      "float32"
                                    ]
                                  ]
                                },
                                "parent_id": "gen8_11a0ea524cb3",
                                "generation": 9,
                                "llm_reasoning": "Pipeline top-k selection with softmax precomputation: compute running exp-sum for candidates during selection phase, eliminating separate softmax pass."
                              },
                              "visit_count": 1,
                              "max_reward": 0.0,
                              "prior": 0.25,
                              "eval_result": {
                                "compiled": true,
                                "correct": false,
                                "compile_error": null,
                                "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.37095221877098083 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.12904778122901917 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.37095221877098083 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.12904778122901917 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.21468516\nMax relative difference among violations: 1.373835\n ACTUAL: array([[0.370952, 0.129048, 0.370952, 0.129048]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                                "timings_us": [],
                                "median_us": Infinity,
                                "reward": 0.0,
                                "speedup": 0.0
                              },
                              "children": []
                            },
                            {
                              "node_id": "gen9_2c11999c024e",
                              "candidate": {
                                "spec": {
                                  "name": "kk_glm_topk_gating_gen9",
                                  "input_names": [
                                    "inp"
                                  ],
                                  "output_names": [
                                    "weights",
                                    "indices"
                                  ],
                                  "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load all 64 values into threadgroup memory for sorting\nthreadgroup float shared_vals[64];\nthreadgroup uint shared_idxs[64];\n\nshared_vals[tid] = (float)inp[base + tid];\nshared_vals[tid + 32] = (float)inp[base + tid + 32];\nshared_idxs[tid] = tid;\nshared_idxs[tid + 32] = tid + 32;\n\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\n// Each thread sorts a local chunk of 4 elements using sorting network\n// Thread 0 handles 0-3, thread 1 handles 4-7, etc.\nuint chunk_start = tid * 2;\nif (chunk_start + 1 < D) {\n    float v0 = shared_vals[chunk_start];\n    float v1 = shared_vals[chunk_start + 1];\n    uint i0 = shared_idxs[chunk_start];\n    uint i1 = shared_idxs[chunk_start + 1];\n    \n    // Compare-swap\n    if (v1 > v0) {\n        shared_vals[chunk_start] = v1;\n        shared_vals[chunk_start + 1] = v0;\n        shared_idxs[chunk_start] = i1;\n        shared_idxs[chunk_start + 1] = i0;\n    }\n}\n\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\n// Now merge sorted pairs using SIMD-level bitonic merge\n// Extract top-4 using parallel reduction\nthread float heap[K];\nthread uint heap_idx[K];\n\nif (tid == 0) {\n    // Initialize with first K\n    #pragma unroll\n    for (uint k = 0; k < K; ++k) {\n        heap[k] = shared_vals[k];\n        heap_idx[k] = shared_idxs[k];\n    }\n    \n    // Insertion sort for remaining elements\n    for (uint i = K; i < D; ++i) {\n        float val = shared_vals[i];\n        uint idx = shared_idxs[i];\n        \n        if (val > heap[K-1]) {\n            // Insert at end\n            heap[K-1] = val;\n            heap_idx[K-1] = idx;\n            \n            // Bubble up to maintain sorted order\n            for (int k = K-2; k >= 0; --k) {\n                if (heap[k+1] > heap[k]) {\n                    float tmp_v = heap[k];\n                    uint tmp_i = heap_idx[k];\n                    heap[k] = heap[k+1];\n                    heap_idx[k] = heap_idx[k+1];\n                    heap[k+1] = tmp_v;\n                    heap_idx[k+1] = tmp_i;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n}\n\n// Broadcast sorted top-K\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    heap[k] = simd_broadcast(heap[k], 0);\n    heap_idx[k] = simd_broadcast(heap_idx[k], 0);\n}\n\n// Parallel softmax with fast math\nfloat max_val = heap[0];\nthread float exps[K];\nfloat partial_sum = 0.0f;\n\nif (tid < K) {\n    exps[tid] = metal::fast::exp(heap[tid] - max_val);\n    partial_sum = exps[tid];\n}\n\nfloat total_sum = simd_sum(partial_sum);\nfloat inv_sum = metal::fast::divide(1.0f, total_sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exps[tid] * inv_sum);\n    indices[out_base + tid] = heap_idx[tid];\n}",
                                  "header": "",
                                  "threadgroup": [
                                    32,
                                    1,
                                    1
                                  ],
                                  "template_params": [
                                    [
                                      "T",
                                      "float32"
                                    ]
                                  ]
                                },
                                "parent_id": "gen8_11a0ea524cb3",
                                "generation": 9,
                                "llm_reasoning": "Exploit register-level sorting with explicit 4-element insertion sort network (6 compare-swaps for K=4) on per-thread candidates, then merge sorted lists across SIMD lanes using bitonic merge."
                              },
                              "visit_count": 1,
                              "max_reward": 3.4934350011321054,
                              "prior": 0.25,
                              "eval_result": {
                                "compiled": true,
                                "correct": true,
                                "compile_error": null,
                                "correctness_error": null,
                                "timings_us": [
                                  536.875,
                                  533.167,
                                  597.833,
                                  746.0,
                                  202.167,
                                  155.542,
                                  144.791,
                                  133.916,
                                  135.333,
                                  148.417,
                                  149.333,
                                  147.875,
                                  145.458,
                                  156.542,
                                  158.917,
                                  155.083,
                                  162.541,
                                  162.917,
                                  162.333,
                                  161.583
                                ],
                                "median_us": 158.917,
                                "reward": 3.4934350011321054,
                                "speedup": 4.451745250665441
                              },
                              "children": []
                            }
                          ]
                        },
                        {
                          "node_id": "gen8_6b70f9d8fde7",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen8",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Maintain sorted top-K using predicated blend\nthread float vals[K];\nthread uint idxs[K];\n\n// Initialize with local values\nvals[0] = metal::max(v0, v1);\nidxs[0] = (v0 >= v1) ? tid : (tid + 32);\nvals[1] = metal::min(v0, v1);\nidxs[1] = (v0 < v1) ? tid : (tid + 32);\nvals[2] = -INFINITY;\nidxs[2] = 0;\nvals[3] = -INFINITY;\nidxs[3] = 0;\n\n// Iterative reduction across warp with sorting network\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float candidate = simd_max(vals[k]);\n    bool is_source = (vals[k] == candidate);\n    uint candidate_idx = simd_max(is_source ? idxs[k] : 0u);\n    \n    // Insert candidate into sorted position (all threads compute)\n    thread float new_vals[K];\n    thread uint new_idxs[K];\n    \n    uint insert_pos = K;\n    #pragma unroll\n    for (uint i = 0; i < K; ++i) {\n        if (candidate > vals[i] && insert_pos == K) {\n            insert_pos = i;\n        }\n    }\n    \n    // Shift and insert\n    #pragma unroll\n    for (uint i = 0; i < K; ++i) {\n        if (i < insert_pos) {\n            new_vals[i] = vals[i];\n            new_idxs[i] = idxs[i];\n        } else if (i == insert_pos) {\n            new_vals[i] = candidate;\n            new_idxs[i] = candidate_idx;\n        } else if (i < K) {\n            new_vals[i] = vals[i-1];\n            new_idxs[i] = idxs[i-1];\n        }\n    }\n    \n    #pragma unroll\n    for (uint i = 0; i < K; ++i) {\n        vals[i] = new_vals[i];\n        idxs[i] = new_idxs[i];\n    }\n    \n    // Invalidate source\n    vals[k] = metal::select(vals[k], -INFINITY, is_source);\n}\n\n// Softmax with vectorized ops\nfloat max_val = vals[0];\nthread float exp_vals[K];\nfloat sum_local = 0.0f;\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    exp_vals[k] = metal::fast::exp(vals[k] - max_val);\n    sum_local += exp_vals[k];\n}\n\nfloat total = simd_sum(sum_local);\nfloat scale = metal::fast::divide(1.0f, total);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_vals[tid] * scale);\n    indices[out_base + tid] = idxs[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                256,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_921af78bb7b6",
                            "generation": 8,
                            "llm_reasoning": "Eliminate branch divergence by using min/max blend operations for top-K tracking, maintaining sorted order incrementally with fully predicated updates."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.007874015718698502 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.007874015718698502 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.007874015718698502 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.007874015718698502 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.5075394\nMax relative difference among violations: 0.9847229\n ACTUAL: array([[0.007874, 0.007874, 0.007874, 0.007874]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        },
                        {
                          "node_id": "gen8_47f23ecd0587",
                          "candidate": {
                            "spec": {
                              "name": "kk_glm_topk_gating_gen8",
                              "input_names": [
                                "inp"
                              ],
                              "output_names": [
                                "weights",
                                "indices"
                              ],
                              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Prefetch into registers\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\nthread float heap[K];\nthread uint indices[K];\nthread float heap_next[K];\nthread uint indices_next[K];\n\n// Initialize double buffer\nfloat my_max = metal::max(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Unroll K iterations with prefetch\n// Iteration 0\nfloat global_max = simd_max(my_max);\nbool winner = (my_max == global_max);\nuint winner_idx = simd_max(winner ? my_idx : 0u);\nheap[0] = global_max;\nindices[0] = winner_idx;\n\n// Prefetch iteration 1 while storing 0\nmy_max = metal::select(my_max, -INFINITY, winner);\nfloat global_max_next = simd_max(my_max);\n\n// Iteration 1\nwinner = (my_max == global_max_next);\nwinner_idx = simd_max(winner ? my_idx : 0u);\nheap[1] = global_max_next;\nindices[1] = winner_idx;\n\n// Prefetch iteration 2\nmy_max = metal::select(my_max, -INFINITY, winner);\nglobal_max = simd_max(my_max);\n\n// Iteration 2\nwinner = (my_max == global_max);\nwinner_idx = simd_max(winner ? my_idx : 0u);\nheap[2] = global_max;\nindices[2] = winner_idx;\n\n// Prefetch iteration 3\nmy_max = metal::select(my_max, -INFINITY, winner);\nglobal_max_next = simd_max(my_max);\n\n// Iteration 3\nwinner = (my_max == global_max_next);\nwinner_idx = simd_max(winner ? my_idx : 0u);\nheap[3] = global_max_next;\nindices[3] = winner_idx;\n\n// Softmax with interleaved exp and sum\nfloat max_logit = heap[0];\nfloat exp0 = metal::fast::exp(heap[0] - max_logit);\nfloat exp1 = metal::fast::exp(heap[1] - max_logit);\nfloat exp2 = metal::fast::exp(heap[2] - max_logit);\nfloat exp3 = metal::fast::exp(heap[3] - max_logit);\n\n// Parallel reduction of partial sums\nfloat sum_pair0 = exp0 + exp1;\nfloat sum_pair1 = exp2 + exp3;\nfloat sum_all = sum_pair0 + sum_pair1;\n\nfloat total = simd_sum(sum_all);\nfloat inv_total = metal::fast::divide(1.0f, total);\n\nif (tid < K) {\n    uint out_base = row * K;\n    thread float exp_arr[4] = {exp0, exp1, exp2, exp3};\n    weights[out_base + tid] = (T)(exp_arr[tid] * inv_total);\n    indices[out_base + tid] = indices[tid];\n}",
                              "header": "",
                              "threadgroup": [
                                256,
                                1,
                                1
                              ],
                              "template_params": [
                                [
                                  "T",
                                  "float32"
                                ]
                              ]
                            },
                            "parent_id": "gen4_921af78bb7b6",
                            "generation": 8,
                            "llm_reasoning": "Double buffer top-K candidates with explicit prefetch from next iteration, hiding latency of simd operations by interleaving arithmetic with communication."
                          },
                          "visit_count": 1,
                          "max_reward": 0.0,
                          "prior": 0.25,
                          "eval_result": {
                            "compiled": true,
                            "correct": false,
                            "compile_error": null,
                            "correctness_error": "[metal::Device] Unable to build metal library from source\nmlx/backend/metal/kernels/utils.h:506:13: error: redefinition of 'indices' with a different type: 'uint[4]' (aka 'unsigned int[4]') vs 'device uint32_t *' (aka 'device unsigned int *')\nthread uint indices[K];\n            ^\nmlx/backend/metal/kernels/utils.h:489:20: note: previous definition is here\n  device uint32_t* indices [[buffer(2)]],\n                   ^\n\n",
                            "timings_us": [],
                            "median_us": Infinity,
                            "reward": 0.0,
                            "speedup": 0.0
                          },
                          "children": []
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "node_id": "gen2_7f6b05c81a57",
              "candidate": {
                "spec": {
                  "name": "kk_glm_topk_gating_gen2",
                  "input_names": [
                    "inp"
                  ],
                  "output_names": [
                    "weights",
                    "indices"
                  ],
                  "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Pack value bits and index for single comparison\nuint64_t pack0 = (uint64_t(as_type<uint>(v0)) << 32) | tid;\nuint64_t pack1 = (uint64_t(as_type<uint>(v1)) << 32) | (tid + 32);\nuint64_t cur_pack = metal::max(pack0, pack1);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfor (uint i = 0; i < K; ++i) {\n    uint64_t max_pack = simd_max(cur_pack);\n    \n    if (tid == 0) {\n        uint val_bits = uint(max_pack >> 32);\n        topk_vals[i] = as_type<float>(val_bits);\n        topk_idx[i] = uint(max_pack & 0xFFFFFFFF);\n    }\n    \n    if (cur_pack == max_pack) {\n        cur_pack = (uint64_t(as_type<uint>(-INFINITY)) << 32) | uint(max_pack & 0xFFFFFFFF);\n    }\n}\n\nif (tid == 0) {\n    float m = topk_vals[0];\n    float s = 0.0f;\n    for (uint i = 0; i < K; ++i) {\n        s += metal::exp(topk_vals[i] - m);\n    }\n    float inv = 1.0f / s;\n    uint out_base = row * K;\n    for (uint i = 0; i < K; ++i) {\n        weights[out_base + i] = (T)(metal::exp(topk_vals[i] - m) * inv);\n        indices[out_base + i] = topk_idx[i];\n    }\n}",
                  "header": "",
                  "threadgroup": [
                    32,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_675c892a5bcb",
                "generation": 2,
                "llm_reasoning": "Fuse max-finding and index-tracking using packed uint64 (upper 32b=bits of float, lower 32b=index), enabling single simd_max comparison. Reduces instruction count in critical loop."
              },
              "visit_count": 1,
              "max_reward": 0.0,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": false,
                "compile_error": null,
                "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.25 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.25 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.25 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.25 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.2654134\nMax relative difference among violations: 0.67766994\n ACTUAL: array([[0.25, 0.25, 0.25, 0.25]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                "timings_us": [],
                "median_us": Infinity,
                "reward": 0.0,
                "speedup": 0.0
              },
              "children": []
            },
            {
              "node_id": "gen2_83c4fb031848",
              "candidate": {
                "spec": {
                  "name": "kk_glm_topk_gating_gen2",
                  "input_names": [
                    "inp"
                  ],
                  "output_names": [
                    "weights",
                    "indices"
                  ],
                  "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load 4 values per thread using vector load (D=64, SG=32, 64/(32*2)=1 but we can do 2x float2)\nfloat2 v01 = float2((float)inp[base + tid * 2], (float)inp[base + tid * 2 + 1]);\nfloat2 v23 = float2((float)inp[base + 32 + tid * 2], (float)inp[base + 32 + tid * 2 + 1]);\n\n// Find max among 4 values\nfloat m0 = metal::max(v01.x, v01.y);\nfloat m1 = metal::max(v23.x, v23.y);\nfloat v = metal::max(m0, m1);\n\nuint local_idx;\nif (v == v01.x) local_idx = tid * 2;\nelse if (v == v01.y) local_idx = tid * 2 + 1;\nelse if (v == v23.x) local_idx = 32 + tid * 2;\nelse local_idx = 32 + tid * 2 + 1;\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    if (tid == 0) {\n        topk_vals[i] = cur_max;\n        topk_idx[i] = winner_idx;\n    }\n    \n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\nif (tid == 0) {\n    float m = topk_vals[0];\n    float s = 0.0f;\n    for (uint i = 0; i < K; ++i) {\n        s += metal::exp(topk_vals[i] - m);\n    }\n    float inv = 1.0f / s;\n    uint out_base = row * K;\n    for (uint i = 0; i < K; ++i) {\n        weights[out_base + i] = (T)(metal::exp(topk_vals[i] - m) * inv);\n        indices[out_base + i] = topk_idx[i];\n    }\n}",
                  "header": "",
                  "threadgroup": [
                    32,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_675c892a5bcb",
                "generation": 2,
                "llm_reasoning": "Use 4-wide vector loads (float4) to read D=64 in 16 ops instead of 64, improving memory bandwidth. Each thread handles 4 values, finds local max, then participates in SIMD reduction."
              },
              "visit_count": 1,
              "max_reward": 0.0,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": false,
                "compile_error": null,
                "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.3760780692100525 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.30600985884666443 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.18708109855651855 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.13083097338676453 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.13933533\nMax relative difference among violations: 0.7066606\n ACTUAL: array([[0.376078, 0.30601 , 0.187081, 0.130831]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
                "timings_us": [],
                "median_us": Infinity,
                "reward": 0.0,
                "speedup": 0.0
              },
              "children": []
            },
            {
              "node_id": "gen2_69374a040e7d",
              "candidate": {
                "spec": {
                  "name": "kk_glm_topk_gating_gen2",
                  "input_names": [
                    "inp"
                  ],
                  "output_names": [
                    "weights",
                    "indices"
                  ],
                  "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    if (tid == 0) {\n        topk_vals[i] = cur_max;\n        topk_idx[i] = winner_idx;\n    }\n    \n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\nif (tid == 0) {\n    // Use fast exp and manual sum for softmax\n    float m = topk_vals[0];\n    thread float exps[K];\n    float s = 0.0f;\n    \n    #pragma unroll\n    for (uint i = 0; i < K; ++i) {\n        exps[i] = metal::fast::exp(topk_vals[i] - m);\n        s += exps[i];\n    }\n    \n    float inv = metal::fast::divide(1.0f, s);\n    uint out_base = row * K;\n    \n    #pragma unroll\n    for (uint i = 0; i < K; ++i) {\n        weights[out_base + i] = (T)(exps[i] * inv);\n        indices[out_base + i] = topk_idx[i];\n    }\n}",
                  "header": "",
                  "threadgroup": [
                    32,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_675c892a5bcb",
                "generation": 2,
                "llm_reasoning": "Precompute reciprocal sqrt for fast approximate softmax normalization. Use fast math intrinsics (metal::fast::exp) and rsqrt approximation to reduce transcendental instruction latency."
              },
              "visit_count": 1,
              "max_reward": 4.016407260216029,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  164.875,
                  163.5,
                  142.542,
                  141.75,
                  152.959,
                  151.5,
                  147.75,
                  150.75,
                  147.417,
                  148.584,
                  149.667,
                  166.083,
                  136.958,
                  141.583,
                  753.833,
                  634.334,
                  183.291,
                  155.709,
                  144.458,
                  141.25
                ],
                "median_us": 150.75,
                "reward": 4.016407260216029,
                "speedup": 4.6929220563847425
              },
              "children": []
            }
          ]
        },
        {
          "node_id": "gen1_2c95774d26b6",
          "candidate": {
            "spec": {
              "name": "kk_glm_topk_gating_gen1",
              "input_names": [
                "inp"
              ],
              "output_names": [
                "weights",
                "indices"
              ],
              "source": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v = -INFINITY;\nif (tid < D) {\n    v = (float)inp[base + tid];\n}\n\nfloat cur = v;\n\n// Unrolled top-k selection with broadcast\nfloat max0 = simd_max(cur);\nuint cand0 = (cur == max0 && tid < D) ? tid : 0;\nuint idx0 = simd_broadcast(simd_max(cand0), 0);\ncur = (tid == idx0) ? -INFINITY : cur;\n\nfloat max1 = simd_max(cur);\nuint cand1 = (cur == max1 && tid < D) ? tid : 0;\nuint idx1 = simd_broadcast(simd_max(cand1), 0);\ncur = (tid == idx1) ? -INFINITY : cur;\n\nfloat max2 = simd_max(cur);\nuint cand2 = (cur == max2 && tid < D) ? tid : 0;\nuint idx2 = simd_broadcast(simd_max(cand2), 0);\ncur = (tid == idx2) ? -INFINITY : cur;\n\nfloat max3 = simd_max(cur);\nuint cand3 = (cur == max3 && tid < D) ? tid : 0;\nuint idx3 = simd_broadcast(simd_max(cand3), 0);\n\n// All threads broadcast and compute softmax in parallel\nfloat m = simd_broadcast(max0, 0);\nfloat exp0 = metal::exp(max0 - m);\nfloat exp1 = metal::exp(max1 - m);\nfloat exp2 = metal::exp(max2 - m);\nfloat exp3 = metal::exp(max3 - m);\n\nfloat s = exp0 + exp1 + exp2 + exp3;\nfloat inv = 1.0f / s;\n\nif (tid == 0) {\n    uint out_base = row * K;\n    weights[out_base + 0] = (T)(exp0 * inv);\n    weights[out_base + 1] = (T)(exp1 * inv);\n    weights[out_base + 2] = (T)(exp2 * inv);\n    weights[out_base + 3] = (T)(exp3 * inv);\n    indices[out_base + 0] = idx0;\n    indices[out_base + 1] = idx1;\n    indices[out_base + 2] = idx2;\n    indices[out_base + 3] = idx3;\n}",
              "header": "",
              "threadgroup": [
                32,
                1,
                1
              ],
              "template_params": [
                [
                  "T",
                  "float32"
                ]
              ]
            },
            "parent_id": "root",
            "generation": 1,
            "llm_reasoning": "Combine unrolling with parallel softmax computation. Broadcast winners to all threads, compute exp in parallel, then reduce sum with simd_sum for maximum throughput."
          },
          "visit_count": 1,
          "max_reward": 0.0,
          "prior": 0.25,
          "eval_result": {
            "compiled": true,
            "correct": false,
            "compile_error": null,
            "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 4 / 4 (100%)\nMismatch at indices:\n [0, 0]: 0.6251656413078308 (ACTUAL), 0.5154134035110474 (DESIRED)\n [0, 1]: 0.1695910394191742 (ACTUAL), 0.17930328845977783 (DESIRED)\n [0, 2]: 0.1061181053519249 (ACTUAL), 0.15626706182956696 (DESIRED)\n [0, 3]: 0.09912522882223129 (ACTUAL), 0.14901620149612427 (DESIRED)\nMax absolute difference among violations: 0.10975224\nMax relative difference among violations: 0.33480233\n ACTUAL: array([[0.625166, 0.169591, 0.106118, 0.099125]], dtype=float32)\n DESIRED: array([[0.515413, 0.179303, 0.156267, 0.149016]], dtype=float32)",
            "timings_us": [],
            "median_us": Infinity,
            "reward": 0.0,
            "speedup": 0.0
          },
          "children": []
        }
      ]
    }
  },
  "eval_history": [],
  "candidate_sources": {
    "gen1_538e146ea727": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v = -INFINITY;\nif (tid < D) {\n    v = (float)inp[base + tid];\n}\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate = (cur == cur_max && tid < D) ? tid : 0;\n    uint winner = simd_max(candidate);\n    \n    // Broadcast to all threads\n    topk_vals[i] = simd_broadcast(cur_max, 0);\n    topk_idx[i] = simd_broadcast(winner, 0);\n    \n    cur = (tid == winner) ? -INFINITY : cur;\n}\n\n// All threads compute softmax in parallel\nfloat m = topk_vals[0];\nfloat s = 0.0f;\nfor (uint i = 0; i < K; ++i) {\n    s += metal::exp(topk_vals[i] - m);\n}\nfloat inv = 1.0f / s;\n\n// Thread-0 writes results\nif (tid == 0) {\n    uint out_base = row * K;\n    for (uint i = 0; i < K; ++i) {\n        weights[out_base + i] = (T)(metal::exp(topk_vals[i] - m) * inv);\n        indices[out_base + i] = topk_idx[i];\n    }\n}",
    "gen1_4ee5fa59a05d": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v = -INFINITY;\nif (tid < D) {\n    v = (float)inp[base + tid];\n}\n\nfloat cur = v;\n\n// Iteration 0\nfloat max0 = simd_max(cur);\nuint cand0 = (cur == max0 && tid < D) ? tid : 0;\nuint idx0 = simd_max(cand0);\ncur = (tid == idx0) ? -INFINITY : cur;\n\n// Iteration 1\nfloat max1 = simd_max(cur);\nuint cand1 = (cur == max1 && tid < D) ? tid : 0;\nuint idx1 = simd_max(cand1);\ncur = (tid == idx1) ? -INFINITY : cur;\n\n// Iteration 2\nfloat max2 = simd_max(cur);\nuint cand2 = (cur == max2 && tid < D) ? tid : 0;\nuint idx2 = simd_max(cand2);\ncur = (tid == idx2) ? -INFINITY : cur;\n\n// Iteration 3\nfloat max3 = simd_max(cur);\nuint cand3 = (cur == max3 && tid < D) ? tid : 0;\nuint idx3 = simd_max(cand3);\n\nif (tid == 0) {\n    float m = max0;\n    float exp0 = metal::exp(max0 - m);\n    float exp1 = metal::exp(max1 - m);\n    float exp2 = metal::exp(max2 - m);\n    float exp3 = metal::exp(max3 - m);\n    \n    float s = exp0 + exp1 + exp2 + exp3;\n    float inv = 1.0f / s;\n    \n    uint out_base = row * K;\n    weights[out_base + 0] = (T)(exp0 * inv);\n    weights[out_base + 1] = (T)(exp1 * inv);\n    weights[out_base + 2] = (T)(exp2 * inv);\n    weights[out_base + 3] = (T)(exp3 * inv);\n    indices[out_base + 0] = idx0;\n    indices[out_base + 1] = idx1;\n    indices[out_base + 2] = idx2;\n    indices[out_base + 3] = idx3;\n}",
    "gen1_675c892a5bcb": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load two values per thread (D=64, SG=32)\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Start with max of the two\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    if (tid == 0) {\n        topk_vals[i] = cur_max;\n        topk_idx[i] = winner_idx;\n    }\n    \n    // Update cur to -INFINITY if we were the winner\n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\nif (tid == 0) {\n    float m = topk_vals[0];\n    float s = 0.0f;\n    for (uint i = 0; i < K; ++i) {\n        s += metal::exp(topk_vals[i] - m);\n    }\n    float inv = 1.0f / s;\n    uint out_base = row * K;\n    for (uint i = 0; i < K; ++i) {\n        weights[out_base + i] = (T)(metal::exp(topk_vals[i] - m) * inv);\n        indices[out_base + i] = topk_idx[i];\n    }\n}",
    "gen1_2c95774d26b6": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v = -INFINITY;\nif (tid < D) {\n    v = (float)inp[base + tid];\n}\n\nfloat cur = v;\n\n// Unrolled top-k selection with broadcast\nfloat max0 = simd_max(cur);\nuint cand0 = (cur == max0 && tid < D) ? tid : 0;\nuint idx0 = simd_broadcast(simd_max(cand0), 0);\ncur = (tid == idx0) ? -INFINITY : cur;\n\nfloat max1 = simd_max(cur);\nuint cand1 = (cur == max1 && tid < D) ? tid : 0;\nuint idx1 = simd_broadcast(simd_max(cand1), 0);\ncur = (tid == idx1) ? -INFINITY : cur;\n\nfloat max2 = simd_max(cur);\nuint cand2 = (cur == max2 && tid < D) ? tid : 0;\nuint idx2 = simd_broadcast(simd_max(cand2), 0);\ncur = (tid == idx2) ? -INFINITY : cur;\n\nfloat max3 = simd_max(cur);\nuint cand3 = (cur == max3 && tid < D) ? tid : 0;\nuint idx3 = simd_broadcast(simd_max(cand3), 0);\n\n// All threads broadcast and compute softmax in parallel\nfloat m = simd_broadcast(max0, 0);\nfloat exp0 = metal::exp(max0 - m);\nfloat exp1 = metal::exp(max1 - m);\nfloat exp2 = metal::exp(max2 - m);\nfloat exp3 = metal::exp(max3 - m);\n\nfloat s = exp0 + exp1 + exp2 + exp3;\nfloat inv = 1.0f / s;\n\nif (tid == 0) {\n    uint out_base = row * K;\n    weights[out_base + 0] = (T)(exp0 * inv);\n    weights[out_base + 1] = (T)(exp1 * inv);\n    weights[out_base + 2] = (T)(exp2 * inv);\n    weights[out_base + 3] = (T)(exp3 * inv);\n    indices[out_base + 0] = idx0;\n    indices[out_base + 1] = idx1;\n    indices[out_base + 2] = idx2;\n    indices[out_base + 3] = idx3;\n}",
    "gen2_1b54c88997fe": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    topk_vals[i] = simd_broadcast(cur_max, 0);\n    topk_idx[i] = simd_broadcast(winner_idx, 0);\n    \n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\n// Parallel softmax: each thread handles one K value\nfloat m = topk_vals[0];\nfloat local_exp = (tid < K) ? metal::exp(topk_vals[tid] - m) : 0.0f;\nfloat sum_exp = simd_sum(local_exp);\nfloat inv = 1.0f / sum_exp;\n\n// Thread 0-3 write results\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(local_exp * inv);\n    indices[out_base + tid] = topk_idx[tid];\n}",
    "gen2_7f6b05c81a57": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Pack value bits and index for single comparison\nuint64_t pack0 = (uint64_t(as_type<uint>(v0)) << 32) | tid;\nuint64_t pack1 = (uint64_t(as_type<uint>(v1)) << 32) | (tid + 32);\nuint64_t cur_pack = metal::max(pack0, pack1);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfor (uint i = 0; i < K; ++i) {\n    uint64_t max_pack = simd_max(cur_pack);\n    \n    if (tid == 0) {\n        uint val_bits = uint(max_pack >> 32);\n        topk_vals[i] = as_type<float>(val_bits);\n        topk_idx[i] = uint(max_pack & 0xFFFFFFFF);\n    }\n    \n    if (cur_pack == max_pack) {\n        cur_pack = (uint64_t(as_type<uint>(-INFINITY)) << 32) | uint(max_pack & 0xFFFFFFFF);\n    }\n}\n\nif (tid == 0) {\n    float m = topk_vals[0];\n    float s = 0.0f;\n    for (uint i = 0; i < K; ++i) {\n        s += metal::exp(topk_vals[i] - m);\n    }\n    float inv = 1.0f / s;\n    uint out_base = row * K;\n    for (uint i = 0; i < K; ++i) {\n        weights[out_base + i] = (T)(metal::exp(topk_vals[i] - m) * inv);\n        indices[out_base + i] = topk_idx[i];\n    }\n}",
    "gen2_83c4fb031848": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load 4 values per thread using vector load (D=64, SG=32, 64/(32*2)=1 but we can do 2x float2)\nfloat2 v01 = float2((float)inp[base + tid * 2], (float)inp[base + tid * 2 + 1]);\nfloat2 v23 = float2((float)inp[base + 32 + tid * 2], (float)inp[base + 32 + tid * 2 + 1]);\n\n// Find max among 4 values\nfloat m0 = metal::max(v01.x, v01.y);\nfloat m1 = metal::max(v23.x, v23.y);\nfloat v = metal::max(m0, m1);\n\nuint local_idx;\nif (v == v01.x) local_idx = tid * 2;\nelse if (v == v01.y) local_idx = tid * 2 + 1;\nelse if (v == v23.x) local_idx = 32 + tid * 2;\nelse local_idx = 32 + tid * 2 + 1;\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    if (tid == 0) {\n        topk_vals[i] = cur_max;\n        topk_idx[i] = winner_idx;\n    }\n    \n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\nif (tid == 0) {\n    float m = topk_vals[0];\n    float s = 0.0f;\n    for (uint i = 0; i < K; ++i) {\n        s += metal::exp(topk_vals[i] - m);\n    }\n    float inv = 1.0f / s;\n    uint out_base = row * K;\n    for (uint i = 0; i < K; ++i) {\n        weights[out_base + i] = (T)(metal::exp(topk_vals[i] - m) * inv);\n        indices[out_base + i] = topk_idx[i];\n    }\n}",
    "gen2_69374a040e7d": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    if (tid == 0) {\n        topk_vals[i] = cur_max;\n        topk_idx[i] = winner_idx;\n    }\n    \n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\nif (tid == 0) {\n    // Use fast exp and manual sum for softmax\n    float m = topk_vals[0];\n    thread float exps[K];\n    float s = 0.0f;\n    \n    #pragma unroll\n    for (uint i = 0; i < K; ++i) {\n        exps[i] = metal::fast::exp(topk_vals[i] - m);\n        s += exps[i];\n    }\n    \n    float inv = metal::fast::divide(1.0f, s);\n    uint out_base = row * K;\n    \n    #pragma unroll\n    for (uint i = 0; i < K; ++i) {\n        weights[out_base + i] = (T)(exps[i] * inv);\n        indices[out_base + i] = topk_idx[i];\n    }\n}",
    "gen3_329e5901bcbb": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Sorted insertion network for K=4\nthread float vals[4] = {-INFINITY, -INFINITY, -INFINITY, -INFINITY};\nthread uint idxs[4] = {0, 0, 0, 0};\n\n// Insert v into sorted array\nif (v > vals[0]) {\n    vals[3] = vals[2]; idxs[3] = idxs[2];\n    vals[2] = vals[1]; idxs[2] = idxs[1];\n    vals[1] = vals[0]; idxs[1] = idxs[0];\n    vals[0] = v; idxs[0] = local_idx;\n} else if (v > vals[1]) {\n    vals[3] = vals[2]; idxs[3] = idxs[2];\n    vals[2] = vals[1]; idxs[2] = idxs[1];\n    vals[1] = v; idxs[1] = local_idx;\n} else if (v > vals[2]) {\n    vals[3] = vals[2]; idxs[3] = idxs[2];\n    vals[2] = v; idxs[2] = local_idx;\n} else if (v > vals[3]) {\n    vals[3] = v; idxs[3] = local_idx;\n}\n\n// SIMD-level merge to find global top-k\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfor (uint i = 0; i < K; ++i) {\n    float candidate = vals[i];\n    uint candidate_idx = idxs[i];\n    float global_max = simd_max(candidate);\n    uint winner_idx = (candidate == global_max) ? candidate_idx : 0;\n    winner_idx = simd_max(winner_idx);\n    \n    topk_vals[i] = simd_broadcast(global_max, 0);\n    topk_idx[i] = simd_broadcast(winner_idx, 0);\n    \n    if (candidate_idx == winner_idx) {\n        vals[i] = -INFINITY;\n    }\n}\n\n// Softmax\nfloat m = topk_vals[0];\nfloat local_exp = (tid < K) ? metal::exp(topk_vals[tid] - m) : 0.0f;\nfloat sum_exp = simd_sum(local_exp);\nfloat inv = metal::fast::divide(1.0f, sum_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(local_exp * inv);\n    indices[out_base + tid] = topk_idx[tid];\n}",
    "gen3_07fe13061f60": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\n\nfor (uint k = 0; k < K; ++k) {\n    float candidate = v;\n    uint candidate_idx = local_idx;\n    \n    // Binary tree reduction using simd_shuffle_xor\n    for (uint offset = 16; offset > 0; offset >>= 1) {\n        float other_val = simd_shuffle_xor(candidate, offset);\n        uint other_idx = simd_shuffle_xor(candidate_idx, offset);\n        if (other_val > candidate) {\n            candidate = other_val;\n            candidate_idx = other_idx;\n        }\n    }\n    \n    topk_vals[k] = simd_broadcast(candidate, 0);\n    topk_idx[k] = simd_broadcast(candidate_idx, 0);\n    \n    if (local_idx == candidate_idx) {\n        v = -INFINITY;\n    }\n}\n\n// Vectorized softmax computation\nfloat m = topk_vals[0];\nfloat local_exp = (tid < K) ? metal::exp(topk_vals[tid] - m) : 0.0f;\nfloat sum_exp = simd_sum(local_exp);\nfloat inv_sum = metal::fast::divide(1.0f, sum_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(local_exp * inv_sum);\n    indices[out_base + tid] = topk_idx[tid];\n}",
    "gen3_7c77f5288cfb": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat v = metal::max(v0, v1);\nuint local_idx = (v0 >= v1) ? tid : (tid + 32);\n\nthread float topk_vals[K];\nthread uint topk_idx[K];\nfloat running_max = -INFINITY;\nfloat running_sum = 0.0f;\n\nfloat cur = v;\nuint cur_idx = local_idx;\n\nfor (uint i = 0; i < K; ++i) {\n    float cur_max = simd_max(cur);\n    uint candidate_idx = (cur == cur_max) ? cur_idx : 0;\n    uint winner_idx = simd_max(candidate_idx);\n    \n    topk_vals[i] = simd_broadcast(cur_max, 0);\n    topk_idx[i] = simd_broadcast(winner_idx, 0);\n    \n    // Fused online softmax update\n    if (i > 0) {\n        float old_max = running_max;\n        running_max = metal::max(running_max, topk_vals[i]);\n        float correction = metal::exp(old_max - running_max);\n        running_sum = running_sum * correction + metal::exp(topk_vals[i] - running_max);\n    } else {\n        running_max = topk_vals[i];\n        running_sum = 1.0f;\n    }\n    \n    if (cur_idx == winner_idx) {\n        cur = -INFINITY;\n    }\n}\n\n// Add final value to running sum\nrunning_sum += metal::exp(topk_vals[K-1] - running_max);\nfloat inv_sum = metal::fast::divide(1.0f, running_sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(metal::exp(topk_vals[tid] - running_max) * inv_sum);\n    indices[out_base + tid] = topk_idx[tid];\n}",
    "gen3_aba888496883": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Prefetch both values into registers\nfloat2 vals_reg = float2((float)inp[base + tid], (float)inp[base + tid + 32]);\nfloat v = metal::max(vals_reg.x, vals_reg.y);\nuint local_idx = (vals_reg.x >= vals_reg.y) ? tid : (tid + 32);\n\n// Compact top-k extraction with minimal branching\nthread float sorted_vals[K];\nthread uint sorted_idx[K];\n\nfloat working_val = v;\nuint working_idx = local_idx;\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float lane_max = simd_max(working_val);\n    bool is_winner = (working_val == lane_max);\n    uint winner_lane = simd_max(is_winner ? working_idx : 0u);\n    \n    sorted_vals[i] = lane_max;\n    sorted_idx[i] = winner_lane;\n    \n    working_val = is_winner ? -INFINITY : working_val;\n}\n\n// SIMD-parallel softmax\nfloat max_val = sorted_vals[0];\nfloat thread_exp = (tid < K) ? metal::precise::exp(sorted_vals[tid] - max_val) : 0.0f;\nfloat total_exp = simd_sum(thread_exp);\nfloat norm = metal::precise::divide(1.0f, total_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(thread_exp * norm);\n    indices[out_base + tid] = sorted_idx[tid];\n}",
    "gen4_838b765c7a0a": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load one value per thread from first half\nfloat val_lo = (float)inp[base + tid];\nfloat val_hi = (float)inp[base + tid + 32];\n\n// Phase 1: Hierarchical max across halves using XOR shuffle\nthread float top_vals[K];\nthread uint top_idx[K];\n\nfloat curr_val = metal::max(val_lo, val_hi);\nuint curr_idx = (val_lo >= val_hi) ? tid : (tid + 32);\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    // Find max across all lanes\n    float lane_max = simd_max(curr_val);\n    \n    // XOR shuffle to get neighbor's value for tie-breaking\n    uint neighbor_idx = simd_shuffle_xor(curr_idx, 1);\n    float neighbor_val = simd_shuffle_xor(curr_val, 1);\n    \n    bool is_local_max = (curr_val == lane_max);\n    uint winner_idx = simd_max(is_local_max ? curr_idx : 0u);\n    \n    top_vals[k] = lane_max;\n    top_idx[k] = winner_idx;\n    \n    // Mask out winner\n    curr_val = is_local_max ? -INFINITY : curr_val;\n}\n\n// Phase 2: Softmax with instruction-level parallelism\nfloat max_logit = top_vals[0];\nfloat exp_acc = 0.0f;\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::precise::exp(top_vals[k] - max_logit);\n    top_vals[k] = e;\n    exp_acc += e;\n}\n\nfloat inv_sum = metal::precise::divide(1.0f, simd_sum(exp_acc));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idx[tid];\n}",
    "gen4_098f7c49e4d5": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load first value and start max computation while second value loads\nfloat val1 = (float)inp[base + tid];\nfloat running_max = val1;\nuint running_idx = tid;\n\n// Prefetch second value (compiler can overlap with above arithmetic)\nfloat val2 = (float)inp[base + tid + 32];\n\n// Update max with second value\nif (val2 > running_max) {\n    running_max = val2;\n    running_idx = tid + 32;\n}\n\n// Top-k extraction with compact branch-free updates\nthread float k_vals[K];\nthread uint k_idx[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float best = simd_max(running_max);\n    \n    // Branch-free winner selection\n    bool wins = (running_max == best);\n    uint winner = simd_max(wins ? running_idx : 0u);\n    \n    k_vals[i] = best;\n    k_idx[i] = winner;\n    \n    // Conditional update without branching\n    float mask = wins ? -INFINITY : running_max;\n    running_max = mask;\n}\n\n// Softmax: compute all exp() before summing (better ILP)\nfloat peak = k_vals[0];\nthread float exps[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    exps[i] = metal::precise::exp(k_vals[i] - peak);\n}\n\nfloat sum_exp = 0.0f;\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    sum_exp += exps[i];\n}\n\nfloat rcp = metal::precise::divide(1.0f, simd_sum(sum_exp));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exps[tid] * rcp);\n    indices[out_base + tid] = k_idx[tid];\n}",
    "gen4_a88cc417f0b6": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load both values\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat my_val = metal::max(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Bitonic sort network for K=4 using SIMD shuffles\n// Stage 1: pairs (distance 1)\nfloat p1_val = simd_shuffle_xor(my_val, 1);\nuint p1_idx = simd_shuffle_xor(my_idx, 1);\nbool swap1 = ((tid & 1) == 0) ? (my_val < p1_val) : (my_val > p1_val);\nfloat s1_val = swap1 ? p1_val : my_val;\nuint s1_idx = swap1 ? p1_idx : my_idx;\n\n// Stage 2: pairs (distance 2) then (distance 1)\nfloat p2_val = simd_shuffle_xor(s1_val, 2);\nuint p2_idx = simd_shuffle_xor(s1_idx, 2);\nbool swap2 = ((tid & 2) == 0) ? (s1_val < p2_val) : (s1_val > p2_val);\nfloat s2_val = swap2 ? p2_val : s1_val;\nuint s2_idx = swap2 ? p2_idx : s1_idx;\n\nfloat p3_val = simd_shuffle_xor(s2_val, 1);\nuint p3_idx = simd_shuffle_xor(s2_idx, 1);\nbool swap3 = ((tid & 1) == 0) ? (s2_val < p3_val) : (s2_val > p3_val);\nfloat sorted_val = swap3 ? p3_val : s2_val;\nuint sorted_idx = swap3 ? p3_idx : s2_idx;\n\n// Top-4 are in first 4 threads (descending order)\nif (tid < K) {\n    float max_logit = simd_broadcast(sorted_val, 0);\n    float exp_val = metal::precise::exp(sorted_val - max_logit);\n    float sum_exp = simd_sum(exp_val);\n    float norm_weight = exp_val * metal::precise::divide(1.0f, sum_exp);\n    \n    uint out_base = row * K;\n    weights[out_base + tid] = (T)norm_weight;\n    indices[out_base + tid] = sorted_idx;\n}",
    "gen4_921af78bb7b6": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Initialize with first 2 values per thread\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Build initial top-K with min-heap property\nthread float heap_vals[K];\nthread uint heap_idx[K];\n\nfloat my_max = metal::max(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Find top-K across SIMD group using reduction\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float global_max = simd_max(my_max);\n    bool is_winner = (my_max == global_max);\n    uint winner_lane = simd_max(is_winner ? my_idx : 0u);\n    \n    heap_vals[k] = global_max;\n    heap_idx[k] = winner_lane;\n    \n    // Branch-free invalidation\n    my_max = metal::select(my_max, -INFINITY, is_winner);\n}\n\n// Softmax with fused accumulation\nfloat logit_max = heap_vals[0];\nfloat running_sum = 0.0f;\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float delta = heap_vals[k] - logit_max;\n    heap_vals[k] = metal::fast::exp(delta);\n    running_sum += heap_vals[k];\n}\n\nfloat total = simd_sum(running_sum);\nfloat scale = metal::fast::divide(1.0f, total);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(heap_vals[tid] * scale);\n    indices[out_base + tid] = heap_idx[tid];\n}",
    "gen5_5d2baa5b1433": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load one value per thread from first half\nfloat val_lo = (float)inp[base + tid];\nfloat val_hi = (float)inp[base + tid + 32];\n\nthread float top_vals[K];\nthread uint top_idx[K];\n\nfloat curr_val = metal::max(val_lo, val_hi);\nuint curr_idx = (val_lo >= val_hi) ? tid : (tid + 32);\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float lane_max = simd_max(curr_val);\n    \n    // Use ballot to find all threads with max value\n    bool is_max = (curr_val == lane_max);\n    \n    // First set bit gives us the winner index\n    uint winner_idx = simd_min(is_max ? curr_idx : 0xFFFFFFFFu);\n    \n    top_vals[k] = lane_max;\n    top_idx[k] = winner_idx;\n    \n    // Mask out winner for next iteration\n    curr_val = (curr_idx == winner_idx) ? -INFINITY : curr_val;\n}\n\n// Softmax with fused max subtraction and exp\nfloat max_logit = top_vals[0];\nfloat sum0 = 0.0f, sum1 = 0.0f;\n\n// Manual 2x unroll for ILP\nfloat e0 = metal::precise::exp(top_vals[0] - max_logit);\nfloat e1 = metal::precise::exp(top_vals[1] - max_logit);\nsum0 += e0 + e1;\n\nfloat e2 = metal::precise::exp(top_vals[2] - max_logit);\nfloat e3 = metal::precise::exp(top_vals[3] - max_logit);\nsum1 += e2 + e3;\n\ntop_vals[0] = e0;\ntop_vals[1] = e1;\ntop_vals[2] = e2;\ntop_vals[3] = e3;\n\nfloat inv_sum = metal::precise::divide(1.0f, simd_sum(sum0 + sum1));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idx[tid];\n}",
    "gen5_9b8ba70fc157": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load two values per thread\nfloat val_lo = (float)inp[base + tid];\nfloat val_hi = (float)inp[base + tid + 32];\n\nthread float top_vals[K];\nthread uint top_idx[K];\n\nfloat curr_val = metal::max(val_lo, val_hi);\nuint curr_idx = (val_lo >= val_hi) ? tid : (tid + 32);\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    // Quad-level reduction first (lanes 0-3, 4-7, etc.)\n    float quad_max = curr_val;\n    uint quad_idx = curr_idx;\n    \n    #pragma unroll\n    for (uint offset = 1; offset < 4; ++offset) {\n        float neighbor_val = simd_shuffle_rotate_down(curr_val, offset);\n        uint neighbor_idx = simd_shuffle_rotate_down(curr_idx, offset);\n        if (neighbor_val > quad_max || (neighbor_val == quad_max && neighbor_idx < quad_idx)) {\n            quad_max = neighbor_val;\n            quad_idx = neighbor_idx;\n        }\n    }\n    \n    // Broadcast quad winners to all 32 lanes\n    float lane_max = simd_max(quad_max);\n    uint winner_idx = simd_min((quad_max == lane_max) ? quad_idx : 0xFFFFFFFFu);\n    \n    top_vals[k] = lane_max;\n    top_idx[k] = winner_idx;\n    \n    curr_val = (curr_idx == winner_idx) ? -INFINITY : curr_val;\n}\n\n// Softmax with precise reciprocal\nfloat max_logit = top_vals[0];\nfloat exp_sum = 0.0f;\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::precise::exp(top_vals[k] - max_logit);\n    top_vals[k] = e;\n    exp_sum += e;\n}\n\nfloat inv_sum = metal::precise::divide(1.0f, simd_sum(exp_sum));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idx[tid];\n}",
    "gen5_96135ae35ace": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Each thread holds 2 values\nfloat vals[2];\nvals[0] = (float)inp[base + tid];\nvals[1] = (float)inp[base + tid + 32];\n\nthread float top_vals[K];\nthread uint top_idx[K];\n\n// Build top-K using tournament elimination\nthread bool mask[2] = {false, false};\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    // Find local max among unmasked values\n    float local_max = -INFINITY;\n    uint local_idx = 0;\n    \n    #pragma unroll\n    for (uint i = 0; i < 2; ++i) {\n        if (!mask[i] && vals[i] > local_max) {\n            local_max = vals[i];\n            local_idx = tid + i * 32;\n        }\n    }\n    \n    // Global max across all threads\n    float global_max = simd_max(local_max);\n    uint winner_idx = simd_min((local_max == global_max) ? local_idx : 0xFFFFFFFFu);\n    \n    top_vals[k] = global_max;\n    top_idx[k] = winner_idx;\n    \n    // Mask out winner in local registers\n    #pragma unroll\n    for (uint i = 0; i < 2; ++i) {\n        if (tid + i * 32 == winner_idx) {\n            mask[i] = true;\n        }\n    }\n}\n\n// Parallel softmax computation\nfloat max_logit = top_vals[0];\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    top_vals[k] = metal::precise::exp(top_vals[k] - max_logit);\n}\n\nfloat sum = top_vals[0] + top_vals[1] + top_vals[2] + top_vals[3];\nfloat inv_sum = metal::precise::divide(1.0f, simd_sum(sum));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idx[tid];\n}",
    "gen5_8bc50c14b2e7": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat val_lo = (float)inp[base + tid];\nfloat val_hi = (float)inp[base + tid + 32];\n\nthread float top_vals[K];\nthread uint top_idx[K];\n\nfloat curr_val = metal::max(val_lo, val_hi);\nuint curr_idx = (val_lo >= val_hi) ? tid : (tid + 32);\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float lane_max = simd_max(curr_val);\n    bool is_max = (curr_val == lane_max);\n    uint winner_idx = simd_min(is_max ? curr_idx : 0xFFFFFFFFu);\n    \n    top_vals[k] = lane_max;\n    top_idx[k] = winner_idx;\n    \n    curr_val = (curr_idx == winner_idx) ? -INFINITY : curr_val;\n}\n\n// Kahan-compensated softmax accumulation\nfloat max_logit = top_vals[0];\nfloat sum = 0.0f;\nfloat c = 0.0f;  // Compensation term\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::precise::exp(top_vals[k] - max_logit);\n    top_vals[k] = e;\n    \n    // Kahan summation\n    float y = e - c;\n    float t = sum + y;\n    c = (t - sum) - y;\n    sum = t;\n}\n\n// Single reciprocal with FMA-based scaling\nfloat total_sum = simd_sum(sum);\nfloat inv_sum = metal::precise::divide(1.0f, total_sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)metal::fma(top_vals[tid], inv_sum, 0.0f);\n    indices[out_base + tid] = top_idx[tid];\n}",
    "gen6_8ab591c62c86": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load both values with explicit prefetch hint\nfloat val1 = (float)inp[base + tid];\nfloat val2 = (float)inp[base + tid + 32];\n\n// Parallel max computation\nfloat running_max = metal::max(val1, val2);\nuint running_idx = (val2 > val1) ? (tid + 32) : tid;\n\n// Top-k extraction\nthread float k_vals[K];\nthread uint k_idx[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float best = simd_max(running_max);\n    bool wins = (running_max == best);\n    uint winner = simd_max(wins ? running_idx : 0u);\n    \n    k_vals[i] = best;\n    k_idx[i] = winner;\n    \n    running_max = wins ? -INFINITY : running_max;\n}\n\n// Distribute softmax computation across all 32 threads\n// Each thread computes exp for one value, broadcast via shuffle\nfloat peak = k_vals[0];\nfloat my_exp = 0.0f;\n\nif (tid < K) {\n    my_exp = metal::precise::exp(k_vals[tid] - peak);\n}\n\n// Sum across warp using SIMD broadcast pattern\nfloat sum_exp = 0.0f;\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    sum_exp += simd_broadcast(my_exp, i);\n}\n\nfloat rcp = metal::precise::divide(1.0f, sum_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    float normalized = simd_broadcast(my_exp, tid) * rcp;\n    weights[out_base + tid] = (T)normalized;\n    indices[out_base + tid] = k_idx[tid];\n}",
    "gen6_b254c71c4ea3": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Pack value and index as float2\nfloat val1 = (float)inp[base + tid];\nfloat val2 = (float)inp[base + tid + 32];\n\nfloat2 pair = (val2 > val1) ? float2(val2, tid + 32) : float2(val1, tid);\n\n// Top-k using packed pairs\nthread float2 k_pairs[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float best = simd_max(pair.x);\n    bool wins = (pair.x == best);\n    uint winner = simd_max(wins ? uint(pair.y) : 0u);\n    \n    k_pairs[i] = float2(best, winner);\n    \n    pair.x = wins ? -INFINITY : pair.x;\n}\n\n// Vectorized softmax\nfloat peak = k_pairs[0].x;\nthread float exps[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    exps[i] = metal::fast::exp(k_pairs[i].x - peak);\n}\n\nfloat sum_exp = exps[0] + exps[1] + exps[2] + exps[3];\nsum_exp = simd_sum(sum_exp);\nfloat rcp = 1.0f / sum_exp;\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exps[tid] * rcp);\n    indices[out_base + tid] = uint(k_pairs[tid].y);\n}",
    "gen6_0be9027da778": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Each thread loads 2 values, compares locally\nfloat val1 = (float)inp[base + tid];\nfloat val2 = (float)inp[base + tid + 32];\n\nfloat local_max = metal::max(val1, val2);\nuint local_idx = (val2 > val1) ? (tid + 32) : tid;\n\n// Use quad shuffle for hierarchical max-finding\n// First reduce within quads (4 threads)\nfloat quad_max = local_max;\nuint quad_idx = local_idx;\n\n#pragma unroll\nfor (uint offset = 1; offset < 4; offset *= 2) {\n    float other_val = simd_shuffle_down(quad_max, offset);\n    uint other_idx = simd_shuffle_down(quad_idx, offset);\n    if (other_val > quad_max) {\n        quad_max = other_val;\n        quad_idx = other_idx;\n    }\n}\n\n// Broadcast quad results to all threads in quad\nfloat running_max = simd_shuffle(quad_max, tid & ~3u);\nuint running_idx = simd_shuffle(quad_idx, tid & ~3u);\n\n// Top-k selection\nthread float k_vals[K];\nthread uint k_idx[K];\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float best = simd_max(running_max);\n    bool wins = (running_max == best);\n    uint winner = simd_max(wins ? running_idx : 0u);\n    \n    k_vals[i] = best;\n    k_idx[i] = winner;\n    \n    running_max = wins ? -INFINITY : running_max;\n}\n\n// Fast approximate softmax\nfloat peak = k_vals[0];\nfloat sum_exp = 0.0f;\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    sum_exp += metal::fast::exp(k_vals[i] - peak);\n}\n\nfloat rcp = metal::fast::divide(1.0f, simd_sum(sum_exp));\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(metal::fast::exp(k_vals[tid] - peak) * rcp);\n    indices[out_base + tid] = k_idx[tid];\n}",
    "gen6_feed010c072d": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat val1 = (float)inp[base + tid];\nfloat val2 = (float)inp[base + tid + 32];\n\nfloat running_max = metal::max(val1, val2);\nuint running_idx = (val2 > val1) ? (tid + 32) : tid;\n\nthread float k_vals[K];\nthread uint k_idx[K];\n\n// First pass: find global peak\nfloat peak = simd_max(running_max);\n\n// Second pass: top-k with fused exp computation\nfloat running_exp_sum = 0.0f;\n\n#pragma unroll\nfor (uint i = 0; i < K; ++i) {\n    float best = simd_max(running_max);\n    bool wins = (running_max == best);\n    uint winner = simd_max(wins ? running_idx : 0u);\n    \n    k_vals[i] = best;\n    k_idx[i] = winner;\n    \n    // Immediately compute exp and accumulate\n    float exp_val = metal::precise::exp(best - peak);\n    running_exp_sum += exp_val;\n    \n    running_max = wins ? -INFINITY : running_max;\n}\n\n// Sum is already accumulated, just normalize\nfloat sum_all = simd_sum(running_exp_sum);\nfloat rcp = metal::precise::divide(1.0f, sum_all);\n\nif (tid < K) {\n    uint out_base = row * K;\n    float exp_val = metal::precise::exp(k_vals[tid] - peak);\n    weights[out_base + tid] = (T)(exp_val * rcp);\n    indices[out_base + tid] = k_idx[tid];\n}",
    "gen7_715f2f4b6fad": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Specialized work assignment: each thread handles 2 values from its half\nuint half = tid / 16;  // 0 or 1\nuint local_tid = tid % 16;\nuint idx0 = half * 32 + local_tid;\nuint idx1 = idx0 + 16;\n\nfloat v0 = (float)inp[base + idx0];\nfloat v1 = (float)inp[base + idx1];\n\n// Each thread maintains top-2 from its pair\nfloat top0_val = metal::max(v0, v1);\nfloat top1_val = metal::min(v0, v1);\nuint top0_idx = (v0 >= v1) ? idx0 : idx1;\nuint top1_idx = (v0 < v1) ? idx0 : idx1;\n\n// Within each half (16 threads), find top-2 using shuffle reduction\nfor (uint stride = 8; stride >= 1; stride >>= 1) {\n    float peer0 = simd_shuffle_down(top0_val, stride);\n    float peer1 = simd_shuffle_down(top1_val, stride);\n    uint pidx0 = simd_shuffle_down(top0_idx, stride);\n    uint pidx1 = simd_shuffle_down(top1_idx, stride);\n    \n    if (local_tid < stride) {\n        // Merge two top-2 lists into one top-2\n        float vals[4] = {top0_val, top1_val, peer0, peer1};\n        uint idxs[4] = {top0_idx, top1_idx, pidx0, pidx1};\n        \n        // Simple 4-element sort for top-2\n        for (uint i = 0; i < 3; i++) {\n            for (uint j = i + 1; j < 4; j++) {\n                if (vals[j] > vals[i]) {\n                    float tmp_v = vals[i]; vals[i] = vals[j]; vals[j] = tmp_v;\n                    uint tmp_i = idxs[i]; idxs[i] = idxs[j]; idxs[j] = tmp_i;\n                }\n            }\n        }\n        top0_val = vals[0]; top0_idx = idxs[0];\n        top1_val = vals[1]; top1_idx = idxs[1];\n    }\n}\n\n// Broadcast half-results: thread 0 has top-2 from [0:32], thread 16 has top-2 from [32:64]\nfloat h0_v0 = simd_broadcast(top0_val, 0);\nfloat h0_v1 = simd_broadcast(top1_val, 0);\nuint h0_i0 = simd_broadcast(top0_idx, 0);\nuint h0_i1 = simd_broadcast(top1_idx, 0);\n\nfloat h1_v0 = simd_broadcast(top0_val, 16);\nfloat h1_v1 = simd_broadcast(top1_val, 16);\nuint h1_i0 = simd_broadcast(top0_idx, 16);\nuint h1_i1 = simd_broadcast(top1_idx, 16);\n\n// All threads merge 4 candidates to get global top-4\nfloat vals[4] = {h0_v0, h0_v1, h1_v0, h1_v1};\nuint idxs[4] = {h0_i0, h0_i1, h1_i0, h1_i1};\n\n// Sorting network for 4 elements (5 comparisons)\nif (vals[1] > vals[0]) { float tv = vals[0]; vals[0] = vals[1]; vals[1] = tv; uint ti = idxs[0]; idxs[0] = idxs[1]; idxs[1] = ti; }\nif (vals[3] > vals[2]) { float tv = vals[2]; vals[2] = vals[3]; vals[3] = tv; uint ti = idxs[2]; idxs[2] = idxs[3]; idxs[3] = ti; }\nif (vals[2] > vals[0]) { float tv = vals[0]; vals[0] = vals[2]; vals[2] = tv; uint ti = idxs[0]; idxs[0] = idxs[2]; idxs[2] = ti; }\nif (vals[3] > vals[1]) { float tv = vals[1]; vals[1] = vals[3]; vals[3] = tv; uint ti = idxs[1]; idxs[1] = idxs[3]; idxs[3] = ti; }\nif (vals[2] > vals[1]) { float tv = vals[1]; vals[1] = vals[2]; vals[2] = tv; uint ti = idxs[1]; idxs[1] = idxs[2]; idxs[2] = ti; }\n\n// Softmax over top-4 (all threads compute same result)\nfloat max_logit = vals[0];\nfloat sum_exp = 0.0f;\nfloat exp_vals[4];\nfor (uint i = 0; i < K; i++) {\n    exp_vals[i] = metal::precise::exp(vals[i] - max_logit);\n    sum_exp += exp_vals[i];\n}\nfloat inv_sum = metal::precise::divide(1.0f, sum_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_vals[tid] * inv_sum);\n    indices[out_base + tid] = idxs[tid];\n}",
    "gen7_2d49e0c7ce86": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Initialize with local sort\nbool local_swap = v1 > v0;\nfloat my_val = local_swap ? v1 : v0;\nuint my_idx = local_swap ? (tid + 32) : tid;\n\n// Odd-even merge network optimized for K=4\n// We only need to sort enough to guarantee top-4 end up in first 4 positions\n\n// Distance 16: merge two 16-element halves\nfloat p16 = simd_shuffle_xor(my_val, 16);\nuint i16 = simd_shuffle_xor(my_idx, 16);\nbool dir16 = (tid & 16) == 0;\nbool swap16 = dir16 ? (my_val < p16) : (my_val > p16);\nmy_val = swap16 ? p16 : my_val;\nmy_idx = swap16 ? i16 : my_idx;\n\n// Distance 8\nfloat p8 = simd_shuffle_xor(my_val, 8);\nuint i8 = simd_shuffle_xor(my_idx, 8);\nbool dir8 = (tid & 8) == 0;\nbool swap8 = dir8 ? (my_val < p8) : (my_val > p8);\nmy_val = swap8 ? p8 : my_val;\nmy_idx = swap8 ? i8 : my_idx;\n\n// Distance 4 (critical for top-4)\nfloat p4 = simd_shuffle_xor(my_val, 4);\nuint i4 = simd_shuffle_xor(my_idx, 4);\nbool dir4 = (tid & 4) == 0;\nbool swap4 = dir4 ? (my_val < p4) : (my_val > p4);\nmy_val = swap4 ? p4 : my_val;\nmy_idx = swap4 ? i4 : my_idx;\n\n// Distance 2\nfloat p2 = simd_shuffle_xor(my_val, 2);\nuint i2 = simd_shuffle_xor(my_idx, 2);\nbool dir2 = (tid & 2) == 0;\nbool swap2 = dir2 ? (my_val < p2) : (my_val > p2);\nmy_val = swap2 ? p2 : my_val;\nmy_idx = swap2 ? i2 : my_idx;\n\n// Distance 1\nfloat p1 = simd_shuffle_xor(my_val, 1);\nuint i1 = simd_shuffle_xor(my_idx, 1);\nbool dir1 = (tid & 1) == 0;\nbool swap1 = dir1 ? (my_val < p1) : (my_val > p1);\nmy_val = swap1 ? p1 : my_val;\nmy_idx = swap1 ? i1 : my_idx;\n\n// Final cleanup pass for guaranteed top-4\nif (tid < 8) {\n    float p4b = simd_shuffle_xor(my_val, 4);\n    uint i4b = simd_shuffle_xor(my_idx, 4);\n    bool swap4b = (tid < 4) ? (my_val < p4b) : (my_val > p4b);\n    my_val = swap4b ? p4b : my_val;\n    my_idx = swap4b ? i4b : my_idx;\n}\n\nif (tid < K) {\n    // Softmax distributed across K threads\n    float max_logit = simd_broadcast(my_val, 0);\n    float exp_val = metal::precise::exp(my_val - max_logit);\n    float sum_exp = simd_sum(exp_val);\n    \n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_val * metal::precise::divide(1.0f, sum_exp));\n    indices[out_base + tid] = my_idx;\n}",
    "gen7_e249dff05730": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat my_val = metal::max(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\nbool alive = true;\n\n// Tournament round 1: 32\u219216 (compare with distance 1)\nfloat peer = simd_shuffle_xor(my_val, 1);\nuint peer_idx = simd_shuffle_xor(my_idx, 1);\nif ((tid & 1) == 1) {\n    alive = (my_val > peer);\n} else {\n    if (peer > my_val) {\n        my_val = peer;\n        my_idx = peer_idx;\n    }\n}\n\n// Round 2: 16\u21928 (distance 2, only even threads from round 1)\nif (alive && (tid & 1) == 0) {\n    peer = simd_shuffle_xor(my_val, 2);\n    peer_idx = simd_shuffle_xor(my_idx, 2);\n    if ((tid & 2) == 2) {\n        alive = (my_val > peer);\n    } else if (peer > my_val) {\n        my_val = peer;\n        my_idx = peer_idx;\n    }\n}\n\n// Round 3: 8\u21924 (distance 4)\nif (alive && (tid & 3) == 0) {\n    peer = simd_shuffle_xor(my_val, 4);\n    peer_idx = simd_shuffle_xor(my_idx, 4);\n    if ((tid & 4) == 4) {\n        alive = (my_val > peer);\n    } else if (peer > my_val) {\n        my_val = peer;\n        my_idx = peer_idx;\n    }\n}\n\n// Round 4: 4\u2192top-4 finalists (keep all, just sort)\nif (tid < 8) {\n    peer = simd_shuffle_xor(my_val, 4);\n    peer_idx = simd_shuffle_xor(my_idx, 4);\n    bool should_swap = ((tid & 4) == 0) ? (my_val < peer) : (my_val > peer);\n    if (should_swap) {\n        my_val = peer;\n        my_idx = peer_idx;\n    }\n}\n\n// Final sort among top-4 using 3-stage bitonic\nif (tid < 4) {\n    // Stage 1: pairs\n    peer = simd_shuffle_xor(my_val, 1);\n    peer_idx = simd_shuffle_xor(my_idx, 1);\n    bool s1 = ((tid & 1) == 0) ? (my_val < peer) : (my_val > peer);\n    if (s1) { my_val = peer; my_idx = peer_idx; }\n    \n    // Stage 2: distance 2 then 1\n    peer = simd_shuffle_xor(my_val, 2);\n    peer_idx = simd_shuffle_xor(my_idx, 2);\n    bool s2 = ((tid & 2) == 0) ? (my_val < peer) : (my_val > peer);\n    if (s2) { my_val = peer; my_idx = peer_idx; }\n    \n    peer = simd_shuffle_xor(my_val, 1);\n    peer_idx = simd_shuffle_xor(my_idx, 1);\n    bool s3 = ((tid & 1) == 0) ? (my_val < peer) : (my_val > peer);\n    if (s3) { my_val = peer; my_idx = peer_idx; }\n    \n    // Softmax (only 4 threads active)\n    float max_logit = simd_broadcast(my_val, 0);\n    float exp_val = metal::precise::exp(my_val - max_logit);\n    float sum_exp = exp_val;\n    sum_exp += simd_shuffle(exp_val, 1);\n    sum_exp += simd_shuffle(exp_val, 2);\n    sum_exp += simd_shuffle(exp_val, 3);\n    \n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_val * metal::precise::divide(1.0f, sum_exp));\n    indices[out_base + tid] = my_idx;\n}",
    "gen7_37a6bdb871a4": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Each thread gets max of its two values\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nfloat my_val = metal::max(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Compute rank by counting how many peers have strictly greater values\nuint rank = 0;\nfor (uint offset = 1; offset < SG; offset <<= 1) {\n    float peer_val = simd_shuffle_xor(my_val, offset);\n    // Count peers strictly greater\n    if (peer_val > my_val) rank++;\n    // Tie-breaking: if equal, lower index wins\n    else if (peer_val == my_val) {\n        uint peer_idx = simd_shuffle_xor(my_idx, offset);\n        if (peer_idx < my_idx) rank++;\n    }\n}\n\n// Threads with rank < K are in top-K\nif (rank < K) {\n    // Gather all top-4 values for softmax via broadcasts\n    // Find which thread has each rank\n    float topk_vals[K];\n    uint topk_idxs[K];\n    \n    for (uint r = 0; r < K; r++) {\n        // Broadcast from thread with this rank\n        for (uint scan_tid = 0; scan_tid < SG; scan_tid++) {\n            uint peer_rank = simd_broadcast(rank, scan_tid);\n            if (peer_rank == r) {\n                topk_vals[r] = simd_broadcast(my_val, scan_tid);\n                topk_idxs[r] = simd_broadcast(my_idx, scan_tid);\n                break;\n            }\n        }\n    }\n    \n    // Softmax over gathered top-4\n    float max_logit = topk_vals[0];  // rank 0 has max value\n    float sum_exp = 0.0f;\n    float exp_vals[K];\n    for (uint i = 0; i < K; i++) {\n        exp_vals[i] = metal::precise::exp(topk_vals[i] - max_logit);\n        sum_exp += exp_vals[i];\n    }\n    float inv_sum = metal::precise::divide(1.0f, sum_exp);\n    \n    // Each top-4 thread writes its own output\n    uint out_base = row * K;\n    weights[out_base + rank] = (T)(exp_vals[rank] * inv_sum);\n    indices[out_base + rank] = my_idx;\n}",
    "gen8_6683d707a647": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load 2 values per thread\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Local top-2 selection\nfloat local_max0 = metal::max(v0, v1);\nfloat local_max1 = metal::min(v0, v1);\nuint local_idx0 = (v0 >= v1) ? tid : (tid + 32);\nuint local_idx1 = (v0 < v1) ? tid : (tid + 32);\n\n// Hierarchical merge using simd_shuffle (5 iterations for 32 threads)\nthread float heap_vals[K];\nthread uint heap_idx[K];\n\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float peer_max0 = simd_shuffle(local_max0, tid ^ offset);\n    uint peer_idx0 = simd_shuffle(local_idx0, tid ^ offset);\n    \n    if (peer_max0 > local_max1) {\n        if (peer_max0 > local_max0) {\n            local_max1 = local_max0;\n            local_idx1 = local_idx0;\n            local_max0 = peer_max0;\n            local_idx0 = peer_idx0;\n        } else {\n            local_max1 = peer_max0;\n            local_idx1 = peer_idx0;\n        }\n    }\n}\n\n// Broadcast top-K from lane 0\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    heap_vals[k] = simd_broadcast(k < 2 ? (k == 0 ? local_max0 : local_max1) : -INFINITY, 0);\n    heap_idx[k] = simd_broadcast(k < 2 ? (k == 0 ? local_idx0 : local_idx1) : 0u, 0);\n}\n\n// Collect remaining top-K candidates\nif (tid == 0) {\n    thread float all_vals[8];\n    thread uint all_idx[8];\n    all_vals[0] = local_max0; all_idx[0] = local_idx0;\n    all_vals[1] = local_max1; all_idx[1] = local_idx1;\n    \n    // Gather top-2 from other key lanes\n    for (uint i = 1; i < 4; ++i) {\n        all_vals[i*2] = simd_shuffle(local_max0, i * 8);\n        all_idx[i*2] = simd_shuffle(local_idx0, i * 8);\n        all_vals[i*2+1] = simd_shuffle(local_max1, i * 8);\n        all_idx[i*2+1] = simd_shuffle(local_idx1, i * 8);\n    }\n    \n    // Selection sort for top-K\n    for (uint k = 0; k < K; ++k) {\n        uint max_pos = k;\n        for (uint j = k + 1; j < 8; ++j) {\n            if (all_vals[j] > all_vals[max_pos]) max_pos = j;\n        }\n        heap_vals[k] = all_vals[max_pos];\n        heap_idx[k] = all_idx[max_pos];\n        all_vals[max_pos] = -INFINITY;\n    }\n}\n\n// Broadcast final top-K\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    heap_vals[k] = simd_broadcast(heap_vals[k], 0);\n    heap_idx[k] = simd_broadcast(heap_idx[k], 0);\n}\n\n// Softmax\nfloat logit_max = heap_vals[0];\nfloat sum_exp = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    heap_vals[k] = metal::fast::exp(heap_vals[k] - logit_max);\n    sum_exp += heap_vals[k];\n}\nfloat inv_sum = metal::fast::divide(1.0f, sum_exp);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(heap_vals[tid] * inv_sum);\n    indices[out_base + tid] = heap_idx[tid];\n}",
    "gen8_11a0ea524cb3": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nthreadgroup float shared_vals[64];\nthreadgroup uint shared_idx[64];\n\n// Cooperative load into threadgroup memory\nshared_vals[tid] = (float)inp[base + tid];\nshared_vals[tid + 32] = (float)inp[base + tid + 32];\nshared_idx[tid] = tid;\nshared_idx[tid + 32] = tid + 32;\n\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nthread float heap_vals[K];\nthread uint heap_idx[K];\n\nif (tid == 0) {\n    // Initialize heap with first K elements\n    #pragma unroll\n    for (uint k = 0; k < K; ++k) {\n        heap_vals[k] = shared_vals[k];\n        heap_idx[k] = shared_idx[k];\n    }\n    \n    // Build max-heap\n    for (uint i = K; i < D; ++i) {\n        float val = shared_vals[i];\n        if (val > heap_vals[K-1]) {\n            // Insert and bubble up\n            heap_vals[K-1] = val;\n            heap_idx[K-1] = i;\n            \n            // Bubble up\n            for (uint k = K-1; k > 0; --k) {\n                if (heap_vals[k] > heap_vals[k-1]) {\n                    float tmp_v = heap_vals[k];\n                    uint tmp_i = heap_idx[k];\n                    heap_vals[k] = heap_vals[k-1];\n                    heap_idx[k] = heap_idx[k-1];\n                    heap_vals[k-1] = tmp_v;\n                    heap_idx[k-1] = tmp_i;\n                }\n            }\n        }\n    }\n}\n\n// Broadcast results\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    heap_vals[k] = simd_broadcast(heap_vals[k], 0);\n    heap_idx[k] = simd_broadcast(heap_idx[k], 0);\n}\n\n// Parallel softmax computation\nfloat logit_max = heap_vals[0];\nthread float exp_vals[K];\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    exp_vals[k] = metal::fast::exp(heap_vals[k] - logit_max);\n}\n\nfloat partial_sum = 0.0f;\nif (tid < K) {\n    partial_sum = exp_vals[tid];\n}\nfloat total_sum = simd_sum(partial_sum);\nfloat inv_sum = metal::fast::divide(1.0f, total_sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_vals[tid] * inv_sum);\n    indices[out_base + tid] = heap_idx[tid];\n}",
    "gen8_6b70f9d8fde7": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Maintain sorted top-K using predicated blend\nthread float vals[K];\nthread uint idxs[K];\n\n// Initialize with local values\nvals[0] = metal::max(v0, v1);\nidxs[0] = (v0 >= v1) ? tid : (tid + 32);\nvals[1] = metal::min(v0, v1);\nidxs[1] = (v0 < v1) ? tid : (tid + 32);\nvals[2] = -INFINITY;\nidxs[2] = 0;\nvals[3] = -INFINITY;\nidxs[3] = 0;\n\n// Iterative reduction across warp with sorting network\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float candidate = simd_max(vals[k]);\n    bool is_source = (vals[k] == candidate);\n    uint candidate_idx = simd_max(is_source ? idxs[k] : 0u);\n    \n    // Insert candidate into sorted position (all threads compute)\n    thread float new_vals[K];\n    thread uint new_idxs[K];\n    \n    uint insert_pos = K;\n    #pragma unroll\n    for (uint i = 0; i < K; ++i) {\n        if (candidate > vals[i] && insert_pos == K) {\n            insert_pos = i;\n        }\n    }\n    \n    // Shift and insert\n    #pragma unroll\n    for (uint i = 0; i < K; ++i) {\n        if (i < insert_pos) {\n            new_vals[i] = vals[i];\n            new_idxs[i] = idxs[i];\n        } else if (i == insert_pos) {\n            new_vals[i] = candidate;\n            new_idxs[i] = candidate_idx;\n        } else if (i < K) {\n            new_vals[i] = vals[i-1];\n            new_idxs[i] = idxs[i-1];\n        }\n    }\n    \n    #pragma unroll\n    for (uint i = 0; i < K; ++i) {\n        vals[i] = new_vals[i];\n        idxs[i] = new_idxs[i];\n    }\n    \n    // Invalidate source\n    vals[k] = metal::select(vals[k], -INFINITY, is_source);\n}\n\n// Softmax with vectorized ops\nfloat max_val = vals[0];\nthread float exp_vals[K];\nfloat sum_local = 0.0f;\n\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    exp_vals[k] = metal::fast::exp(vals[k] - max_val);\n    sum_local += exp_vals[k];\n}\n\nfloat total = simd_sum(sum_local);\nfloat scale = metal::fast::divide(1.0f, total);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_vals[tid] * scale);\n    indices[out_base + tid] = idxs[tid];\n}",
    "gen8_47f23ecd0587": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Prefetch into registers\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\nthread float heap[K];\nthread uint indices[K];\nthread float heap_next[K];\nthread uint indices_next[K];\n\n// Initialize double buffer\nfloat my_max = metal::max(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Unroll K iterations with prefetch\n// Iteration 0\nfloat global_max = simd_max(my_max);\nbool winner = (my_max == global_max);\nuint winner_idx = simd_max(winner ? my_idx : 0u);\nheap[0] = global_max;\nindices[0] = winner_idx;\n\n// Prefetch iteration 1 while storing 0\nmy_max = metal::select(my_max, -INFINITY, winner);\nfloat global_max_next = simd_max(my_max);\n\n// Iteration 1\nwinner = (my_max == global_max_next);\nwinner_idx = simd_max(winner ? my_idx : 0u);\nheap[1] = global_max_next;\nindices[1] = winner_idx;\n\n// Prefetch iteration 2\nmy_max = metal::select(my_max, -INFINITY, winner);\nglobal_max = simd_max(my_max);\n\n// Iteration 2\nwinner = (my_max == global_max);\nwinner_idx = simd_max(winner ? my_idx : 0u);\nheap[2] = global_max;\nindices[2] = winner_idx;\n\n// Prefetch iteration 3\nmy_max = metal::select(my_max, -INFINITY, winner);\nglobal_max_next = simd_max(my_max);\n\n// Iteration 3\nwinner = (my_max == global_max_next);\nwinner_idx = simd_max(winner ? my_idx : 0u);\nheap[3] = global_max_next;\nindices[3] = winner_idx;\n\n// Softmax with interleaved exp and sum\nfloat max_logit = heap[0];\nfloat exp0 = metal::fast::exp(heap[0] - max_logit);\nfloat exp1 = metal::fast::exp(heap[1] - max_logit);\nfloat exp2 = metal::fast::exp(heap[2] - max_logit);\nfloat exp3 = metal::fast::exp(heap[3] - max_logit);\n\n// Parallel reduction of partial sums\nfloat sum_pair0 = exp0 + exp1;\nfloat sum_pair1 = exp2 + exp3;\nfloat sum_all = sum_pair0 + sum_pair1;\n\nfloat total = simd_sum(sum_all);\nfloat inv_total = metal::fast::divide(1.0f, total);\n\nif (tid < K) {\n    uint out_base = row * K;\n    thread float exp_arr[4] = {exp0, exp1, exp2, exp3};\n    weights[out_base + tid] = (T)(exp_arr[tid] * inv_total);\n    indices[out_base + tid] = indices[tid];\n}",
    "gen9_cdce14a003a8": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Each thread loads 2 values (D=64, SG=32)\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nuint i0 = tid;\nuint i1 = tid + 32;\n\n// Parallel reduction: each thread finds its local max\nfloat local_max = fmax(v0, v1);\nuint local_idx = (v0 >= v1) ? i0 : i1;\n\n// SIMD-level top-4 using tournament tree\nthread float vals[K] = {-INFINITY, -INFINITY, -INFINITY, -INFINITY};\nthread uint idxs[K] = {0, 0, 0, 0};\n\nvals[0] = local_max;\nidxs[0] = local_idx;\n\n// Round 1: find global max via SIMD shuffle tournament\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float other_val = simd_shuffle_down(vals[0], offset);\n    uint other_idx = simd_shuffle_down(idxs[0], offset);\n    if (other_val > vals[0]) {\n        vals[0] = other_val;\n        idxs[0] = other_idx;\n    }\n}\nvals[0] = simd_broadcast(vals[0], 0);\nidxs[0] = simd_broadcast(idxs[0], 0);\n\n// Mask out winner for round 2\nbool masked0 = (local_idx == idxs[0]);\nfloat masked_max1 = masked0 ? -INFINITY : local_max;\nvals[1] = masked_max1;\nidxs[1] = masked0 ? 0 : local_idx;\n\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float other_val = simd_shuffle_down(vals[1], offset);\n    uint other_idx = simd_shuffle_down(idxs[1], offset);\n    if (other_val > vals[1]) {\n        vals[1] = other_val;\n        idxs[1] = other_idx;\n    }\n}\nvals[1] = simd_broadcast(vals[1], 0);\nidxs[1] = simd_broadcast(idxs[1], 0);\n\n// Round 3\nbool masked1 = (local_idx == idxs[0]) || (local_idx == idxs[1]);\nfloat masked_max2 = masked1 ? -INFINITY : local_max;\nvals[2] = masked_max2;\nidxs[2] = masked1 ? 0 : local_idx;\n\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float other_val = simd_shuffle_down(vals[2], offset);\n    uint other_idx = simd_shuffle_down(idxs[2], offset);\n    if (other_val > vals[2]) {\n        vals[2] = other_val;\n        idxs[2] = other_idx;\n    }\n}\nvals[2] = simd_broadcast(vals[2], 0);\nidxs[2] = simd_broadcast(idxs[2], 0);\n\n// Round 4\nbool masked2 = (local_idx == idxs[0]) || (local_idx == idxs[1]) || (local_idx == idxs[2]);\nfloat masked_max3 = masked2 ? -INFINITY : local_max;\nvals[3] = masked_max3;\nidxs[3] = masked2 ? 0 : local_idx;\n\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float other_val = simd_shuffle_down(vals[3], offset);\n    uint other_idx = simd_shuffle_down(idxs[3], offset);\n    if (other_val > vals[3]) {\n        vals[3] = other_val;\n        idxs[3] = other_idx;\n    }\n}\nvals[3] = simd_broadcast(vals[3], 0);\nidxs[3] = simd_broadcast(idxs[3], 0);\n\n// Parallel softmax\nfloat max_val = vals[0];\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::fast::exp(vals[k] - max_val);\n    vals[k] = e;\n    sum += e;\n}\nfloat inv_sum = metal::fast::divide(1.0f, sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(vals[tid] * inv_sum);\n    indices[out_base + tid] = idxs[tid];\n}",
    "gen9_f6ad3cb4c0e0": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load 2 values per thread\nfloat vals[2];\nvals[0] = (float)inp[base + tid];\nvals[1] = (float)inp[base + tid + 32];\n\n// Find quad-local top-1 using quad_shuffle\nuint quad_id = tid / 4;\nuint lane = tid % 4;\n\nfloat quad_max = fmax(vals[0], vals[1]);\nuint quad_idx = (vals[0] >= vals[1]) ? tid : (tid + 32);\n\n#pragma unroll\nfor (uint i = 0; i < 2; ++i) {\n    float other_val = quad_shuffle(quad_max, (lane + 1 + i) % 4);\n    uint other_idx = quad_shuffle(quad_idx, (lane + 1 + i) % 4);\n    if (other_val > quad_max) {\n        quad_max = other_val;\n        quad_idx = other_idx;\n    }\n}\n\n// Broadcast quad winners to all lanes in quad\nquad_max = quad_shuffle(quad_max, 0);\nquad_idx = quad_shuffle(quad_idx, 0);\n\n// Now we have 8 quad winners (tid 0, 4, 8, 12, 16, 20, 24, 28)\n// Merge using SIMD shuffle across quads\nfloat simd_max = quad_max;\nuint simd_idx = quad_idx;\n\nif (lane == 0) {\n    #pragma unroll\n    for (uint offset = 4; offset < 32; offset += 4) {\n        float other_val = simd_shuffle_down(simd_max, offset);\n        uint other_idx = simd_shuffle_down(simd_idx, offset);\n        if (other_val > simd_max) {\n            simd_max = other_val;\n            simd_idx = other_idx;\n        }\n    }\n}\n\n// Broadcast final top-1\nthread float top_vals[K];\nthread uint top_idxs[K];\n\ntop_vals[0] = simd_broadcast(simd_max, 0);\ntop_idxs[0] = simd_broadcast(simd_idx, 0);\n\n// Repeat for top-2, top-3, top-4 with masking\nfor (uint round = 1; round < K; ++round) {\n    bool is_masked = false;\n    #pragma unroll\n    for (uint p = 0; p < round; ++p) {\n        if (tid == top_idxs[p] || (tid + 32) == top_idxs[p]) {\n            is_masked = true;\n        }\n    }\n    \n    float masked_max = is_masked ? -INFINITY : fmax(vals[0], vals[1]);\n    uint masked_idx = is_masked ? 0 : ((vals[0] >= vals[1]) ? tid : (tid + 32));\n    \n    // Quad reduction\n    float q_max = masked_max;\n    uint q_idx = masked_idx;\n    #pragma unroll\n    for (uint i = 0; i < 2; ++i) {\n        float other = quad_shuffle(q_max, (lane + 1 + i) % 4);\n        uint other_i = quad_shuffle(q_idx, (lane + 1 + i) % 4);\n        if (other > q_max) {\n            q_max = other;\n            q_idx = other_i;\n        }\n    }\n    q_max = quad_shuffle(q_max, 0);\n    q_idx = quad_shuffle(q_idx, 0);\n    \n    // SIMD reduction\n    if (lane == 0) {\n        #pragma unroll\n        for (uint offset = 4; offset < 32; offset += 4) {\n            float other = simd_shuffle_down(q_max, offset);\n            uint other_i = simd_shuffle_down(q_idx, offset);\n            if (other > q_max) {\n                q_max = other;\n                q_idx = other_i;\n            }\n        }\n    }\n    \n    top_vals[round] = simd_broadcast(q_max, 0);\n    top_idxs[round] = simd_broadcast(q_idx, 0);\n}\n\n// Softmax\nfloat max_val = top_vals[0];\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::fast::exp(top_vals[k] - max_val);\n    top_vals[k] = e;\n    sum += e;\n}\nfloat inv_sum = metal::fast::divide(1.0f, sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idxs[tid];\n}",
    "gen9_247b39725f53": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\nuint i0 = tid;\nuint i1 = tid + 32;\n\n// Find local max first for logit normalization\nfloat local_max = fmax(v0, v1);\nfloat global_max = simd_max(local_max);\n\n// Precompute exp values relative to global max\nfloat exp0 = metal::fast::exp(v0 - global_max);\nfloat exp1 = metal::fast::exp(v1 - global_max);\n\nthread float top_vals[K];\nthread uint top_idxs[K];\nthread float top_exps[K];\n\n// Initialize\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    top_vals[k] = -INFINITY;\n    top_idxs[k] = 0;\n    top_exps[k] = 0.0f;\n}\n\n// Round 1: find top-1 and its exp\nfloat cand_val = local_max;\nuint cand_idx = (v0 >= v1) ? i0 : i1;\nfloat cand_exp = (v0 >= v1) ? exp0 : exp1;\n\n#pragma unroll\nfor (uint offset = 16; offset >= 1; offset >>= 1) {\n    float other_val = simd_shuffle_down(cand_val, offset);\n    uint other_idx = simd_shuffle_down(cand_idx, offset);\n    float other_exp = simd_shuffle_down(cand_exp, offset);\n    if (other_val > cand_val) {\n        cand_val = other_val;\n        cand_idx = other_idx;\n        cand_exp = other_exp;\n    }\n}\ntop_vals[0] = simd_broadcast(cand_val, 0);\ntop_idxs[0] = simd_broadcast(cand_idx, 0);\ntop_exps[0] = simd_broadcast(cand_exp, 0);\n\n// Rounds 2-4 with masking\nfor (uint round = 1; round < K; ++round) {\n    bool is_winner0 = (i0 == top_idxs[round-1]);\n    bool is_winner1 = (i1 == top_idxs[round-1]);\n    \n    float next_val, next_exp;\n    uint next_idx;\n    \n    if (is_winner0 && is_winner1) {\n        next_val = -INFINITY;\n        next_idx = 0;\n        next_exp = 0.0f;\n    } else if (is_winner0) {\n        next_val = v1;\n        next_idx = i1;\n        next_exp = exp1;\n    } else if (is_winner1) {\n        next_val = v0;\n        next_idx = i0;\n        next_exp = exp0;\n    } else {\n        next_val = fmax(v0, v1);\n        next_idx = (v0 >= v1) ? i0 : i1;\n        next_exp = (v0 >= v1) ? exp0 : exp1;\n    }\n    \n    #pragma unroll\n    for (uint offset = 16; offset >= 1; offset >>= 1) {\n        float other_val = simd_shuffle_down(next_val, offset);\n        uint other_idx = simd_shuffle_down(next_idx, offset);\n        float other_exp = simd_shuffle_down(next_exp, offset);\n        if (other_val > next_val) {\n            next_val = other_val;\n            next_idx = other_idx;\n            next_exp = other_exp;\n        }\n    }\n    \n    top_vals[round] = simd_broadcast(next_val, 0);\n    top_idxs[round] = simd_broadcast(next_idx, 0);\n    top_exps[round] = simd_broadcast(next_exp, 0);\n}\n\n// Finalize softmax: sum already in exp form\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    sum += top_exps[k];\n}\nfloat inv_sum = metal::fast::divide(1.0f, sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_exps[tid] * inv_sum);\n    indices[out_base + tid] = top_idxs[tid];\n}",
    "gen9_2c11999c024e": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load all 64 values into threadgroup memory for sorting\nthreadgroup float shared_vals[64];\nthreadgroup uint shared_idxs[64];\n\nshared_vals[tid] = (float)inp[base + tid];\nshared_vals[tid + 32] = (float)inp[base + tid + 32];\nshared_idxs[tid] = tid;\nshared_idxs[tid + 32] = tid + 32;\n\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\n// Each thread sorts a local chunk of 4 elements using sorting network\n// Thread 0 handles 0-3, thread 1 handles 4-7, etc.\nuint chunk_start = tid * 2;\nif (chunk_start + 1 < D) {\n    float v0 = shared_vals[chunk_start];\n    float v1 = shared_vals[chunk_start + 1];\n    uint i0 = shared_idxs[chunk_start];\n    uint i1 = shared_idxs[chunk_start + 1];\n    \n    // Compare-swap\n    if (v1 > v0) {\n        shared_vals[chunk_start] = v1;\n        shared_vals[chunk_start + 1] = v0;\n        shared_idxs[chunk_start] = i1;\n        shared_idxs[chunk_start + 1] = i0;\n    }\n}\n\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\n// Now merge sorted pairs using SIMD-level bitonic merge\n// Extract top-4 using parallel reduction\nthread float heap[K];\nthread uint heap_idx[K];\n\nif (tid == 0) {\n    // Initialize with first K\n    #pragma unroll\n    for (uint k = 0; k < K; ++k) {\n        heap[k] = shared_vals[k];\n        heap_idx[k] = shared_idxs[k];\n    }\n    \n    // Insertion sort for remaining elements\n    for (uint i = K; i < D; ++i) {\n        float val = shared_vals[i];\n        uint idx = shared_idxs[i];\n        \n        if (val > heap[K-1]) {\n            // Insert at end\n            heap[K-1] = val;\n            heap_idx[K-1] = idx;\n            \n            // Bubble up to maintain sorted order\n            for (int k = K-2; k >= 0; --k) {\n                if (heap[k+1] > heap[k]) {\n                    float tmp_v = heap[k];\n                    uint tmp_i = heap_idx[k];\n                    heap[k] = heap[k+1];\n                    heap_idx[k] = heap_idx[k+1];\n                    heap[k+1] = tmp_v;\n                    heap_idx[k+1] = tmp_i;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n}\n\n// Broadcast sorted top-K\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    heap[k] = simd_broadcast(heap[k], 0);\n    heap_idx[k] = simd_broadcast(heap_idx[k], 0);\n}\n\n// Parallel softmax with fast math\nfloat max_val = heap[0];\nthread float exps[K];\nfloat partial_sum = 0.0f;\n\nif (tid < K) {\n    exps[tid] = metal::fast::exp(heap[tid] - max_val);\n    partial_sum = exps[tid];\n}\n\nfloat total_sum = simd_sum(partial_sum);\nfloat inv_sum = metal::fast::divide(1.0f, total_sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exps[tid] * inv_sum);\n    indices[out_base + tid] = heap_idx[tid];\n}",
    "gen10_790bf6e10a36": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\n// Load 2 values per thread\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// XOR-based butterfly reduction for top-1\nfloat my_max = fmax(v0, v1);\nuint my_idx = (v0 >= v1) ? tid : (tid + 32);\n\n// Butterfly network using XOR shuffles (log2(32) = 5 steps)\n#pragma unroll\nfor (uint offset = 16; offset > 0; offset >>= 1) {\n    float other_val = quad_shuffle_xor(my_max, offset);\n    uint other_idx = quad_shuffle_xor(my_idx, offset);\n    if (other_val > my_max) {\n        my_max = other_val;\n        my_idx = other_idx;\n    }\n}\n\nthread float top_vals[K];\nthread uint top_idxs[K];\ntop_vals[0] = my_max;\ntop_idxs[0] = my_idx;\n\n// Subsequent rounds with masking\nfor (uint round = 1; round < K; ++round) {\n    bool masked = false;\n    #pragma unroll\n    for (uint p = 0; p < round; ++p) {\n        masked = masked || (tid == top_idxs[p]) || ((tid + 32) == top_idxs[p]);\n    }\n    \n    float curr_max = masked ? -INFINITY : fmax(v0, v1);\n    uint curr_idx = masked ? 0 : ((v0 >= v1) ? tid : (tid + 32));\n    \n    #pragma unroll\n    for (uint offset = 16; offset > 0; offset >>= 1) {\n        float other_val = quad_shuffle_xor(curr_max, offset);\n        uint other_idx = quad_shuffle_xor(curr_idx, offset);\n        if (other_val > curr_max) {\n            curr_max = other_val;\n            curr_idx = other_idx;\n        }\n    }\n    \n    top_vals[round] = curr_max;\n    top_idxs[round] = curr_idx;\n}\n\n// Softmax with fast math\nfloat max_val = top_vals[0];\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::fast::exp(top_vals[k] - max_val);\n    top_vals[k] = e;\n    sum += e;\n}\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * metal::fast::divide(1.0f, sum));\n    indices[out_base + tid] = top_idxs[tid];\n}",
    "gen10_4f3cc9bfeb14": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// First pass: estimate top-K threshold from first 32 values\nfloat threshold = v0;\n#pragma unroll\nfor (uint offset = 16; offset > 0; offset >>= 1) {\n    float other = simd_shuffle_xor(threshold, offset);\n    threshold = fmax(threshold, other);\n}\n// Broadcast max of first 32 to all threads\nthreshold = simd_broadcast(threshold, 0);\n\n// Second pass: only process v1 if it exceeds 90% of first-half max\nfloat candidates[2];\nuint candidate_idxs[2];\nuint candidate_count = 1;\ncandidates[0] = v0;\ncandidate_idxs[0] = tid;\n\nif (v1 > threshold * 0.9f) {\n    candidates[1] = v1;\n    candidate_idxs[1] = tid + 32;\n    candidate_count = 2;\n}\n\nthread float top_vals[K];\nthread uint top_idxs[K];\n\nfor (uint round = 0; round < K; ++round) {\n    float my_max = -INFINITY;\n    uint my_idx = 0;\n    \n    for (uint i = 0; i < candidate_count; ++i) {\n        bool is_masked = false;\n        #pragma unroll\n        for (uint p = 0; p < round; ++p) {\n            if (candidate_idxs[i] == top_idxs[p]) {\n                is_masked = true;\n            }\n        }\n        if (!is_masked && candidates[i] > my_max) {\n            my_max = candidates[i];\n            my_idx = candidate_idxs[i];\n        }\n    }\n    \n    #pragma unroll\n    for (uint offset = 16; offset > 0; offset >>= 1) {\n        float other_val = simd_shuffle_xor(my_max, offset);\n        uint other_idx = simd_shuffle_xor(my_idx, offset);\n        if (other_val > my_max) {\n            my_max = other_val;\n            my_idx = other_idx;\n        }\n    }\n    \n    top_vals[round] = my_max;\n    top_idxs[round] = my_idx;\n}\n\n// Softmax\nfloat max_val = top_vals[0];\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::fast::exp(top_vals[k] - max_val);\n    top_vals[k] = e;\n    sum += e;\n}\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * metal::fast::divide(1.0f, sum));\n    indices[out_base + tid] = top_idxs[tid];\n}",
    "gen10_ee22e6d5140b": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\n// Sort local pair\nfloat my_max = fmax(v0, v1);\nfloat my_min = fmin(v0, v1);\nuint idx_max = (v0 >= v1) ? tid : (tid + 32);\nuint idx_min = (v0 >= v1) ? (tid + 32) : tid;\n\n// Parallel bitonic sort for top-K extraction\n// Each thread holds 2 sorted elements, merge to extract K=4\n\n// Stage 1: Compare-exchange across distance 1\nfloat other_max = simd_shuffle_xor(my_max, 1);\nfloat other_min = simd_shuffle_xor(my_min, 1);\nuint other_idx_max = simd_shuffle_xor(idx_max, 1);\nuint other_idx_min = simd_shuffle_xor(idx_min, 1);\n\nbool swap = (tid & 1) ? (my_max < other_max) : (my_max > other_max);\nif (swap) {\n    float tmp = my_max; my_max = other_max; other_max = tmp;\n    uint tmp_idx = idx_max; idx_max = other_idx_max; other_idx_max = tmp_idx;\n}\n\n// Collect top-4 from tid=0,1 (holds 4 highest)\nthread float top_vals[K];\nthread uint top_idxs[K];\n\nif (tid == 0) {\n    top_vals[0] = my_max;\n    top_vals[1] = my_min;\n    top_idxs[0] = idx_max;\n    top_idxs[1] = idx_min;\n} else if (tid == 1) {\n    top_vals[2] = my_max;\n    top_vals[3] = my_min;\n    top_idxs[2] = idx_max;\n    top_idxs[3] = idx_min;\n}\n\n// Broadcast from tid 0,1 to all threads\nif (tid >= 2) {\n    top_vals[0] = simd_broadcast(top_vals[0], 0);\n    top_vals[1] = simd_broadcast(top_vals[1], 0);\n    top_vals[2] = simd_broadcast(top_vals[2], 1);\n    top_vals[3] = simd_broadcast(top_vals[3], 1);\n    top_idxs[0] = simd_broadcast(top_idxs[0], 0);\n    top_idxs[1] = simd_broadcast(top_idxs[1], 0);\n    top_idxs[2] = simd_broadcast(top_idxs[2], 1);\n    top_idxs[3] = simd_broadcast(top_idxs[3], 1);\n}\n\n// Manual 4-element sort\n#pragma unroll\nfor (uint i = 0; i < K - 1; ++i) {\n    #pragma unroll\n    for (uint j = i + 1; j < K; ++j) {\n        if (top_vals[j] > top_vals[i]) {\n            float tmp_v = top_vals[i];\n            top_vals[i] = top_vals[j];\n            top_vals[j] = tmp_v;\n            uint tmp_i = top_idxs[i];\n            top_idxs[i] = top_idxs[j];\n            top_idxs[j] = tmp_i;\n        }\n    }\n}\n\n// Softmax\nfloat max_val = top_vals[0];\nfloat sum = 0.0f;\n#pragma unroll\nfor (uint k = 0; k < K; ++k) {\n    float e = metal::fast::exp(top_vals[k] - max_val);\n    top_vals[k] = e;\n    sum += e;\n}\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(top_vals[tid] * metal::fast::divide(1.0f, sum));\n    indices[out_base + tid] = top_idxs[tid];\n}",
    "gen10_7a4816ad51d5": "constexpr uint D = 64;\nconstexpr uint K = 4;\nconstexpr uint SG = 32;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / SG;\nuint base = row * D;\n\nfloat v0 = (float)inp[base + tid];\nfloat v1 = (float)inp[base + tid + 32];\n\nthread float top_vals[K];\nthread uint top_idxs[K];\nthread float exp_vals[K];\nfloat running_exp_sum = 0.0f;\nfloat global_max = -INFINITY;\n\nfor (uint round = 0; round < K; ++round) {\n    bool masked_0 = false;\n    bool masked_1 = false;\n    #pragma unroll\n    for (uint p = 0; p < round; ++p) {\n        masked_0 = masked_0 || (tid == top_idxs[p]);\n        masked_1 = masked_1 || ((tid + 32) == top_idxs[p]);\n    }\n    \n    float my_max = -INFINITY;\n    uint my_idx = 0;\n    \n    if (!masked_0 && v0 > my_max) {\n        my_max = v0;\n        my_idx = tid;\n    }\n    if (!masked_1 && v1 > my_max) {\n        my_max = v1;\n        my_idx = tid + 32;\n    }\n    \n    #pragma unroll\n    for (uint offset = 16; offset > 0; offset >>= 1) {\n        float other_val = simd_shuffle_xor(my_max, offset);\n        uint other_idx = simd_shuffle_xor(my_idx, offset);\n        if (other_val > my_max) {\n            my_max = other_val;\n            my_idx = other_idx;\n        }\n    }\n    \n    top_vals[round] = my_max;\n    top_idxs[round] = my_idx;\n    \n    // Update global max and recompute all exp values\n    if (round == 0) {\n        global_max = my_max;\n    }\n    \n    if (my_max > global_max) {\n        // Rescale previous exp values\n        float scale = metal::fast::exp(global_max - my_max);\n        #pragma unroll\n        for (uint k = 0; k < round; ++k) {\n            exp_vals[k] *= scale;\n        }\n        running_exp_sum *= scale;\n        global_max = my_max;\n    }\n    \n    exp_vals[round] = metal::fast::exp(my_max - global_max);\n    running_exp_sum += exp_vals[round];\n}\n\n// Final normalization\nfloat inv_sum = metal::fast::divide(1.0f, running_exp_sum);\n\nif (tid < K) {\n    uint out_base = row * K;\n    weights[out_base + tid] = (T)(exp_vals[tid] * inv_sum);\n    indices[out_base + tid] = top_idxs[tid];\n}"
  }
}