{
  "schema_version": "1.0",
  "metadata": {
    "session_id": "0cf2e9c745ef4bf4",
    "target_name": "glm_fused_swiglu",
    "llm_backend": "claude-code",
    "device_chip": "Apple M4",
    "device_memory_gb": 36,
    "os_version": "Darwin 25.1.0",
    "started_at": "2026-02-08T12:54:35-0600",
    "updated_at": "2026-02-08T13:00:38-0600",
    "total_steps": 10,
    "total_candidates": 40,
    "total_evaluated": 40,
    "best_reward": 1.2020222632407604,
    "best_speedup": 1.2033753877973112,
    "best_source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 16;\n\n// Prefetch first batch\nfloat g0 = (base_idx < N) ? (float)gate[base_idx] : 0.0f;\nfloat u0 = (base_idx < N) ? (float)up[base_idx] : 0.0f;\n\n#pragma unroll\nfor (uint i = 0; i < 16; i++) {\n    uint idx = base_idx + i;\n    if (idx >= N) return;\n    \n    // Prefetch next iteration\n    uint next_idx = idx + 1;\n    float g_next = (next_idx < N && i < 15) ? (float)gate[next_idx] : 0.0f;\n    float u_next = (next_idx < N && i < 15) ? (float)up[next_idx] : 0.0f;\n    \n    // Compute current\n    float exp_val = metal::exp(-g0);\n    float sig = 1.0f / (1.0f + exp_val);\n    out[idx] = (T)(g0 * sig * u0);\n    \n    // Swap buffers\n    g0 = g_next;\n    u0 = u_next;\n}",
    "baseline_us": 145.458
  },
  "tree_data": {
    "c_puct": 1.0,
    "root": {
      "node_id": "root",
      "candidate": {
        "spec": {
          "name": "kk_fused_swiglu",
          "input_names": [
            "gate",
            "up"
          ],
          "output_names": [
            "out"
          ],
          "source": "\n        constexpr uint N = 1536;\n        uint idx = thread_position_in_grid.x;\n        if (idx >= N) return;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float sig = 1.0f / (1.0f + metal::exp(-g));\n        out[idx] = (T)(g * sig * u);\n    ",
          "header": "",
          "threadgroup": [
            256,
            1,
            1
          ],
          "template_params": [
            [
              "T",
              "float32"
            ]
          ]
        },
        "parent_id": null,
        "generation": 0,
        "llm_reasoning": "baseline"
      },
      "visit_count": 41,
      "max_reward": 1.2020222632407604,
      "prior": 1.0,
      "eval_result": {
        "compiled": true,
        "correct": true,
        "compile_error": null,
        "correctness_error": null,
        "timings_us": [
          151.958,
          131.916,
          127.292,
          135.208,
          138.541,
          209.167,
          258.542,
          164.25,
          163.417,
          188.042,
          222.833,
          149.458,
          161.167,
          145.875,
          140.875,
          161.125,
          161.167,
          150.5,
          157.958,
          145.208
        ],
        "median_us": 157.958,
        "reward": 0.9061675705790875,
        "speedup": 0.9208650400739437
      },
      "children": [
        {
          "node_id": "gen1_691dd8fd480f",
          "candidate": {
            "spec": {
              "name": "kk_glm_fused_swiglu_gen1",
              "input_names": [
                "gate",
                "up"
              ],
              "output_names": [
                "out"
              ],
              "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 4;\nif (idx >= N) return;\n\n// Vectorized load\nfloat4 g4 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 u4 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\n\n// Vectorized SwiGLU computation\nfloat4 sig4 = 1.0f / (1.0f + metal::exp(-g4));\nfloat4 result = g4 * sig4 * u4;\n\n// Vectorized store\nout[idx] = (T)result.x;\nout[idx+1] = (T)result.y;\nout[idx+2] = (T)result.z;\nout[idx+3] = (T)result.w;",
              "header": "",
              "threadgroup": [
                256,
                1,
                1
              ],
              "template_params": [
                [
                  "T",
                  "float32"
                ]
              ]
            },
            "parent_id": "root",
            "generation": 1,
            "llm_reasoning": "Vectorize using float4 loads/stores to process 4 elements per thread, reducing memory transactions and increasing memory bandwidth utilization."
          },
          "visit_count": 9,
          "max_reward": 1.1872878529830195,
          "prior": 0.25,
          "eval_result": {
            "compiled": true,
            "correct": true,
            "compile_error": null,
            "correctness_error": null,
            "timings_us": [
              133.916,
              133.542,
              126.5,
              134.041,
              158.75,
              135.625,
              133.917,
              151.75,
              153.75,
              128.75,
              164.5,
              390.208,
              225.625,
              151.375,
              177.209,
              149.75,
              150.541,
              130.5,
              129.0,
              140.875
            ],
            "median_us": 149.75,
            "reward": 0.9460136926333869,
            "speedup": 0.971338898163606
          },
          "children": [
            {
              "node_id": "gen3_e8f63dda0468",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen3",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 8;\nif (idx >= N) return;\n\n// Load 8 elements as two float4 vectors\nfloat4 g4_0 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 g4_1 = float4(gate[idx+4], gate[idx+5], gate[idx+6], gate[idx+7]);\nfloat4 u4_0 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat4 u4_1 = float4(up[idx+4], up[idx+5], up[idx+6], up[idx+7]);\n\n// Vectorized sigmoid computation\nfloat4 sig4_0 = 1.0f / (1.0f + metal::exp(-g4_0));\nfloat4 sig4_1 = 1.0f / (1.0f + metal::exp(-g4_1));\n\n// Vectorized SwiGLU\nfloat4 result_0 = g4_0 * sig4_0 * u4_0;\nfloat4 result_1 = g4_1 * sig4_1 * u4_1;\n\n// Store 8 elements\nout[idx] = (T)result_0.x;\nout[idx+1] = (T)result_0.y;\nout[idx+2] = (T)result_0.z;\nout[idx+3] = (T)result_0.w;\nout[idx+4] = (T)result_1.x;\nout[idx+5] = (T)result_1.y;\nout[idx+6] = (T)result_1.z;\nout[idx+7] = (T)result_1.w;",
                  "header": "",
                  "threadgroup": [
                    256,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_691dd8fd480f",
                "generation": 3,
                "llm_reasoning": "Use float8 vectorization (process 8 elements per thread as packed vectors) to maximize memory bandwidth and reduce instruction count compared to float4."
              },
              "visit_count": 1,
              "max_reward": 0.9013334750442283,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  154.416,
                  146.209,
                  162.167,
                  164.833,
                  157.875,
                  188.834,
                  274.875,
                  151.959,
                  149.625,
                  147.791,
                  150.167,
                  157.292,
                  169.084,
                  158.083,
                  151.0,
                  157.25,
                  155.75,
                  158.75,
                  152.208,
                  153.125
                ],
                "median_us": 157.25,
                "reward": 0.9013334750442283,
                "speedup": 0.9250111287758347
              },
              "children": []
            },
            {
              "node_id": "gen3_51d6f39bb155",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen3",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 4;\nif (idx >= N) return;\n\n// Coefficients for polynomial sigmoid approximation\nconstexpr float a = 0.1875f;\nconstexpr float b = -0.0390625f;\nconstexpr float c = 0.00537109375f;\n\n// Vectorized load\nfloat4 g4 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 u4 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\n\n// Polynomial sigmoid: clamp input for stability\nfloat4 x = metal::clamp(g4, -4.0f, 4.0f);\nfloat4 x2 = x * x;\nfloat4 sig4 = 0.5f + x * (a + x2 * (b + x2 * c));\n\n// SwiGLU computation\nfloat4 result = g4 * sig4 * u4;\n\n// Vectorized store\nout[idx] = (T)result.x;\nout[idx+1] = (T)result.y;\nout[idx+2] = (T)result.z;\nout[idx+3] = (T)result.w;",
                  "header": "",
                  "threadgroup": [
                    256,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_691dd8fd480f",
                "generation": 3,
                "llm_reasoning": "Use a 5th-degree polynomial approximation for sigmoid (\u03c3(x) \u2248 0.5 + x*(a + x\u00b2*(b + x\u00b2*c))) to replace expensive exp() with polynomial evaluation."
              },
              "visit_count": 1,
              "max_reward": 0.0,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": false,
                "compile_error": null,
                "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 1447 / 1536 (94.2%)\nFirst 5 mismatches are at indices:\n [0]: -0.07165591418743134 (ACTUAL), -0.06948916614055634 (DESIRED)\n [1]: -0.045300066471099854 (ACTUAL), -0.044312771409749985 (DESIRED)\n [2]: 0.2742772400379181 (ACTUAL), 0.2393781691789627 (DESIRED)\n [3]: -0.02352854423224926 (ACTUAL), -0.0236652884632349 (DESIRED)\n [4]: 0.7272408604621887 (ACTUAL), 0.7961243987083435 (DESIRED)\nMax absolute difference among violations: 13.528284\nMax relative difference among violations: 151.66692\n ACTUAL: array([-0.071656, -0.0453  ,  0.274277, ...,  0.311638,  0.273327,\n       -0.610735], shape=(1536,), dtype=float32)\n DESIRED: array([-0.069489, -0.044313,  0.239378, ...,  0.185042,  0.173579,\n       -0.6558  ], shape=(1536,), dtype=float32)",
                "timings_us": [],
                "median_us": Infinity,
                "reward": 0.0,
                "speedup": 0.0
              },
              "children": []
            },
            {
              "node_id": "gen3_6a2852131e90",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen3",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 8;\nif (idx >= N) return;\n\n// Process 4 pairs (8 elements total) with explicit unrolling\nfloat2 g0 = float2(gate[idx], gate[idx+1]);\nfloat2 g1 = float2(gate[idx+2], gate[idx+3]);\nfloat2 g2 = float2(gate[idx+4], gate[idx+5]);\nfloat2 g3 = float2(gate[idx+6], gate[idx+7]);\n\nfloat2 u0 = float2(up[idx], up[idx+1]);\nfloat2 u1 = float2(up[idx+2], up[idx+3]);\nfloat2 u2 = float2(up[idx+4], up[idx+5]);\nfloat2 u3 = float2(up[idx+6], up[idx+7]);\n\n// Compute sigmoid for all pairs\nfloat2 sig0 = 1.0f / (1.0f + metal::exp(-g0));\nfloat2 sig1 = 1.0f / (1.0f + metal::exp(-g1));\nfloat2 sig2 = 1.0f / (1.0f + metal::exp(-g2));\nfloat2 sig3 = 1.0f / (1.0f + metal::exp(-g3));\n\n// SwiGLU computation\nfloat2 r0 = g0 * sig0 * u0;\nfloat2 r1 = g1 * sig1 * u1;\nfloat2 r2 = g2 * sig2 * u2;\nfloat2 r3 = g3 * sig3 * u3;\n\n// Store results\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y;\nout[idx+2] = (T)r1.x; out[idx+3] = (T)r1.y;\nout[idx+4] = (T)r2.x; out[idx+5] = (T)r2.y;\nout[idx+6] = (T)r3.x; out[idx+7] = (T)r3.y;",
                  "header": "",
                  "threadgroup": [
                    256,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_691dd8fd480f",
                "generation": 3,
                "llm_reasoning": "Combine float2 vectorization with 4-way loop unrolling (8 elements total per thread) to balance register usage and instruction-level parallelism."
              },
              "visit_count": 5,
              "max_reward": 1.1872878529830195,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  127.875,
                  134.208,
                  129.666,
                  122.583,
                  118.417,
                  117.875,
                  117.875,
                  119.166,
                  117.125,
                  116.5,
                  118.583,
                  117.875,
                  116.583,
                  117.208,
                  117.375,
                  116.208,
                  117.709,
                  134.75,
                  148.25,
                  129.791
                ],
                "median_us": 118.417,
                "reward": 1.1872878529830195,
                "speedup": 1.2283540370048218
              },
              "children": [
                {
                  "node_id": "gen7_f7fda877a68e",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen7",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 12;\nif (idx >= N) return;\n\n// Load 6 pairs (12 elements total)\nfloat2 g0 = float2(gate[idx], gate[idx+1]);\nfloat2 g1 = float2(gate[idx+2], gate[idx+3]);\nfloat2 g2 = float2(gate[idx+4], gate[idx+5]);\nfloat2 g3 = float2(gate[idx+6], gate[idx+7]);\nfloat2 g4 = float2(gate[idx+8], gate[idx+9]);\nfloat2 g5 = float2(gate[idx+10], gate[idx+11]);\n\nfloat2 u0 = float2(up[idx], up[idx+1]);\nfloat2 u1 = float2(up[idx+2], up[idx+3]);\nfloat2 u2 = float2(up[idx+4], up[idx+5]);\nfloat2 u3 = float2(up[idx+6], up[idx+7]);\nfloat2 u4 = float2(up[idx+8], up[idx+9]);\nfloat2 u5 = float2(up[idx+10], up[idx+11]);\n\n// Compute sigmoid for all pairs\nfloat2 sig0 = 1.0f / (1.0f + metal::exp(-g0));\nfloat2 sig1 = 1.0f / (1.0f + metal::exp(-g1));\nfloat2 sig2 = 1.0f / (1.0f + metal::exp(-g2));\nfloat2 sig3 = 1.0f / (1.0f + metal::exp(-g3));\nfloat2 sig4 = 1.0f / (1.0f + metal::exp(-g4));\nfloat2 sig5 = 1.0f / (1.0f + metal::exp(-g5));\n\n// SwiGLU computation\nfloat2 r0 = g0 * sig0 * u0;\nfloat2 r1 = g1 * sig1 * u1;\nfloat2 r2 = g2 * sig2 * u2;\nfloat2 r3 = g3 * sig3 * u3;\nfloat2 r4 = g4 * sig4 * u4;\nfloat2 r5 = g5 * sig5 * u5;\n\n// Store results\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y;\nout[idx+2] = (T)r1.x; out[idx+3] = (T)r1.y;\nout[idx+4] = (T)r2.x; out[idx+5] = (T)r2.y;\nout[idx+6] = (T)r3.x; out[idx+7] = (T)r3.y;\nout[idx+8] = (T)r4.x; out[idx+9] = (T)r4.y;\nout[idx+10] = (T)r5.x; out[idx+11] = (T)r5.y;",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen3_6a2852131e90",
                    "generation": 7,
                    "llm_reasoning": "Use float2 with 6-way unrolling (12 elements per thread) to find sweet spot between current best 8-element and slower 16-element variants, balancing ILP and register pressure."
                  },
                  "visit_count": 1,
                  "max_reward": 1.0563616075968345,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      144.292,
                      142.291,
                      141.375,
                      143.0,
                      138.5,
                      128.5,
                      120.334,
                      123.583,
                      124.584,
                      125.083,
                      186.625,
                      147.333,
                      131.833,
                      138.333,
                      112.542,
                      131.791,
                      127.208,
                      163.792,
                      138.583,
                      163.333
                    ],
                    "median_us": 138.5,
                    "reward": 1.0563616075968345,
                    "speedup": 1.0502382671480144
                  },
                  "children": []
                },
                {
                  "node_id": "gen7_95f040ff2f4c",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen7",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 10;\nif (idx >= N) return;\n\n// Prefetch first batch\nfloat g0 = gate[idx];\nfloat g1 = gate[idx+1];\nfloat u0 = up[idx];\nfloat u1 = up[idx+1];\n\n// Load and compute in batches\nfloat g2 = gate[idx+2];\nfloat g3 = gate[idx+3];\nfloat sig0 = 1.0f / (1.0f + metal::exp(-g0));\nfloat sig1 = 1.0f / (1.0f + metal::exp(-g1));\n\nfloat u2 = up[idx+2];\nfloat u3 = up[idx+3];\nfloat r0 = g0 * sig0 * u0;\nfloat r1 = g1 * sig1 * u1;\n\nfloat g4 = gate[idx+4];\nfloat g5 = gate[idx+5];\nfloat sig2 = 1.0f / (1.0f + metal::exp(-g2));\nfloat sig3 = 1.0f / (1.0f + metal::exp(-g3));\n\nfloat u4 = up[idx+4];\nfloat u5 = up[idx+5];\nfloat r2 = g2 * sig2 * u2;\nfloat r3 = g3 * sig3 * u3;\n\nfloat g6 = gate[idx+6];\nfloat g7 = gate[idx+7];\nfloat sig4 = 1.0f / (1.0f + metal::exp(-g4));\nfloat sig5 = 1.0f / (1.0f + metal::exp(-g5));\n\nfloat u6 = up[idx+6];\nfloat u7 = up[idx+7];\nfloat r4 = g4 * sig4 * u4;\nfloat r5 = g5 * sig5 * u5;\n\nfloat g8 = gate[idx+8];\nfloat g9 = gate[idx+9];\nfloat sig6 = 1.0f / (1.0f + metal::exp(-g6));\nfloat sig7 = 1.0f / (1.0f + metal::exp(-g7));\n\nfloat u8 = up[idx+8];\nfloat u9 = up[idx+9];\nfloat r6 = g6 * sig6 * u6;\nfloat r7 = g7 * sig7 * u7;\n\nfloat sig8 = 1.0f / (1.0f + metal::exp(-g8));\nfloat sig9 = 1.0f / (1.0f + metal::exp(-g9));\nfloat r8 = g8 * sig8 * u8;\nfloat r9 = g9 * sig9 * u9;\n\n// Store all results\nout[idx] = (T)r0; out[idx+1] = (T)r1;\nout[idx+2] = (T)r2; out[idx+3] = (T)r3;\nout[idx+4] = (T)r4; out[idx+5] = (T)r5;\nout[idx+6] = (T)r6; out[idx+7] = (T)r7;\nout[idx+8] = (T)r8; out[idx+9] = (T)r9;",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen3_6a2852131e90",
                    "generation": 7,
                    "llm_reasoning": "Use 10 elements per thread with aggressive prefetching to overlap memory access with computation, targeting untried middle ground between 8 and 12 elements."
                  },
                  "visit_count": 1,
                  "max_reward": 0.8672217771416287,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      148.916,
                      146.541,
                      146.542,
                      147.708,
                      215.291,
                      433.125,
                      238.833,
                      206.291,
                      154.209,
                      149.791,
                      156.333,
                      176.459,
                      157.292,
                      157.625,
                      145.834,
                      149.584,
                      149.75,
                      142.167,
                      138.208,
                      141.125
                    ],
                    "median_us": 149.791,
                    "reward": 0.8672217771416287,
                    "speedup": 0.971073028419598
                  },
                  "children": []
                },
                {
                  "node_id": "gen7_a29816f2305f",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen7",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 6;\nif (idx >= N) return;\n\n// Load float4 + float2\nfloat4 g_vec4 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat2 g_vec2 = float2(gate[idx+4], gate[idx+5]);\n\nfloat4 u_vec4 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat2 u_vec2 = float2(up[idx+4], up[idx+5]);\n\n// Compute sigmoid for float4\nfloat4 sig_vec4 = 1.0f / (1.0f + metal::exp(-g_vec4));\n\n// Compute sigmoid for float2\nfloat2 sig_vec2 = 1.0f / (1.0f + metal::exp(-g_vec2));\n\n// SwiGLU computation\nfloat4 r_vec4 = g_vec4 * sig_vec4 * u_vec4;\nfloat2 r_vec2 = g_vec2 * sig_vec2 * u_vec2;\n\n// Store results\nout[idx] = (T)r_vec4.x;\nout[idx+1] = (T)r_vec4.y;\nout[idx+2] = (T)r_vec4.z;\nout[idx+3] = (T)r_vec4.w;\nout[idx+4] = (T)r_vec2.x;\nout[idx+5] = (T)r_vec2.y;",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen3_6a2852131e90",
                    "generation": 7,
                    "llm_reasoning": "Combine float4 and float2 vectorization (6 elements total) to exploit different alignment patterns and maximize memory throughput without excessive register pressure."
                  },
                  "visit_count": 1,
                  "max_reward": 1.067812947612839,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      134.083,
                      127.458,
                      120.208,
                      135.625,
                      143.292,
                      135.833,
                      134.584,
                      138.5,
                      150.916,
                      150.375,
                      148.834,
                      146.75,
                      130.833,
                      122.958,
                      126.375,
                      120.625,
                      122.833,
                      124.5,
                      179.709,
                      143.333
                    ],
                    "median_us": 135.625,
                    "reward": 1.067812947612839,
                    "speedup": 1.0725013824884793
                  },
                  "children": []
                },
                {
                  "node_id": "gen7_1f8d5ea4250d",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen7",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 8;\nif (idx >= N) return;\n\n// Process 4 pairs (8 elements total) with explicit unrolling\nfloat2 g0 = float2(gate[idx], gate[idx+1]);\nfloat2 g1 = float2(gate[idx+2], gate[idx+3]);\nfloat2 g2 = float2(gate[idx+4], gate[idx+5]);\nfloat2 g3 = float2(gate[idx+6], gate[idx+7]);\n\nfloat2 u0 = float2(up[idx], up[idx+1]);\nfloat2 u1 = float2(up[idx+2], up[idx+3]);\nfloat2 u2 = float2(up[idx+4], up[idx+5]);\nfloat2 u3 = float2(up[idx+6], up[idx+7]);\n\n// Compute sigmoid using fast approximation\nfloat2 sig0 = 1.0f / (1.0f + metal::fast::exp(-g0));\nfloat2 sig1 = 1.0f / (1.0f + metal::fast::exp(-g1));\nfloat2 sig2 = 1.0f / (1.0f + metal::fast::exp(-g2));\nfloat2 sig3 = 1.0f / (1.0f + metal::fast::exp(-g3));\n\n// SwiGLU computation\nfloat2 r0 = g0 * sig0 * u0;\nfloat2 r1 = g1 * sig1 * u1;\nfloat2 r2 = g2 * sig2 * u2;\nfloat2 r3 = g3 * sig3 * u3;\n\n// Store results\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y;\nout[idx+2] = (T)r1.x; out[idx+3] = (T)r1.y;\nout[idx+4] = (T)r2.x; out[idx+5] = (T)r2.y;\nout[idx+6] = (T)r3.x; out[idx+7] = (T)r3.y;",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen3_6a2852131e90",
                    "generation": 7,
                    "llm_reasoning": "Use metal::fast::exp approximation with float2 and 4-way unrolling to reduce exp computation cost while maintaining vectorization benefits from current best approach."
                  },
                  "visit_count": 1,
                  "max_reward": 1.08322976770206,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      165.042,
                      146.25,
                      133.542,
                      150.667,
                      144.792,
                      140.291,
                      137.583,
                      119.875,
                      116.5,
                      116.959,
                      121.583,
                      119.917,
                      133.708,
                      183.5,
                      118.5,
                      128.041,
                      184.0,
                      128.0,
                      107.708,
                      119.041
                    ],
                    "median_us": 133.542,
                    "reward": 1.08322976770206,
                    "speedup": 1.0892303544952149
                  },
                  "children": []
                }
              ]
            },
            {
              "node_id": "gen3_6bb165b34655",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen3",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 4;\nif (idx >= N) return;\n\n// Load first pair\nfloat g0 = gate[idx];\nfloat u0 = up[idx];\n\n// Load second pair while computing first\nfloat g1 = gate[idx+1];\nfloat sig0 = 1.0f / (1.0f + metal::exp(-g0));\nfloat u1 = up[idx+1];\nfloat r0 = g0 * sig0 * u0;\n\n// Load third pair while computing second\nfloat g2 = gate[idx+2];\nfloat sig1 = 1.0f / (1.0f + metal::exp(-g1));\nfloat u2 = up[idx+2];\nfloat r1 = g1 * sig1 * u1;\n\n// Load fourth pair while computing third\nfloat g3 = gate[idx+3];\nfloat sig2 = 1.0f / (1.0f + metal::exp(-g2));\nfloat u3 = up[idx+3];\nfloat r2 = g2 * sig2 * u2;\n\n// Compute fourth while storing first\nout[idx] = (T)r0;\nfloat sig3 = 1.0f / (1.0f + metal::exp(-g3));\nout[idx+1] = (T)r1;\nfloat r3 = g3 * sig3 * u3;\n\n// Store remaining results\nout[idx+2] = (T)r2;\nout[idx+3] = (T)r3;",
                  "header": "",
                  "threadgroup": [
                    256,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_691dd8fd480f",
                "generation": 3,
                "llm_reasoning": "Interleave loads, computation, and stores to hide memory latency by allowing the GPU to overlap memory operations with arithmetic."
              },
              "visit_count": 1,
              "max_reward": 0.9958174123600306,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  152.959,
                  152.833,
                  149.167,
                  148.375,
                  150.959,
                  156.0,
                  194.584,
                  153.791,
                  170.167,
                  156.208,
                  163.416,
                  148.541,
                  145.792,
                  129.625,
                  122.833,
                  127.708,
                  125.542,
                  122.667,
                  132.458,
                  137.417
                ],
                "median_us": 149.167,
                "reward": 0.9958174123600306,
                "speedup": 0.9751352510944109
              },
              "children": []
            }
          ]
        },
        {
          "node_id": "gen1_caf19c818f11",
          "candidate": {
            "spec": {
              "name": "kk_glm_fused_swiglu_gen1",
              "input_names": [
                "gate",
                "up"
              ],
              "output_names": [
                "out"
              ],
              "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 2;\nif (idx >= N) return;\n\n// Load two elements per thread\nfloat g0 = (float)gate[idx];\nfloat u0 = (float)up[idx];\nfloat g1 = (idx + 1 < N) ? (float)gate[idx+1] : 0.0f;\nfloat u1 = (idx + 1 < N) ? (float)up[idx+1] : 0.0f;\n\n// Compute sigmoid for both elements (interleaved for ILP)\nfloat exp0 = metal::exp(-g0);\nfloat exp1 = metal::exp(-g1);\nfloat sig0 = 1.0f / (1.0f + exp0);\nfloat sig1 = 1.0f / (1.0f + exp1);\n\n// Compute outputs\nfloat result0 = g0 * sig0 * u0;\nfloat result1 = g1 * sig1 * u1;\n\n// Store results\nout[idx] = (T)result0;\nif (idx + 1 < N) {\n    out[idx+1] = (T)result1;\n}",
              "header": "",
              "threadgroup": [
                256,
                1,
                1
              ],
              "template_params": [
                [
                  "T",
                  "float32"
                ]
              ]
            },
            "parent_id": "root",
            "generation": 1,
            "llm_reasoning": "Use SIMD-level parallelism with manual unrolling to increase instruction-level parallelism and hide latency of exp operations."
          },
          "visit_count": 9,
          "max_reward": 1.1457125806080972,
          "prior": 0.25,
          "eval_result": {
            "compiled": true,
            "correct": true,
            "compile_error": null,
            "correctness_error": null,
            "timings_us": [
              129.083,
              122.917,
              119.917,
              120.042,
              120.167,
              138.375,
              141.583,
              191.583,
              136.417,
              125.083,
              128.333,
              120.375,
              122.959,
              120.625,
              120.0,
              120.125,
              118.917,
              118.75,
              122.875,
              117.5
            ],
            "median_us": 122.875,
            "reward": 1.1457125806080972,
            "speedup": 1.1837884028484231
          },
          "children": [
            {
              "node_id": "gen2_6f0ba48228ce",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen2",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 8;\nif (idx >= N) return;\n\n// Load 2x float4 = 8 elements per thread\nfloat4 g0 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 u0 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat4 g1 = (idx + 4 < N) ? float4(gate[idx+4], gate[idx+5], gate[idx+6], gate[idx+7]) : float4(0.0f);\nfloat4 u1 = (idx + 4 < N) ? float4(up[idx+4], up[idx+5], up[idx+6], up[idx+7]) : float4(0.0f);\n\n// Compute sigmoid for all 8 elements with interleaved operations\nfloat4 exp0 = metal::exp(-g0);\nfloat4 exp1 = metal::exp(-g1);\nfloat4 sig0 = 1.0f / (1.0f + exp0);\nfloat4 sig1 = 1.0f / (1.0f + exp1);\n\n// Compute SwiGLU outputs\nfloat4 result0 = g0 * sig0 * u0;\nfloat4 result1 = g1 * sig1 * u1;\n\n// Store all 8 results\nout[idx] = (T)result0.x;\nout[idx+1] = (T)result0.y;\nout[idx+2] = (T)result0.z;\nout[idx+3] = (T)result0.w;\nif (idx + 4 < N) {\n    out[idx+4] = (T)result1.x;\n    out[idx+5] = (T)result1.y;\n    out[idx+6] = (T)result1.z;\n    out[idx+7] = (T)result1.w;\n}",
                  "header": "",
                  "threadgroup": [
                    256,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_caf19c818f11",
                "generation": 2,
                "llm_reasoning": "Use float4 vectorization with manual unrolling to process 8 elements per thread (2 vector loads/stores), maximizing memory bandwidth while maintaining ILP."
              },
              "visit_count": 5,
              "max_reward": 1.1061938332766164,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  537.292,
                  611.208,
                  160.583,
                  129.417,
                  116.292,
                  121.375,
                  122.208,
                  121.416,
                  117.917,
                  147.541,
                  117.083,
                  122.791,
                  157.75,
                  141.5,
                  133.042,
                  124.084,
                  117.417,
                  124.25,
                  120.25,
                  118.625
                ],
                "median_us": 124.084,
                "reward": 0.9791222876611623,
                "speedup": 1.1722542793591437
              },
              "children": [
                {
                  "node_id": "gen8_4817124436f8",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen8",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 12;\nif (idx >= N) return;\n\n// Load 3x float4 = 12 elements with sequential pattern\nfloat4 g0 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 g1 = float4(gate[idx+4], gate[idx+5], gate[idx+6], gate[idx+7]);\nfloat4 g2 = (idx + 8 < N) ? float4(gate[idx+8], gate[idx+9], gate[idx+10], gate[idx+11]) : float4(0.0f);\n\nfloat4 u0 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat4 u1 = float4(up[idx+4], up[idx+5], up[idx+6], up[idx+7]);\nfloat4 u2 = (idx + 8 < N) ? float4(up[idx+8], up[idx+9], up[idx+10], up[idx+11]) : float4(0.0f);\n\n// Interleave exp computations to hide latency\nfloat4 exp0 = metal::exp(-g0);\nfloat4 exp1 = metal::exp(-g1);\nfloat4 sig0 = 1.0f / (1.0f + exp0);\nfloat4 exp2 = metal::exp(-g2);\nfloat4 sig1 = 1.0f / (1.0f + exp1);\nfloat4 sig2 = 1.0f / (1.0f + exp2);\n\n// Compute results with interleaved multiplies\nfloat4 r0 = g0 * sig0;\nr0 = r0 * u0;\nfloat4 r1 = g1 * sig1;\nr1 = r1 * u1;\nfloat4 r2 = g2 * sig2;\nr2 = r2 * u2;\n\n// Sequential stores for coalesced writes\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y; out[idx+2] = (T)r0.z; out[idx+3] = (T)r0.w;\nout[idx+4] = (T)r1.x; out[idx+5] = (T)r1.y; out[idx+6] = (T)r1.z; out[idx+7] = (T)r1.w;\nif (idx + 8 < N) {\n    out[idx+8] = (T)r2.x; out[idx+9] = (T)r2.y; out[idx+10] = (T)r2.z; out[idx+11] = (T)r2.w;\n}",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen2_6f0ba48228ce",
                    "generation": 8,
                    "llm_reasoning": "Use 3x float4 loads (12 elements/thread) with carefully scheduled operations to balance ILP and memory bandwidth, avoiding the register pressure of 16-element variants."
                  },
                  "visit_count": 1,
                  "max_reward": 1.0107425534016379,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      172.834,
                      140.042,
                      128.5,
                      258.209,
                      130.5,
                      130.708,
                      131.041,
                      128.583,
                      138.5,
                      129.0,
                      123.375,
                      203.417,
                      137.334,
                      131.417,
                      126.959,
                      128.875,
                      174.125,
                      157.041,
                      130.833,
                      132.791
                    ],
                    "median_us": 131.417,
                    "reward": 1.0107425534016379,
                    "speedup": 1.1068431024905454
                  },
                  "children": []
                },
                {
                  "node_id": "gen8_e5c3ac1e723b",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen8",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 16;\nif (idx >= N) return;\n\n// Phase 1: Process first 8 elements\nfloat4 g0 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 g1 = float4(gate[idx+4], gate[idx+5], gate[idx+6], gate[idx+7]);\nfloat4 u0 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat4 u1 = float4(up[idx+4], up[idx+5], up[idx+6], up[idx+7]);\n\nfloat4 sig0 = 1.0f / (1.0f + metal::exp(-g0));\nfloat4 sig1 = 1.0f / (1.0f + metal::exp(-g1));\nfloat4 r0 = g0 * sig0 * u0;\nfloat4 r1 = g1 * sig1 * u1;\n\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y; out[idx+2] = (T)r0.z; out[idx+3] = (T)r0.w;\nout[idx+4] = (T)r1.x; out[idx+5] = (T)r1.y; out[idx+6] = (T)r1.z; out[idx+7] = (T)r1.w;\n\n// Phase 2: Reuse registers for second 8 elements\nif (idx + 8 < N) {\n    g0 = float4(gate[idx+8], gate[idx+9], gate[idx+10], gate[idx+11]);\n    g1 = (idx + 12 < N) ? float4(gate[idx+12], gate[idx+13], gate[idx+14], gate[idx+15]) : float4(0.0f);\n    u0 = float4(up[idx+8], up[idx+9], up[idx+10], up[idx+11]);\n    u1 = (idx + 12 < N) ? float4(up[idx+12], up[idx+13], up[idx+14], up[idx+15]) : float4(0.0f);\n    \n    sig0 = 1.0f / (1.0f + metal::exp(-g0));\n    sig1 = 1.0f / (1.0f + metal::exp(-g1));\n    r0 = g0 * sig0 * u0;\n    r1 = g1 * sig1 * u1;\n    \n    out[idx+8] = (T)r0.x; out[idx+9] = (T)r0.y; out[idx+10] = (T)r0.z; out[idx+11] = (T)r0.w;\n    if (idx + 12 < N) {\n        out[idx+12] = (T)r1.x; out[idx+13] = (T)r1.y; out[idx+14] = (T)r1.z; out[idx+15] = (T)r1.w;\n    }\n}",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen2_6f0ba48228ce",
                    "generation": 8,
                    "llm_reasoning": "Optimize the proven 16-element approach with better register allocation by splitting computation into two phases and reusing registers."
                  },
                  "visit_count": 1,
                  "max_reward": 1.0622770441852751,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      150.125,
                      137.417,
                      125.25,
                      122.75,
                      126.084,
                      122.75,
                      186.708,
                      133.0,
                      188.5,
                      129.5,
                      130.792,
                      181.125,
                      130.667,
                      142.75,
                      148.375,
                      125.083,
                      123.333,
                      125.875,
                      118.75,
                      119.375
                    ],
                    "median_us": 130.667,
                    "reward": 1.0622770441852751,
                    "speedup": 1.1131961398057657
                  },
                  "children": []
                },
                {
                  "node_id": "gen8_15edf4f24d9a",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen8",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 4;\nif (idx >= N) return;\n\n// Single float4 load per array - perfectly coalesced\nfloat4 g = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 u = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\n\n// Compute sigmoid with fused operations\nfloat4 exp_neg = metal::exp(-g);\nfloat4 sig = 1.0f / (1.0f + exp_neg);\n\n// Final result in one step\nfloat4 result = g * sig * u;\n\n// Coalesced stores\nout[idx] = (T)result.x;\nout[idx+1] = (T)result.y;\nout[idx+2] = (T)result.z;\nout[idx+3] = (T)result.w;",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen2_6f0ba48228ce",
                    "generation": 8,
                    "llm_reasoning": "Use single float4 per thread (4 elements) with perfectly coalesced access and minimal branching to maximize memory throughput."
                  },
                  "visit_count": 1,
                  "max_reward": 1.0231787041710658,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      119.458,
                      185.792,
                      127.208,
                      119.0,
                      119.166,
                      120.208,
                      121.833,
                      120.583,
                      120.333,
                      120.417,
                      123.0,
                      123.625,
                      122.292,
                      120.584,
                      122.875,
                      124.75,
                      119.5,
                      222.125,
                      630.75,
                      192.834
                    ],
                    "median_us": 122.292,
                    "reward": 1.0231787041710658,
                    "speedup": 1.1894318516337945
                  },
                  "children": []
                },
                {
                  "node_id": "gen8_bcd467625989",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen8",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 16;\nif (idx >= N) return;\n\n// Load first batch as vectors\nfloat4 g0 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 u0 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat4 exp0 = metal::exp(-g0);\n\n// Load second batch while first exp completes\nfloat4 g1 = float4(gate[idx+4], gate[idx+5], gate[idx+6], gate[idx+7]);\nfloat4 u1 = float4(up[idx+4], up[idx+5], up[idx+6], up[idx+7]);\nfloat4 sig0 = 1.0f / (1.0f + exp0);\nfloat4 exp1 = metal::exp(-g1);\n\n// Continue pattern for third batch\nfloat4 g2 = (idx+8 < N) ? float4(gate[idx+8], gate[idx+9], gate[idx+10], gate[idx+11]) : float4(0.0f);\nfloat4 u2 = (idx+8 < N) ? float4(up[idx+8], up[idx+9], up[idx+10], up[idx+11]) : float4(0.0f);\nfloat4 r0 = g0 * sig0 * u0;\nfloat4 sig1 = 1.0f / (1.0f + exp1);\nfloat4 exp2 = metal::exp(-g2);\n\n// Fourth batch\nfloat4 g3 = (idx+12 < N) ? float4(gate[idx+12], gate[idx+13], gate[idx+14], gate[idx+15]) : float4(0.0f);\nfloat4 u3 = (idx+12 < N) ? float4(up[idx+12], up[idx+13], up[idx+14], up[idx+15]) : float4(0.0f);\nfloat4 r1 = g1 * sig1 * u1;\nfloat4 sig2 = 1.0f / (1.0f + exp2);\nfloat4 exp3 = metal::exp(-g3);\n\n// Complete computations\nfloat4 r2 = g2 * sig2 * u2;\nfloat4 sig3 = 1.0f / (1.0f + exp3);\nfloat4 r3 = g3 * sig3 * u3;\n\n// Store all results\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y; out[idx+2] = (T)r0.z; out[idx+3] = (T)r0.w;\nout[idx+4] = (T)r1.x; out[idx+5] = (T)r1.y; out[idx+6] = (T)r1.z; out[idx+7] = (T)r1.w;\nif (idx+8 < N) {\n    out[idx+8] = (T)r2.x; out[idx+9] = (T)r2.y; out[idx+10] = (T)r2.z; out[idx+11] = (T)r2.w;\n    if (idx+12 < N) {\n        out[idx+12] = (T)r3.x; out[idx+13] = (T)r3.y; out[idx+14] = (T)r3.z; out[idx+15] = (T)r3.w;\n    }\n}",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen2_6f0ba48228ce",
                    "generation": 8,
                    "llm_reasoning": "Process 16 elements with split scalar/vector pattern to reduce register pressure while maintaining high ILP through alternating computation."
                  },
                  "visit_count": 1,
                  "max_reward": 1.1061938332766164,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      128.167,
                      118.75,
                      123.0,
                      154.0,
                      123.084,
                      126.375,
                      122.125,
                      128.125,
                      119.958,
                      121.667,
                      175.542,
                      146.625,
                      120.709,
                      119.083,
                      125.041,
                      124.75,
                      125.208,
                      205.834,
                      126.458,
                      124.0
                    ],
                    "median_us": 125.041,
                    "reward": 1.1061938332766164,
                    "speedup": 1.1632824433585784
                  },
                  "children": []
                }
              ]
            },
            {
              "node_id": "gen2_f1fb1fc5f353",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen2",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 4;\nif (idx >= N) return;\n\n// Load 4 elements\nfloat g0 = (float)gate[idx];\nfloat u0 = (float)up[idx];\nfloat g1 = (idx + 1 < N) ? (float)gate[idx+1] : 0.0f;\nfloat u1 = (idx + 1 < N) ? (float)up[idx+1] : 0.0f;\nfloat g2 = (idx + 2 < N) ? (float)gate[idx+2] : 0.0f;\nfloat u2 = (idx + 2 < N) ? (float)up[idx+2] : 0.0f;\nfloat g3 = (idx + 3 < N) ? (float)gate[idx+3] : 0.0f;\nfloat u3 = (idx + 3 < N) ? (float)up[idx+3] : 0.0f;\n\n// Compute sigmoid using FMA for better precision\nfloat exp0 = metal::precise::exp(-g0);\nfloat exp1 = metal::precise::exp(-g1);\nfloat exp2 = metal::precise::exp(-g2);\nfloat exp3 = metal::precise::exp(-g3);\n\nfloat sig0 = metal::fma(-exp0, 1.0f / (1.0f + exp0), 1.0f / (1.0f + exp0));\nfloat sig1 = metal::fma(-exp1, 1.0f / (1.0f + exp1), 1.0f / (1.0f + exp1));\nfloat sig2 = metal::fma(-exp2, 1.0f / (1.0f + exp2), 1.0f / (1.0f + exp2));\nfloat sig3 = metal::fma(-exp3, 1.0f / (1.0f + exp3), 1.0f / (1.0f + exp3));\n\n// Compute outputs with FMA\nout[idx] = (T)metal::fma(g0 * sig0, u0, 0.0f);\nif (idx + 1 < N) out[idx+1] = (T)metal::fma(g1 * sig1, u1, 0.0f);\nif (idx + 2 < N) out[idx+2] = (T)metal::fma(g2 * sig2, u2, 0.0f);\nif (idx + 3 < N) out[idx+3] = (T)metal::fma(g3 * sig3, u3, 0.0f);",
                  "header": "",
                  "threadgroup": [
                    384,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_caf19c818f11",
                "generation": 2,
                "llm_reasoning": "Process 4 elements per thread with FMA-optimized sigmoid using precise_exp and explicit FMA instructions to reduce rounding error and instruction count."
              },
              "visit_count": 1,
              "max_reward": 0.0,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": false,
                "compile_error": null,
                "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 1533 / 1536 (99.8%)\nFirst 5 mismatches are at indices:\n [0]: 0.017028309404850006 (ACTUAL), -0.06948916614055634 (DESIRED)\n [1]: 0.007821033708751202 (ACTUAL), -0.044312771409749985 (DESIRED)\n [2]: -0.23834110796451569 (ACTUAL), 0.2393781691789627 (DESIRED)\n [3]: -0.0010930098360404372 (ACTUAL), -0.0236652884632349 (DESIRED)\n [4]: 0.44565340876579285 (ACTUAL), 0.7961243987083435 (DESIRED)\nMax absolute difference among violations: 5.5610614\nMax relative difference among violations: 50.916924\n ACTUAL: array([ 0.017028,  0.007821, -0.238341, ..., -0.633272, -0.51455 ,\n       -0.312975], shape=(1536,), dtype=float32)\n DESIRED: array([-0.069489, -0.044313,  0.239378, ...,  0.185042,  0.173579,\n       -0.6558  ], shape=(1536,), dtype=float32)",
                "timings_us": [],
                "median_us": Infinity,
                "reward": 0.0,
                "speedup": 0.0
              },
              "children": []
            },
            {
              "node_id": "gen2_42838abd9915",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen2",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 2;\nif (idx >= N) return;\n\n// Load two elements per thread\nfloat g0 = (float)gate[idx];\nfloat u0 = (float)up[idx];\nfloat g1 = (idx + 1 < N) ? (float)gate[idx+1] : 0.0f;\nfloat u1 = (idx + 1 < N) ? (float)up[idx+1] : 0.0f;\n\n// Fast sigmoid using tanh approximation\nfloat sig0 = 0.5f + 0.5f * metal::fast::tanh(0.5f * g0);\nfloat sig1 = 0.5f + 0.5f * metal::fast::tanh(0.5f * g1);\n\n// Compute SwiGLU outputs\nfloat result0 = g0 * sig0 * u0;\nfloat result1 = g1 * sig1 * u1;\n\n// Store results\nout[idx] = (T)result0;\nif (idx + 1 < N) {\n    out[idx+1] = (T)result1;\n}",
                  "header": "",
                  "threadgroup": [
                    256,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_caf19c818f11",
                "generation": 2,
                "llm_reasoning": "Use tanh-based sigmoid approximation (\u03c3(x) \u2248 0.5 + 0.5*tanh(0.5*x)) which is faster than exp on Apple GPUs, processing 2 elements per thread."
              },
              "visit_count": 1,
              "max_reward": 0.8494866461020376,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  167.75,
                  146.333,
                  145.541,
                  143.583,
                  140.666,
                  138.375,
                  136.666,
                  137.834,
                  139.5,
                  137.75,
                  135.666,
                  153.584,
                  134.625,
                  174.5,
                  481.083,
                  679.625,
                  187.917,
                  136.25,
                  130.5,
                  242.917
                ],
                "median_us": 143.583,
                "reward": 0.8494866461020376,
                "speedup": 1.0130586490044087
              },
              "children": []
            },
            {
              "node_id": "gen2_fc5d8e517439",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen2",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nconstexpr uint TILE_SIZE = 128;\n\nthreadgroup float s_gate[TILE_SIZE];\nthreadgroup float s_up[TILE_SIZE];\n\nuint tid = thread_position_in_threadgroup.x;\nuint gid = threadgroup_position_in_grid.x;\nuint idx = gid * TILE_SIZE + tid;\n\n// Cooperative load into threadgroup memory\nif (idx < N) {\n    s_gate[tid] = (float)gate[idx];\n    s_up[tid] = (float)up[idx];\n}\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\n// Process from threadgroup memory\nif (idx < N) {\n    float g = s_gate[tid];\n    float u = s_up[tid];\n    \n    // Compute sigmoid\n    float exp_val = metal::exp(-g);\n    float sig = 1.0f / (1.0f + exp_val);\n    \n    // Compute and store result\n    out[idx] = (T)(g * sig * u);\n}",
                  "header": "",
                  "threadgroup": [
                    128,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_caf19c818f11",
                "generation": 2,
                "llm_reasoning": "Tile the computation across threadgroups with threadgroup memory to prefetch and cache data, reducing global memory latency via cooperative loading."
              },
              "visit_count": 1,
              "max_reward": 0.0,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": false,
                "compile_error": null,
                "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 861 / 1536 (56.1%)\nFirst 5 mismatches are at indices:\n [0]: -0.1865844875574112 (ACTUAL), -0.06948916614055634 (DESIRED)\n [1]: -0.1578143686056137 (ACTUAL), -0.044312771409749985 (DESIRED)\n [2]: -0.9359785318374634 (ACTUAL), 0.2393781691789627 (DESIRED)\n [3]: -0.15469101071357727 (ACTUAL), -0.0236652884632349 (DESIRED)\n [4]: 0.11182951927185059 (ACTUAL), 0.7961243987083435 (DESIRED)\nMax absolute difference among violations: 4.4444056\nMax relative difference among violations: 195.1184\n ACTUAL: array([-0.186584, -0.157814, -0.935979, ...,  0.185042,  0.173579,\n       -0.6558  ], shape=(1536,), dtype=float32)\n DESIRED: array([-0.069489, -0.044313,  0.239378, ...,  0.185042,  0.173579,\n       -0.6558  ], shape=(1536,), dtype=float32)",
                "timings_us": [],
                "median_us": Infinity,
                "reward": 0.0,
                "speedup": 0.0
              },
              "children": []
            }
          ]
        },
        {
          "node_id": "gen1_4509efaa336b",
          "candidate": {
            "spec": {
              "name": "kk_glm_fused_swiglu_gen1",
              "input_names": [
                "gate",
                "up"
              ],
              "output_names": [
                "out"
              ],
              "source": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x;\nif (idx >= N) return;\n\nfloat g = (float)gate[idx];\nfloat u = (float)up[idx];\n\n// Use metal::fast::exp for faster approximation\nfloat neg_g = -g;\nfloat exp_val = metal::fast::exp(neg_g);\nfloat sig = metal::fast::divide(1.0f, 1.0f + exp_val);\n\n// Fused multiply: g * sig * u\nfloat result = g * sig;\nresult = result * u;\n\nout[idx] = (T)result;",
              "header": "",
              "threadgroup": [
                256,
                1,
                1
              ],
              "template_params": [
                [
                  "T",
                  "float32"
                ]
              ]
            },
            "parent_id": "root",
            "generation": 1,
            "llm_reasoning": "Optimize sigmoid computation using fast_exp approximation and fused multiply-add to reduce instruction count and improve throughput."
          },
          "visit_count": 9,
          "max_reward": 1.131089710662879,
          "prior": 0.25,
          "eval_result": {
            "compiled": true,
            "correct": true,
            "compile_error": null,
            "correctness_error": null,
            "timings_us": [
              233.708,
              150.834,
              146.333,
              172.5,
              151.167,
              150.25,
              142.167,
              165.667,
              378.5,
              244.375,
              176.25,
              128.25,
              135.709,
              135.875,
              135.541,
              131.542,
              137.792,
              137.292,
              139.125,
              134.458
            ],
            "median_us": 146.333,
            "reward": 0.9110755881170277,
            "speedup": 0.9940204875181948
          },
          "children": [
            {
              "node_id": "gen5_c9e0f5899d32",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen5",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 16;\n\n// Prefetch all 16 gate values into registers\nfloat g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15;\nfloat u0, u1, u2, u3, u4, u5, u6, u7, u8, u9, u10, u11, u12, u13, u14, u15;\n\nif (base_idx < N) { g0 = (float)gate[base_idx]; u0 = (float)up[base_idx]; }\nif (base_idx + 1 < N) { g1 = (float)gate[base_idx + 1]; u1 = (float)up[base_idx + 1]; }\nif (base_idx + 2 < N) { g2 = (float)gate[base_idx + 2]; u2 = (float)up[base_idx + 2]; }\nif (base_idx + 3 < N) { g3 = (float)gate[base_idx + 3]; u3 = (float)up[base_idx + 3]; }\nif (base_idx + 4 < N) { g4 = (float)gate[base_idx + 4]; u4 = (float)up[base_idx + 4]; }\nif (base_idx + 5 < N) { g5 = (float)gate[base_idx + 5]; u5 = (float)up[base_idx + 5]; }\nif (base_idx + 6 < N) { g6 = (float)gate[base_idx + 6]; u6 = (float)up[base_idx + 6]; }\nif (base_idx + 7 < N) { g7 = (float)gate[base_idx + 7]; u7 = (float)up[base_idx + 7]; }\nif (base_idx + 8 < N) { g8 = (float)gate[base_idx + 8]; u8 = (float)up[base_idx + 8]; }\nif (base_idx + 9 < N) { g9 = (float)gate[base_idx + 9]; u9 = (float)up[base_idx + 9]; }\nif (base_idx + 10 < N) { g10 = (float)gate[base_idx + 10]; u10 = (float)up[base_idx + 10]; }\nif (base_idx + 11 < N) { g11 = (float)gate[base_idx + 11]; u11 = (float)up[base_idx + 11]; }\nif (base_idx + 12 < N) { g12 = (float)gate[base_idx + 12]; u12 = (float)up[base_idx + 12]; }\nif (base_idx + 13 < N) { g13 = (float)gate[base_idx + 13]; u13 = (float)up[base_idx + 13]; }\nif (base_idx + 14 < N) { g14 = (float)gate[base_idx + 14]; u14 = (float)up[base_idx + 14]; }\nif (base_idx + 15 < N) { g15 = (float)gate[base_idx + 15]; u15 = (float)up[base_idx + 15]; }\n\n// Compute all sigmoids with fast_exp and fused operations\nfloat s0 = g0 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g0));\nfloat s1 = g1 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g1));\nfloat s2 = g2 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g2));\nfloat s3 = g3 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g3));\nfloat s4 = g4 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g4));\nfloat s5 = g5 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g5));\nfloat s6 = g6 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g6));\nfloat s7 = g7 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g7));\nfloat s8 = g8 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g8));\nfloat s9 = g9 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g9));\nfloat s10 = g10 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g10));\nfloat s11 = g11 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g11));\nfloat s12 = g12 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g12));\nfloat s13 = g13 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g13));\nfloat s14 = g14 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g14));\nfloat s15 = g15 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g15));\n\n// Final multiply with up values and write out\nif (base_idx < N) out[base_idx] = (T)(s0 * u0);\nif (base_idx + 1 < N) out[base_idx + 1] = (T)(s1 * u1);\nif (base_idx + 2 < N) out[base_idx + 2] = (T)(s2 * u2);\nif (base_idx + 3 < N) out[base_idx + 3] = (T)(s3 * u3);\nif (base_idx + 4 < N) out[base_idx + 4] = (T)(s4 * u4);\nif (base_idx + 5 < N) out[base_idx + 5] = (T)(s5 * u5);\nif (base_idx + 6 < N) out[base_idx + 6] = (T)(s6 * u6);\nif (base_idx + 7 < N) out[base_idx + 7] = (T)(s7 * u7);\nif (base_idx + 8 < N) out[base_idx + 8] = (T)(s8 * u8);\nif (base_idx + 9 < N) out[base_idx + 9] = (T)(s9 * u9);\nif (base_idx + 10 < N) out[base_idx + 10] = (T)(s10 * u10);\nif (base_idx + 11 < N) out[base_idx + 11] = (T)(s11 * u11);\nif (base_idx + 12 < N) out[base_idx + 12] = (T)(s12 * u12);\nif (base_idx + 13 < N) out[base_idx + 13] = (T)(s13 * u13);\nif (base_idx + 14 < N) out[base_idx + 14] = (T)(s14 * u14);\nif (base_idx + 15 < N) out[base_idx + 15] = (T)(s15 * u15);",
                  "header": "",
                  "threadgroup": [
                    256,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_4509efaa336b",
                "generation": 5,
                "llm_reasoning": "Combine the best working strategy (16 elements per thread with aggressive unrolling) with SIMD shuffle operations to share intermediate sigmoid results across SIMD lanes, reducing redundant exp() calls."
              },
              "visit_count": 1,
              "max_reward": 1.0811863603477958,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  169.25,
                  135.417,
                  130.209,
                  124.625,
                  126.291,
                  124.667,
                  123.5,
                  123.791,
                  128.0,
                  123.125,
                  121.875,
                  122.25,
                  122.916,
                  250.125,
                  133.875,
                  124.541,
                  132.458,
                  135.541,
                  135.458,
                  144.0
                ],
                "median_us": 128.0,
                "reward": 1.0811863603477958,
                "speedup": 1.136390625
              },
              "children": []
            },
            {
              "node_id": "gen5_4ee8f74f7f50",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen5",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 12;\n\nif (base_idx + 11 >= N) {\n    // Scalar fallback for remainder\n    for (uint i = 0; i < 12 && base_idx + i < N; i++) {\n        uint idx = base_idx + i;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float sig = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g));\n        out[idx] = (T)(g * sig * u);\n    }\n    return;\n}\n\n// Load 4 float3 vectors (12 elements total)\nfloat3 g0 = float3((float)gate[base_idx], (float)gate[base_idx + 1], (float)gate[base_idx + 2]);\nfloat3 g1 = float3((float)gate[base_idx + 3], (float)gate[base_idx + 4], (float)gate[base_idx + 5]);\nfloat3 g2 = float3((float)gate[base_idx + 6], (float)gate[base_idx + 7], (float)gate[base_idx + 8]);\nfloat3 g3 = float3((float)gate[base_idx + 9], (float)gate[base_idx + 10], (float)gate[base_idx + 11]);\n\nfloat3 u0 = float3((float)up[base_idx], (float)up[base_idx + 1], (float)up[base_idx + 2]);\nfloat3 u1 = float3((float)up[base_idx + 3], (float)up[base_idx + 4], (float)up[base_idx + 5]);\nfloat3 u2 = float3((float)up[base_idx + 6], (float)up[base_idx + 7], (float)up[base_idx + 8]);\nfloat3 u3 = float3((float)up[base_idx + 9], (float)up[base_idx + 10], (float)up[base_idx + 11]);\n\n// Compute sigmoid and fused multiply\nfloat3 sig0 = 1.0f / (1.0f + metal::fast::exp(-g0));\nfloat3 sig1 = 1.0f / (1.0f + metal::fast::exp(-g1));\nfloat3 sig2 = 1.0f / (1.0f + metal::fast::exp(-g2));\nfloat3 sig3 = 1.0f / (1.0f + metal::fast::exp(-g3));\n\nfloat3 r0 = g0 * sig0 * u0;\nfloat3 r1 = g1 * sig1 * u1;\nfloat3 r2 = g2 * sig2 * u2;\nfloat3 r3 = g3 * sig3 * u3;\n\n// Store results\nout[base_idx] = (T)r0.x; out[base_idx + 1] = (T)r0.y; out[base_idx + 2] = (T)r0.z;\nout[base_idx + 3] = (T)r1.x; out[base_idx + 4] = (T)r1.y; out[base_idx + 5] = (T)r1.z;\nout[base_idx + 6] = (T)r2.x; out[base_idx + 7] = (T)r2.y; out[base_idx + 8] = (T)r2.z;\nout[base_idx + 9] = (T)r3.x; out[base_idx + 10] = (T)r3.y; out[base_idx + 11] = (T)r3.z;",
                  "header": "",
                  "threadgroup": [
                    256,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_4509efaa336b",
                "generation": 5,
                "llm_reasoning": "Use float3 vectorization (12 bytes aligned) with 4-way unrolling to process 12 elements per thread, exploiting better cache line utilization than float4 while maintaining coalesced access patterns."
              },
              "visit_count": 1,
              "max_reward": 1.1170019609355053,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  124.875,
                  119.458,
                  123.834,
                  149.541,
                  130.375,
                  135.042,
                  127.833,
                  121.25,
                  125.375,
                  118.958,
                  132.292,
                  118.792,
                  123.541,
                  178.083,
                  130.125,
                  162.458,
                  124.75,
                  126.792,
                  125.333,
                  120.708
                ],
                "median_us": 125.375,
                "reward": 1.1170019609355053,
                "speedup": 1.1601834496510468
              },
              "children": []
            },
            {
              "node_id": "gen5_bcfe4498312f",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen5",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\nif (base_idx >= N) return;\n\n// First batch - load\nfloat g_curr[4], u_curr[4];\ng_curr[0] = (base_idx < N) ? (float)gate[base_idx] : 0.0f;\ng_curr[1] = (base_idx + 1 < N) ? (float)gate[base_idx + 1] : 0.0f;\ng_curr[2] = (base_idx + 2 < N) ? (float)gate[base_idx + 2] : 0.0f;\ng_curr[3] = (base_idx + 3 < N) ? (float)gate[base_idx + 3] : 0.0f;\n\nu_curr[0] = (base_idx < N) ? (float)up[base_idx] : 0.0f;\nu_curr[1] = (base_idx + 1 < N) ? (float)up[base_idx + 1] : 0.0f;\nu_curr[2] = (base_idx + 2 < N) ? (float)up[base_idx + 2] : 0.0f;\nu_curr[3] = (base_idx + 3 < N) ? (float)up[base_idx + 3] : 0.0f;\n\n// Second batch - prefetch while computing first\nfloat g_next[4], u_next[4];\ng_next[0] = (base_idx + 4 < N) ? (float)gate[base_idx + 4] : 0.0f;\ng_next[1] = (base_idx + 5 < N) ? (float)gate[base_idx + 5] : 0.0f;\ng_next[2] = (base_idx + 6 < N) ? (float)gate[base_idx + 6] : 0.0f;\ng_next[3] = (base_idx + 7 < N) ? (float)gate[base_idx + 7] : 0.0f;\n\n// Compute first batch\nfloat r0 = g_curr[0] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_curr[0])) * u_curr[0];\nfloat r1 = g_curr[1] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_curr[1])) * u_curr[1];\nfloat r2 = g_curr[2] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_curr[2])) * u_curr[2];\nfloat r3 = g_curr[3] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_curr[3])) * u_curr[3];\n\n// Load second batch up values while computing\nu_next[0] = (base_idx + 4 < N) ? (float)up[base_idx + 4] : 0.0f;\nu_next[1] = (base_idx + 5 < N) ? (float)up[base_idx + 5] : 0.0f;\nu_next[2] = (base_idx + 6 < N) ? (float)up[base_idx + 6] : 0.0f;\nu_next[3] = (base_idx + 7 < N) ? (float)up[base_idx + 7] : 0.0f;\n\n// Store first batch\nif (base_idx < N) out[base_idx] = (T)r0;\nif (base_idx + 1 < N) out[base_idx + 1] = (T)r1;\nif (base_idx + 2 < N) out[base_idx + 2] = (T)r2;\nif (base_idx + 3 < N) out[base_idx + 3] = (T)r3;\n\n// Compute and store second batch\nif (base_idx + 4 < N) {\n    float r4 = g_next[0] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_next[0])) * u_next[0];\n    out[base_idx + 4] = (T)r4;\n}\nif (base_idx + 5 < N) {\n    float r5 = g_next[1] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_next[1])) * u_next[1];\n    out[base_idx + 5] = (T)r5;\n}\nif (base_idx + 6 < N) {\n    float r6 = g_next[2] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_next[2])) * u_next[2];\n    out[base_idx + 6] = (T)r6;\n}\nif (base_idx + 7 < N) {\n    float r7 = g_next[3] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_next[3])) * u_next[3];\n    out[base_idx + 7] = (T)r7;\n}",
                  "header": "",
                  "threadgroup": [
                    256,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_4509efaa336b",
                "generation": 5,
                "llm_reasoning": "Use a hybrid approach with 8 elements per thread using double-buffering pattern to hide latency: load next batch while computing current batch, alternating between two register sets."
              },
              "visit_count": 1,
              "max_reward": 1.1268507468887532,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  131.417,
                  131.875,
                  134.584,
                  148.709,
                  144.25,
                  156.417,
                  127.125,
                  128.5,
                  131.75,
                  112.291,
                  141.833,
                  117.833,
                  130.125,
                  120.791,
                  125.042,
                  124.792,
                  119.958,
                  120.459,
                  122.0,
                  120.709
                ],
                "median_us": 128.5,
                "reward": 1.1268507468887532,
                "speedup": 1.1319688715953307
              },
              "children": []
            },
            {
              "node_id": "gen5_5a1b14911781",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen5",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\nif (base_idx + 7 >= N) {\n    // Scalar fallback\n    for (uint i = 0; i < 8 && base_idx + i < N; i++) {\n        uint idx = base_idx + i;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float sig = 1.0f / (1.0f + metal::fast::exp(-g));\n        out[idx] = (T)(g * sig * u);\n    }\n    return;\n}\n\n// Load all 8 gate and up values\nfloat g0 = (float)gate[base_idx];\nfloat g1 = (float)gate[base_idx + 1];\nfloat g2 = (float)gate[base_idx + 2];\nfloat g3 = (float)gate[base_idx + 3];\nfloat g4 = (float)gate[base_idx + 4];\nfloat g5 = (float)gate[base_idx + 5];\nfloat g6 = (float)gate[base_idx + 6];\nfloat g7 = (float)gate[base_idx + 7];\n\nfloat u0 = (float)up[base_idx];\nfloat u1 = (float)up[base_idx + 1];\nfloat u2 = (float)up[base_idx + 2];\nfloat u3 = (float)up[base_idx + 3];\nfloat u4 = (float)up[base_idx + 4];\nfloat u5 = (float)up[base_idx + 5];\nfloat u6 = (float)up[base_idx + 6];\nfloat u7 = (float)up[base_idx + 7];\n\n// Compute all exp values in parallel\nfloat e0 = metal::fast::exp(-g0);\nfloat e1 = metal::fast::exp(-g1);\nfloat e2 = metal::fast::exp(-g2);\nfloat e3 = metal::fast::exp(-g3);\nfloat e4 = metal::fast::exp(-g4);\nfloat e5 = metal::fast::exp(-g5);\nfloat e6 = metal::fast::exp(-g6);\nfloat e7 = metal::fast::exp(-g7);\n\n// Compute denominators\nfloat d0 = 1.0f + e0;\nfloat d1 = 1.0f + e1;\nfloat d2 = 1.0f + e2;\nfloat d3 = 1.0f + e3;\nfloat d4 = 1.0f + e4;\nfloat d5 = 1.0f + e5;\nfloat d6 = 1.0f + e6;\nfloat d7 = 1.0f + e7;\n\n// Compute sigmoids using precise divide\nfloat s0 = metal::precise::divide(1.0f, d0);\nfloat s1 = metal::precise::divide(1.0f, d1);\nfloat s2 = metal::precise::divide(1.0f, d2);\nfloat s3 = metal::precise::divide(1.0f, d3);\nfloat s4 = metal::precise::divide(1.0f, d4);\nfloat s5 = metal::precise::divide(1.0f, d5);\nfloat s6 = metal::precise::divide(1.0f, d6);\nfloat s7 = metal::precise::divide(1.0f, d7);\n\n// Fused multiply: g * sig * u\nout[base_idx] = (T)(g0 * s0 * u0);\nout[base_idx + 1] = (T)(g1 * s1 * u1);\nout[base_idx + 2] = (T)(g2 * s2 * u2);\nout[base_idx + 3] = (T)(g3 * s3 * u3);\nout[base_idx + 4] = (T)(g4 * s4 * u4);\nout[base_idx + 5] = (T)(g5 * s5 * u5);\nout[base_idx + 6] = (T)(g6 * s6 * u6);\nout[base_idx + 7] = (T)(g7 * s7 * u7);",
                  "header": "",
                  "threadgroup": [
                    256,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_4509efaa336b",
                "generation": 5,
                "llm_reasoning": "Optimize for instruction-level parallelism by computing 8 sigmoid values in parallel using metal::precise::divide (potentially faster than fast::divide on M4) and restructuring computation to maximize independent operations that can execute simultaneously."
              },
              "visit_count": 5,
              "max_reward": 1.131089710662879,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  206.542,
                  157.458,
                  121.209,
                  130.458,
                  133.875,
                  123.833,
                  124.792,
                  120.625,
                  121.125,
                  121.917,
                  119.042,
                  120.541,
                  122.083,
                  123.417,
                  122.25,
                  122.459,
                  123.333,
                  123.417,
                  122.667,
                  133.625
                ],
                "median_us": 123.333,
                "reward": 1.131089710662879,
                "speedup": 1.1793923767361534
              },
              "children": [
                {
                  "node_id": "gen9_ea6ab2df8bc7",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen9",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\nif (base_idx + 7 >= N) {\n    for (uint i = 0; i < 8 && base_idx + i < N; i++) {\n        uint idx = base_idx + i;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float sig = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g));\n        out[idx] = (T)metal::fma(g * sig, u, 0.0f);\n    }\n    return;\n}\n\nfloat g0 = (float)gate[base_idx];\nfloat g1 = (float)gate[base_idx + 1];\nfloat g2 = (float)gate[base_idx + 2];\nfloat g3 = (float)gate[base_idx + 3];\nfloat g4 = (float)gate[base_idx + 4];\nfloat g5 = (float)gate[base_idx + 5];\nfloat g6 = (float)gate[base_idx + 6];\nfloat g7 = (float)gate[base_idx + 7];\n\nfloat u0 = (float)up[base_idx];\nfloat u1 = (float)up[base_idx + 1];\nfloat u2 = (float)up[base_idx + 2];\nfloat u3 = (float)up[base_idx + 3];\nfloat u4 = (float)up[base_idx + 4];\nfloat u5 = (float)up[base_idx + 5];\nfloat u6 = (float)up[base_idx + 6];\nfloat u7 = (float)up[base_idx + 7];\n\n// Compute reciprocals with fast path\nfloat s0 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g0));\nfloat s1 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g1));\nfloat s2 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g2));\nfloat s3 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g3));\nfloat s4 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g4));\nfloat s5 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g5));\nfloat s6 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g6));\nfloat s7 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g7));\n\n// FMA-optimized final multiply: fma(g*s, u, 0)\nout[base_idx] = (T)metal::fma(g0 * s0, u0, 0.0f);\nout[base_idx + 1] = (T)metal::fma(g1 * s1, u1, 0.0f);\nout[base_idx + 2] = (T)metal::fma(g2 * s2, u2, 0.0f);\nout[base_idx + 3] = (T)metal::fma(g3 * s3, u3, 0.0f);\nout[base_idx + 4] = (T)metal::fma(g4 * s4, u4, 0.0f);\nout[base_idx + 5] = (T)metal::fma(g5 * s5, u5, 0.0f);\nout[base_idx + 6] = (T)metal::fma(g6 * s6, u6, 0.0f);\nout[base_idx + 7] = (T)metal::fma(g7 * s7, u7, 0.0f);",
                      "header": "",
                      "threadgroup": [
                        192,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen5_5a1b14911781",
                    "generation": 9,
                    "llm_reasoning": "Use `metal::fma` for FMA units and pure `fast` path (no `precise::divide`) to maximize ALU throughput and reduce latency."
                  },
                  "visit_count": 1,
                  "max_reward": 0.8178092072586723,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      162.166,
                      157.541,
                      156.625,
                      154.125,
                      151.667,
                      196.5,
                      300.833,
                      796.042,
                      190.125,
                      157.125,
                      154.25,
                      145.958,
                      152.5,
                      150.792,
                      157.125,
                      156.834,
                      165.666,
                      154.417,
                      147.792,
                      158.292
                    ],
                    "median_us": 157.125,
                    "reward": 0.8178092072586723,
                    "speedup": 0.9257470167064439
                  },
                  "children": []
                },
                {
                  "node_id": "gen9_76ffc0830b76",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen9",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 12;\n\nif (base_idx >= N) return;\n\n// Prefetch first 4 elements\nfloat g0 = base_idx < N ? (float)gate[base_idx] : 0.0f;\nfloat u0 = base_idx < N ? (float)up[base_idx] : 0.0f;\nfloat g1 = base_idx + 1 < N ? (float)gate[base_idx + 1] : 0.0f;\nfloat u1 = base_idx + 1 < N ? (float)up[base_idx + 1] : 0.0f;\nfloat g2 = base_idx + 2 < N ? (float)gate[base_idx + 2] : 0.0f;\nfloat u2 = base_idx + 2 < N ? (float)up[base_idx + 2] : 0.0f;\nfloat g3 = base_idx + 3 < N ? (float)gate[base_idx + 3] : 0.0f;\nfloat u3 = base_idx + 3 < N ? (float)up[base_idx + 3] : 0.0f;\n\n// Compute first 4 while prefetching next 4\nfloat e0 = metal::fast::exp(-g0);\nfloat e1 = metal::fast::exp(-g1);\nfloat g4 = base_idx + 4 < N ? (float)gate[base_idx + 4] : 0.0f;\nfloat u4 = base_idx + 4 < N ? (float)up[base_idx + 4] : 0.0f;\nfloat e2 = metal::fast::exp(-g2);\nfloat e3 = metal::fast::exp(-g3);\nfloat g5 = base_idx + 5 < N ? (float)gate[base_idx + 5] : 0.0f;\nfloat u5 = base_idx + 5 < N ? (float)up[base_idx + 5] : 0.0f;\n\nfloat s0 = 1.0f / (1.0f + e0);\nfloat s1 = 1.0f / (1.0f + e1);\nfloat g6 = base_idx + 6 < N ? (float)gate[base_idx + 6] : 0.0f;\nfloat u6 = base_idx + 6 < N ? (float)up[base_idx + 6] : 0.0f;\nfloat s2 = 1.0f / (1.0f + e2);\nfloat s3 = 1.0f / (1.0f + e3);\nfloat g7 = base_idx + 7 < N ? (float)gate[base_idx + 7] : 0.0f;\nfloat u7 = base_idx + 7 < N ? (float)up[base_idx + 7] : 0.0f;\n\n// Store first 4 while computing next 4\nif (base_idx < N) out[base_idx] = (T)(g0 * s0 * u0);\nfloat e4 = metal::fast::exp(-g4);\nif (base_idx + 1 < N) out[base_idx + 1] = (T)(g1 * s1 * u1);\nfloat e5 = metal::fast::exp(-g5);\nif (base_idx + 2 < N) out[base_idx + 2] = (T)(g2 * s2 * u2);\nfloat e6 = metal::fast::exp(-g6);\nif (base_idx + 3 < N) out[base_idx + 3] = (T)(g3 * s3 * u3);\nfloat e7 = metal::fast::exp(-g7);\n\nfloat s4 = 1.0f / (1.0f + e4);\nfloat g8 = base_idx + 8 < N ? (float)gate[base_idx + 8] : 0.0f;\nfloat s5 = 1.0f / (1.0f + e5);\nfloat u8 = base_idx + 8 < N ? (float)up[base_idx + 8] : 0.0f;\nfloat s6 = 1.0f / (1.0f + e6);\nfloat g9 = base_idx + 9 < N ? (float)gate[base_idx + 9] : 0.0f;\nfloat s7 = 1.0f / (1.0f + e7);\nfloat u9 = base_idx + 9 < N ? (float)up[base_idx + 9] : 0.0f;\n\n// Store middle 4 while loading last 4\nif (base_idx + 4 < N) out[base_idx + 4] = (T)(g4 * s4 * u4);\nfloat g10 = base_idx + 10 < N ? (float)gate[base_idx + 10] : 0.0f;\nif (base_idx + 5 < N) out[base_idx + 5] = (T)(g5 * s5 * u5);\nfloat u10 = base_idx + 10 < N ? (float)up[base_idx + 10] : 0.0f;\nif (base_idx + 6 < N) out[base_idx + 6] = (T)(g6 * s6 * u6);\nfloat g11 = base_idx + 11 < N ? (float)gate[base_idx + 11] : 0.0f;\nif (base_idx + 7 < N) out[base_idx + 7] = (T)(g7 * s7 * u7);\nfloat u11 = base_idx + 11 < N ? (float)up[base_idx + 11] : 0.0f;\n\n// Compute and store last 4\nfloat e8 = metal::fast::exp(-g8);\nfloat e9 = metal::fast::exp(-g9);\nfloat e10 = metal::fast::exp(-g10);\nfloat e11 = metal::fast::exp(-g11);\n\nfloat s8 = 1.0f / (1.0f + e8);\nfloat s9 = 1.0f / (1.0f + e9);\nfloat s10 = 1.0f / (1.0f + e10);\nfloat s11 = 1.0f / (1.0f + e11);\n\nif (base_idx + 8 < N) out[base_idx + 8] = (T)(g8 * s8 * u8);\nif (base_idx + 9 < N) out[base_idx + 9] = (T)(g9 * s9 * u9);\nif (base_idx + 10 < N) out[base_idx + 10] = (T)(g10 * s10 * u10);\nif (base_idx + 11 < N) out[base_idx + 11] = (T)(g11 * s11 * u11);",
                      "header": "",
                      "threadgroup": [
                        128,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen5_5a1b14911781",
                    "generation": 9,
                    "llm_reasoning": "Reduce grid size by 12x (12 elements/thread) with explicit prefetch pattern to hide memory latency with computation overlap."
                  },
                  "visit_count": 1,
                  "max_reward": 1.0594115400567263,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      164.792,
                      144.959,
                      142.667,
                      148.75,
                      132.833,
                      149.625,
                      161.75,
                      138.292,
                      127.5,
                      131.666,
                      122.5,
                      125.333,
                      122.25,
                      216.541,
                      122.0,
                      125.25,
                      125.958,
                      129.125,
                      120.667,
                      122.916
                    ],
                    "median_us": 131.666,
                    "reward": 1.0594115400567263,
                    "speedup": 1.1047498974678354
                  },
                  "children": []
                },
                {
                  "node_id": "gen9_b92f3341cea2",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen9",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint tid = thread_position_in_grid.x;\nuint lane_id = tid % 32;\nuint warp_base = (tid / 32) * 32 * 8;\nuint idx = warp_base + lane_id;\n\n// Each warp processes 256 elements (32 threads \u00d7 8 elements)\n#pragma unroll\nfor (uint i = 0; i < 8; i++) {\n    uint offset = i * 32;\n    uint global_idx = idx + offset;\n    \n    if (global_idx < N) {\n        float g = (float)gate[global_idx];\n        float u = (float)up[global_idx];\n        \n        // Compute with warp-synchronized pattern\n        float neg_g = -g;\n        float exp_val = metal::fast::exp(neg_g);\n        float denom = 1.0f + exp_val;\n        float sig = 1.0f / denom;\n        float result = g * sig * u;\n        \n        out[global_idx] = (T)result;\n    }\n}",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen5_5a1b14911781",
                    "generation": 9,
                    "llm_reasoning": "Optimize for M4's SIMD-32 width using warp-level computation with shuffle to broadcast intermediate values within warp."
                  },
                  "visit_count": 1,
                  "max_reward": 0.9574793212621459,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      146.041,
                      135.5,
                      127.917,
                      119.208,
                      121.083,
                      129.0,
                      246.583,
                      125.084,
                      122.958,
                      121.875,
                      122.292,
                      197.625,
                      753.708,
                      209.792,
                      136.833,
                      130.167,
                      128.458,
                      131.75,
                      139.125,
                      122.791
                    ],
                    "median_us": 130.167,
                    "reward": 0.9574793212621459,
                    "speedup": 1.1174721703657609
                  },
                  "children": []
                },
                {
                  "node_id": "gen9_99c220809a01",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen9",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\nif (base_idx + 7 >= N) {\n    for (uint i = 0; i < 8 && base_idx + i < N; i++) {\n        uint idx = base_idx + i;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float sig = 1.0f / (1.0f + metal::fast::exp(-g));\n        out[idx] = (T)(g * sig * u);\n    }\n    return;\n}\n\n// Load all in reverse order to optimize cache line fetch\nfloat u7 = (float)up[base_idx + 7];\nfloat g7 = (float)gate[base_idx + 7];\nfloat u6 = (float)up[base_idx + 6];\nfloat g6 = (float)gate[base_idx + 6];\nfloat u5 = (float)up[base_idx + 5];\nfloat g5 = (float)gate[base_idx + 5];\nfloat u4 = (float)up[base_idx + 4];\nfloat g4 = (float)gate[base_idx + 4];\nfloat u3 = (float)up[base_idx + 3];\nfloat g3 = (float)gate[base_idx + 3];\nfloat u2 = (float)up[base_idx + 2];\nfloat g2 = (float)gate[base_idx + 2];\nfloat u1 = (float)up[base_idx + 1];\nfloat g1 = (float)gate[base_idx + 1];\nfloat u0 = (float)up[base_idx];\nfloat g0 = (float)gate[base_idx];\n\n// Compute all sigmoids in parallel\nfloat s0 = 1.0f / (1.0f + metal::fast::exp(-g0));\nfloat s1 = 1.0f / (1.0f + metal::fast::exp(-g1));\nfloat s2 = 1.0f / (1.0f + metal::fast::exp(-g2));\nfloat s3 = 1.0f / (1.0f + metal::fast::exp(-g3));\nfloat s4 = 1.0f / (1.0f + metal::fast::exp(-g4));\nfloat s5 = 1.0f / (1.0f + metal::fast::exp(-g5));\nfloat s6 = 1.0f / (1.0f + metal::fast::exp(-g6));\nfloat s7 = 1.0f / (1.0f + metal::fast::exp(-g7));\n\n// Compute all products\nfloat r0 = g0 * s0 * u0;\nfloat r1 = g1 * s1 * u1;\nfloat r2 = g2 * s2 * u2;\nfloat r3 = g3 * s3 * u3;\nfloat r4 = g4 * s4 * u4;\nfloat r5 = g5 * s5 * u5;\nfloat r6 = g6 * s6 * u6;\nfloat r7 = g7 * s7 * u7;\n\n// Store in reverse order for write combining\nout[base_idx + 7] = (T)r7;\nout[base_idx + 6] = (T)r6;\nout[base_idx + 5] = (T)r5;\nout[base_idx + 4] = (T)r4;\nout[base_idx + 3] = (T)r3;\nout[base_idx + 2] = (T)r2;\nout[base_idx + 1] = (T)r1;\nout[base_idx] = (T)r0;",
                      "header": "",
                      "threadgroup": [
                        192,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen5_5a1b14911781",
                    "generation": 9,
                    "llm_reasoning": "Use reverse unrolling order (compute stores first, loads last) to maximize store buffer utilization and allow early write retirement."
                  },
                  "visit_count": 1,
                  "max_reward": 0.9146126514479154,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      135.25,
                      124.958,
                      130.459,
                      140.916,
                      198.625,
                      487.75,
                      215.0,
                      166.542,
                      130.875,
                      154.084,
                      134.292,
                      127.083,
                      125.417,
                      139.958,
                      233.25,
                      229.25,
                      129.875,
                      132.959,
                      125.042,
                      142.542
                    ],
                    "median_us": 139.958,
                    "reward": 0.9146126514479154,
                    "speedup": 1.0392975035367753
                  },
                  "children": []
                }
              ]
            }
          ]
        },
        {
          "node_id": "gen1_c937492aadcf",
          "candidate": {
            "spec": {
              "name": "kk_glm_fused_swiglu_gen1",
              "input_names": [
                "gate",
                "up"
              ],
              "output_names": [
                "out"
              ],
              "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\n#pragma unroll\nfor (uint i = 0; i < 8; i++) {\n    uint idx = base_idx + i;\n    if (idx >= N) return;\n    \n    float g = (float)gate[idx];\n    float u = (float)up[idx];\n    float exp_val = metal::exp(-g);\n    float sig = 1.0f / (1.0f + exp_val);\n    out[idx] = (T)(g * sig * u);\n}",
              "header": "",
              "threadgroup": [
                192,
                1,
                1
              ],
              "template_params": [
                [
                  "T",
                  "float32"
                ]
              ]
            },
            "parent_id": "root",
            "generation": 1,
            "llm_reasoning": "Process 8 elements per thread with explicit unrolling to maximize register utilization and amortize thread launch overhead."
          },
          "visit_count": 13,
          "max_reward": 1.2020222632407604,
          "prior": 0.25,
          "eval_result": {
            "compiled": true,
            "correct": true,
            "compile_error": null,
            "correctness_error": null,
            "timings_us": [
              158.958,
              151.542,
              144.625,
              142.458,
              135.917,
              144.333,
              193.291,
              197.584,
              268.667,
              144.75,
              228.666,
              154.584,
              145.5,
              147.375,
              136.667,
              149.042,
              142.708,
              140.959,
              139.708,
              139.5
            ],
            "median_us": 145.5,
            "reward": 0.9239116645481901,
            "speedup": 0.9997113402061856
          },
          "children": [
            {
              "node_id": "gen4_dd79b7bce5f6",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen4",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint simd_idx = thread_position_in_threadgroup.x;\nuint simd_base = thread_position_in_grid.x - simd_idx;\nuint elements_per_simd = 32;\n\nfor (uint base = simd_base * elements_per_simd; base < N; base += 32 * elements_per_simd) {\n    uint idx = base + simd_idx;\n    if (idx >= N) return;\n    \n    float g = (float)gate[idx];\n    float u = (float)up[idx];\n    \n    // Compute sigmoid with abs trick for stability\n    float abs_g = metal::abs(g);\n    float exp_val = metal::exp(-abs_g);\n    float sig_abs = 1.0f / (1.0f + exp_val);\n    float sig = (g >= 0.0f) ? sig_abs : (1.0f - sig_abs);\n    \n    out[idx] = (T)(g * sig * u);\n}",
                  "header": "",
                  "threadgroup": [
                    32,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_c937492aadcf",
                "generation": 4,
                "llm_reasoning": "Use horizontal SIMD operations to compute 32 elements cooperatively within each SIMD group, maximizing SIMD-lane utilization and reducing per-thread overhead."
              },
              "visit_count": 5,
              "max_reward": 1.1647582560189749,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  139.5,
                  138.417,
                  134.917,
                  145.541,
                  151.042,
                  140.0,
                  145.166,
                  141.708,
                  140.167,
                  141.709,
                  128.583,
                  122.416,
                  122.083,
                  122.709,
                  124.375,
                  124.0,
                  141.625,
                  140.875,
                  154.291,
                  141.0
                ],
                "median_us": 140.167,
                "reward": 1.0642859560349018,
                "speedup": 1.0377478293749598
              },
              "children": [
                {
                  "node_id": "gen10_7a3b9c3fa6db",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen10",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint tid = thread_position_in_threadgroup.x;\nuint gid = thread_position_in_grid.x;\nconst uint ELEMS_PER_THREAD = 8;\nconst uint THREADS = 128;\n\nthreadgroup float s_gate[THREADS * ELEMS_PER_THREAD];\nthreadgroup float s_up[THREADS * ELEMS_PER_THREAD];\n\n// Coalesced load into threadgroup memory\nfor (uint i = 0; i < ELEMS_PER_THREAD; i++) {\n    uint idx = gid * ELEMS_PER_THREAD + i;\n    if (idx < N) {\n        s_gate[tid * ELEMS_PER_THREAD + i] = (float)gate[idx];\n        s_up[tid * ELEMS_PER_THREAD + i] = (float)up[idx];\n    }\n}\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\n// Compute from threadgroup memory\nfor (uint i = 0; i < ELEMS_PER_THREAD; i++) {\n    uint idx = gid * ELEMS_PER_THREAD + i;\n    if (idx < N) {\n        float g = s_gate[tid * ELEMS_PER_THREAD + i];\n        float u = s_up[tid * ELEMS_PER_THREAD + i];\n        \n        float abs_g = metal::abs(g);\n        float exp_val = metal::exp(-abs_g);\n        float sig_abs = 1.0f / (1.0f + exp_val);\n        float sig = (g >= 0.0f) ? sig_abs : (1.0f - sig_abs);\n        \n        out[idx] = (T)(g * sig * u);\n    }\n}",
                      "header": "",
                      "threadgroup": [
                        128,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen4_dd79b7bce5f6",
                    "generation": 10,
                    "llm_reasoning": "Use threadgroup memory to cache gate/up values and enable coalesced writes, combined with 8 elements/thread to balance occupancy."
                  },
                  "visit_count": 1,
                  "max_reward": 0.0,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": false,
                    "compile_error": null,
                    "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 1023 / 1536 (66.6%)\nFirst 5 mismatches are at indices:\n [0]: 0.13437508046627045 (ACTUAL), -0.06948916614055634 (DESIRED)\n [1]: -0.05563408136367798 (ACTUAL), -0.044312771409749985 (DESIRED)\n [2]: -1.256035327911377 (ACTUAL), 0.2393781691789627 (DESIRED)\n [3]: 0.19356650114059448 (ACTUAL), -0.0236652884632349 (DESIRED)\n [4]: 0.9590476155281067 (ACTUAL), 0.7961243987083435 (DESIRED)\nMax absolute difference among violations: 4.8448267\nMax relative difference among violations: 288.77182\n ACTUAL: array([ 0.134375, -0.055634, -1.256035, ..., -0.      , -0.      ,\n       -0.      ], shape=(1536,), dtype=float32)\n DESIRED: array([-0.069489, -0.044313,  0.239378, ...,  0.185042,  0.173579,\n       -0.6558  ], shape=(1536,), dtype=float32)",
                    "timings_us": [],
                    "median_us": Infinity,
                    "reward": 0.0,
                    "speedup": 0.0
                  },
                  "children": []
                },
                {
                  "node_id": "gen10_6ac03140fadf",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen10",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint tid = thread_position_in_grid.x;\nconst uint STRIDE = 48;\n\n// Process 32 strided elements to maximize cache reuse\nfloat g0, g1, g2, g3, g4, g5, g6, g7;\nfloat u0, u1, u2, u3, u4, u5, u6, u7;\nfloat r0, r1, r2, r3, r4, r5, r6, r7;\n\n#pragma unroll\nfor (uint batch = 0; batch < 4; batch++) {\n    uint idx0 = tid + (batch * 8 + 0) * STRIDE;\n    uint idx1 = tid + (batch * 8 + 1) * STRIDE;\n    uint idx2 = tid + (batch * 8 + 2) * STRIDE;\n    uint idx3 = tid + (batch * 8 + 3) * STRIDE;\n    uint idx4 = tid + (batch * 8 + 4) * STRIDE;\n    uint idx5 = tid + (batch * 8 + 5) * STRIDE;\n    uint idx6 = tid + (batch * 8 + 6) * STRIDE;\n    uint idx7 = tid + (batch * 8 + 7) * STRIDE;\n    \n    if (idx0 < N) { g0 = (float)gate[idx0]; u0 = (float)up[idx0]; }\n    if (idx1 < N) { g1 = (float)gate[idx1]; u1 = (float)up[idx1]; }\n    if (idx2 < N) { g2 = (float)gate[idx2]; u2 = (float)up[idx2]; }\n    if (idx3 < N) { g3 = (float)gate[idx3]; u3 = (float)up[idx3]; }\n    if (idx4 < N) { g4 = (float)gate[idx4]; u4 = (float)up[idx4]; }\n    if (idx5 < N) { g5 = (float)gate[idx5]; u5 = (float)up[idx5]; }\n    if (idx6 < N) { g6 = (float)gate[idx6]; u6 = (float)up[idx6]; }\n    if (idx7 < N) { g7 = (float)gate[idx7]; u7 = (float)up[idx7]; }\n    \n    // Parallel sigmoid computation\n    float a0 = metal::abs(g0); float e0 = metal::exp(-a0); float s0 = 1.0f / (1.0f + e0); r0 = g0 * ((g0 >= 0) ? s0 : (1.0f - s0)) * u0;\n    float a1 = metal::abs(g1); float e1 = metal::exp(-a1); float s1 = 1.0f / (1.0f + e1); r1 = g1 * ((g1 >= 0) ? s1 : (1.0f - s1)) * u1;\n    float a2 = metal::abs(g2); float e2 = metal::exp(-a2); float s2 = 1.0f / (1.0f + e2); r2 = g2 * ((g2 >= 0) ? s2 : (1.0f - s2)) * u2;\n    float a3 = metal::abs(g3); float e3 = metal::exp(-a3); float s3 = 1.0f / (1.0f + e3); r3 = g3 * ((g3 >= 0) ? s3 : (1.0f - s3)) * u3;\n    float a4 = metal::abs(g4); float e4 = metal::exp(-a4); float s4 = 1.0f / (1.0f + e4); r4 = g4 * ((g4 >= 0) ? s4 : (1.0f - s4)) * u4;\n    float a5 = metal::abs(g5); float e5 = metal::exp(-a5); float s5 = 1.0f / (1.0f + e5); r5 = g5 * ((g5 >= 0) ? s5 : (1.0f - s5)) * u5;\n    float a6 = metal::abs(g6); float e6 = metal::exp(-a6); float s6 = 1.0f / (1.0f + e6); r6 = g6 * ((g6 >= 0) ? s6 : (1.0f - s6)) * u6;\n    float a7 = metal::abs(g7); float e7 = metal::exp(-a7); float s7 = 1.0f / (1.0f + e7); r7 = g7 * ((g7 >= 0) ? s7 : (1.0f - s7)) * u7;\n    \n    if (idx0 < N) out[idx0] = (T)r0;\n    if (idx1 < N) out[idx1] = (T)r1;\n    if (idx2 < N) out[idx2] = (T)r2;\n    if (idx3 < N) out[idx3] = (T)r3;\n    if (idx4 < N) out[idx4] = (T)r4;\n    if (idx5 < N) out[idx5] = (T)r5;\n    if (idx6 < N) out[idx6] = (T)r6;\n    if (idx7 < N) out[idx7] = (T)r7;\n}",
                      "header": "",
                      "threadgroup": [
                        48,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen4_dd79b7bce5f6",
                    "generation": 10,
                    "llm_reasoning": "Maximize ILP by computing 32 independent sigmoid operations per thread with minimal branching, using stride access pattern."
                  },
                  "visit_count": 1,
                  "max_reward": 1.0326362778396583,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      146.917,
                      254.458,
                      152.5,
                      130.042,
                      126.125,
                      131.5,
                      117.291,
                      162.5,
                      125.25,
                      121.875,
                      158.833,
                      126.0,
                      121.25,
                      149.333,
                      118.209,
                      126.458,
                      148.792,
                      135.167,
                      163.833,
                      148.125
                    ],
                    "median_us": 135.167,
                    "reward": 1.0326362778396583,
                    "speedup": 1.0761354472615356
                  },
                  "children": []
                },
                {
                  "node_id": "gen10_29ad1a7654df",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen10",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint gid = thread_position_in_grid.x;\nconst uint ELEMS = 16;\nuint base = gid * ELEMS;\n\nif (base >= N) return;\n\n// Pipeline stage 1: Load first 4\nfloat g0 = (base + 0 < N) ? (float)gate[base + 0] : 0.0f;\nfloat g1 = (base + 1 < N) ? (float)gate[base + 1] : 0.0f;\nfloat g2 = (base + 2 < N) ? (float)gate[base + 2] : 0.0f;\nfloat g3 = (base + 3 < N) ? (float)gate[base + 3] : 0.0f;\nfloat u0 = (base + 0 < N) ? (float)up[base + 0] : 0.0f;\nfloat u1 = (base + 1 < N) ? (float)up[base + 1] : 0.0f;\nfloat u2 = (base + 2 < N) ? (float)up[base + 2] : 0.0f;\nfloat u3 = (base + 3 < N) ? (float)up[base + 3] : 0.0f;\n\n// Compute first batch while loading next\nfloat a0 = metal::abs(g0), e0 = metal::exp(-a0), s0 = 1.0f / (1.0f + e0);\nfloat a1 = metal::abs(g1), e1 = metal::exp(-a1), s1 = 1.0f / (1.0f + e1);\nfloat g4 = (base + 4 < N) ? (float)gate[base + 4] : 0.0f;\nfloat g5 = (base + 5 < N) ? (float)gate[base + 5] : 0.0f;\nfloat a2 = metal::abs(g2), e2 = metal::exp(-a2), s2 = 1.0f / (1.0f + e2);\nfloat a3 = metal::abs(g3), e3 = metal::exp(-a3), s3 = 1.0f / (1.0f + e3);\nfloat u4 = (base + 4 < N) ? (float)up[base + 4] : 0.0f;\nfloat u5 = (base + 5 < N) ? (float)up[base + 5] : 0.0f;\n\nfloat r0 = g0 * ((g0 >= 0) ? s0 : (1.0f - s0)) * u0;\nfloat r1 = g1 * ((g1 >= 0) ? s1 : (1.0f - s1)) * u1;\nfloat g6 = (base + 6 < N) ? (float)gate[base + 6] : 0.0f;\nfloat g7 = (base + 7 < N) ? (float)gate[base + 7] : 0.0f;\nfloat r2 = g2 * ((g2 >= 0) ? s2 : (1.0f - s2)) * u2;\nfloat r3 = g3 * ((g3 >= 0) ? s3 : (1.0f - s3)) * u3;\nfloat u6 = (base + 6 < N) ? (float)up[base + 6] : 0.0f;\nfloat u7 = (base + 7 < N) ? (float)up[base + 7] : 0.0f;\n\n// Second batch\nfloat a4 = metal::abs(g4), e4 = metal::exp(-a4), s4 = 1.0f / (1.0f + e4);\nfloat a5 = metal::abs(g5), e5 = metal::exp(-a5), s5 = 1.0f / (1.0f + e5);\nfloat g8 = (base + 8 < N) ? (float)gate[base + 8] : 0.0f;\nfloat g9 = (base + 9 < N) ? (float)gate[base + 9] : 0.0f;\nfloat a6 = metal::abs(g6), e6 = metal::exp(-a6), s6 = 1.0f / (1.0f + e6);\nfloat a7 = metal::abs(g7), e7 = metal::exp(-a7), s7 = 1.0f / (1.0f + e7);\nfloat u8 = (base + 8 < N) ? (float)up[base + 8] : 0.0f;\nfloat u9 = (base + 9 < N) ? (float)up[base + 9] : 0.0f;\n\nfloat r4 = g4 * ((g4 >= 0) ? s4 : (1.0f - s4)) * u4;\nfloat r5 = g5 * ((g5 >= 0) ? s5 : (1.0f - s5)) * u5;\nfloat g10 = (base + 10 < N) ? (float)gate[base + 10] : 0.0f;\nfloat g11 = (base + 11 < N) ? (float)gate[base + 11] : 0.0f;\nfloat r6 = g6 * ((g6 >= 0) ? s6 : (1.0f - s6)) * u6;\nfloat r7 = g7 * ((g7 >= 0) ? s7 : (1.0f - s7)) * u7;\nfloat u10 = (base + 10 < N) ? (float)up[base + 10] : 0.0f;\nfloat u11 = (base + 11 < N) ? (float)up[base + 11] : 0.0f;\n\n// Third batch\nfloat a8 = metal::abs(g8), e8 = metal::exp(-a8), s8 = 1.0f / (1.0f + e8);\nfloat a9 = metal::abs(g9), e9 = metal::exp(-a9), s9 = 1.0f / (1.0f + e9);\nfloat g12 = (base + 12 < N) ? (float)gate[base + 12] : 0.0f;\nfloat g13 = (base + 13 < N) ? (float)gate[base + 13] : 0.0f;\nfloat a10 = metal::abs(g10), e10 = metal::exp(-a10), s10 = 1.0f / (1.0f + e10);\nfloat a11 = metal::abs(g11), e11 = metal::exp(-a11), s11 = 1.0f / (1.0f + e11);\nfloat u12 = (base + 12 < N) ? (float)up[base + 12] : 0.0f;\nfloat u13 = (base + 13 < N) ? (float)up[base + 13] : 0.0f;\n\nfloat r8 = g8 * ((g8 >= 0) ? s8 : (1.0f - s8)) * u8;\nfloat r9 = g9 * ((g9 >= 0) ? s9 : (1.0f - s9)) * u9;\nfloat g14 = (base + 14 < N) ? (float)gate[base + 14] : 0.0f;\nfloat g15 = (base + 15 < N) ? (float)gate[base + 15] : 0.0f;\nfloat r10 = g10 * ((g10 >= 0) ? s10 : (1.0f - s10)) * u10;\nfloat r11 = g11 * ((g11 >= 0) ? s11 : (1.0f - s11)) * u11;\nfloat u14 = (base + 14 < N) ? (float)up[base + 14] : 0.0f;\nfloat u15 = (base + 15 < N) ? (float)up[base + 15] : 0.0f;\n\n// Fourth batch\nfloat a12 = metal::abs(g12), e12 = metal::exp(-a12), s12 = 1.0f / (1.0f + e12);\nfloat a13 = metal::abs(g13), e13 = metal::exp(-a13), s13 = 1.0f / (1.0f + e13);\nfloat a14 = metal::abs(g14), e14 = metal::exp(-a14), s14 = 1.0f / (1.0f + e14);\nfloat a15 = metal::abs(g15), e15 = metal::exp(-a15), s15 = 1.0f / (1.0f + e15);\n\nfloat r12 = g12 * ((g12 >= 0) ? s12 : (1.0f - s12)) * u12;\nfloat r13 = g13 * ((g13 >= 0) ? s13 : (1.0f - s13)) * u13;\nfloat r14 = g14 * ((g14 >= 0) ? s14 : (1.0f - s14)) * u14;\nfloat r15 = g15 * ((g15 >= 0) ? s15 : (1.0f - s15)) * u15;\n\n// Coalesced stores\nif (base + 0 < N) out[base + 0] = (T)r0;\nif (base + 1 < N) out[base + 1] = (T)r1;\nif (base + 2 < N) out[base + 2] = (T)r2;\nif (base + 3 < N) out[base + 3] = (T)r3;\nif (base + 4 < N) out[base + 4] = (T)r4;\nif (base + 5 < N) out[base + 5] = (T)r5;\nif (base + 6 < N) out[base + 6] = (T)r6;\nif (base + 7 < N) out[base + 7] = (T)r7;\nif (base + 8 < N) out[base + 8] = (T)r8;\nif (base + 9 < N) out[base + 9] = (T)r9;\nif (base + 10 < N) out[base + 10] = (T)r10;\nif (base + 11 < N) out[base + 11] = (T)r11;\nif (base + 12 < N) out[base + 12] = (T)r12;\nif (base + 13 < N) out[base + 13] = (T)r13;\nif (base + 14 < N) out[base + 14] = (T)r14;\nif (base + 15 < N) out[base + 15] = (T)r15;",
                      "header": "",
                      "threadgroup": [
                        96,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen4_dd79b7bce5f6",
                    "generation": 10,
                    "llm_reasoning": "Use precise 16 elements/thread matching best variant but with pipelined memory access and computation to hide latency better."
                  },
                  "visit_count": 1,
                  "max_reward": 0.9393093512442734,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      151.334,
                      140.833,
                      146.209,
                      163.709,
                      155.375,
                      148.666,
                      158.0,
                      145.708,
                      191.0,
                      193.334,
                      289.292,
                      178.75,
                      148.583,
                      135.125,
                      141.292,
                      144.334,
                      141.625,
                      131.833,
                      129.334,
                      122.791
                    ],
                    "median_us": 148.583,
                    "reward": 0.9393093512442734,
                    "speedup": 0.9789679842243056
                  },
                  "children": []
                },
                {
                  "node_id": "gen10_a96408771138",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen10",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint gid = thread_position_in_grid.x;\nconst uint ELEMS = 12;\nuint base = gid * ELEMS;\n\n#pragma unroll\nfor (uint i = 0; i < ELEMS; i++) {\n    uint idx = base + i;\n    if (idx >= N) return;\n    \n    float g = (float)gate[idx];\n    float u = (float)up[idx];\n    \n    // Optimized sigmoid: use rcp for division\n    float abs_g = metal::abs(g);\n    float neg_abs = -abs_g;\n    float exp_val = metal::exp(neg_abs);\n    float one_plus_exp = metal::fma(exp_val, 1.0f, 1.0f);\n    float sig_abs = metal::precise::divide(1.0f, one_plus_exp);\n    \n    // Branch-free sign correction\n    float sign_mask = (g >= 0.0f) ? 1.0f : -1.0f;\n    float sig = metal::fma(sign_mask, sig_abs, (sign_mask < 0.0f) ? 1.0f : 0.0f);\n    \n    // Fused result computation\n    float result = g * sig * u;\n    out[idx] = (T)result;\n}",
                      "header": "",
                      "threadgroup": [
                        128,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen4_dd79b7bce5f6",
                    "generation": 10,
                    "llm_reasoning": "Optimize exp computation by using reciprocal directly with fused multiply-add pattern, 12 elements/thread for balanced occupancy."
                  },
                  "visit_count": 1,
                  "max_reward": 1.1647582560189749,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      125.042,
                      129.166,
                      118.125,
                      115.583,
                      118.625,
                      129.458,
                      122.334,
                      118.792,
                      122.375,
                      127.125,
                      118.791,
                      117.416,
                      118.375,
                      117.833,
                      117.125,
                      120.041,
                      120.333,
                      136.708,
                      142.0,
                      174.0
                    ],
                    "median_us": 120.333,
                    "reward": 1.1647582560189749,
                    "speedup": 1.2087955922315574
                  },
                  "children": []
                }
              ]
            },
            {
              "node_id": "gen4_f8604a6a25d1",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen4",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\nif (base_idx + 7 < N) {\n    // Fully vectorized path\n    float4 g0 = float4(gate[base_idx], gate[base_idx+1], gate[base_idx+2], gate[base_idx+3]);\n    float4 u0 = float4(up[base_idx], up[base_idx+1], up[base_idx+2], up[base_idx+3]);\n    float4 g1 = float4(gate[base_idx+4], gate[base_idx+5], gate[base_idx+6], gate[base_idx+7]);\n    float4 u1 = float4(up[base_idx+4], up[base_idx+5], up[base_idx+6], up[base_idx+7]);\n    \n    float4 exp0 = metal::exp(-g0);\n    float4 sig0 = 1.0f / (1.0f + exp0);\n    float4 result0 = g0 * sig0 * u0;\n    \n    float4 exp1 = metal::exp(-g1);\n    float4 sig1 = 1.0f / (1.0f + exp1);\n    float4 result1 = g1 * sig1 * u1;\n    \n    out[base_idx] = (T)result0.x;\n    out[base_idx+1] = (T)result0.y;\n    out[base_idx+2] = (T)result0.z;\n    out[base_idx+3] = (T)result0.w;\n    out[base_idx+4] = (T)result1.x;\n    out[base_idx+5] = (T)result1.y;\n    out[base_idx+6] = (T)result1.z;\n    out[base_idx+7] = (T)result1.w;\n} else {\n    // Scalar tail handling\n    #pragma unroll\n    for (uint i = 0; i < 8; i++) {\n        uint idx = base_idx + i;\n        if (idx >= N) return;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float exp_val = metal::exp(-g);\n        float sig = 1.0f / (1.0f + exp_val);\n        out[idx] = (T)(g * sig * u);\n    }\n}",
                  "header": "",
                  "threadgroup": [
                    64,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_c937492aadcf",
                "generation": 4,
                "llm_reasoning": "Combine float4 vectorization with 2-way unrolling (8 elements per thread) and use precise FMA operations to maximize arithmetic intensity while maintaining coalesced memory access."
              },
              "visit_count": 1,
              "max_reward": 0.8982352092945689,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  509.792,
                  542.625,
                  513.584,
                  152.417,
                  148.042,
                  131.625,
                  128.916,
                  131.25,
                  156.875,
                  139.042,
                  125.959,
                  123.625,
                  119.792,
                  124.125,
                  130.75,
                  122.0,
                  121.791,
                  122.083,
                  126.5,
                  142.167
                ],
                "median_us": 131.25,
                "reward": 0.8982352092945689,
                "speedup": 1.1082514285714287
              },
              "children": []
            },
            {
              "node_id": "gen4_72851fc52324",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen4",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 16;\n\n// Prefetch first batch\nfloat g0 = (base_idx < N) ? (float)gate[base_idx] : 0.0f;\nfloat u0 = (base_idx < N) ? (float)up[base_idx] : 0.0f;\n\n#pragma unroll\nfor (uint i = 0; i < 16; i++) {\n    uint idx = base_idx + i;\n    if (idx >= N) return;\n    \n    // Prefetch next iteration\n    uint next_idx = idx + 1;\n    float g_next = (next_idx < N && i < 15) ? (float)gate[next_idx] : 0.0f;\n    float u_next = (next_idx < N && i < 15) ? (float)up[next_idx] : 0.0f;\n    \n    // Compute current\n    float exp_val = metal::exp(-g0);\n    float sig = 1.0f / (1.0f + exp_val);\n    out[idx] = (T)(g0 * sig * u0);\n    \n    // Swap buffers\n    g0 = g_next;\n    u0 = u_next;\n}",
                  "header": "",
                  "threadgroup": [
                    32,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_c937492aadcf",
                "generation": 4,
                "llm_reasoning": "Process 16 elements per thread with aggressive unrolling and prefetch next iteration's data to hide memory latency through double-buffering."
              },
              "visit_count": 5,
              "max_reward": 1.2020222632407604,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": true,
                "compile_error": null,
                "correctness_error": null,
                "timings_us": [
                  120.25,
                  117.458,
                  112.833,
                  114.208,
                  115.084,
                  118.667,
                  117.208,
                  114.584,
                  126.5,
                  131.084,
                  120.875,
                  125.959,
                  121.5,
                  122.458,
                  125.542,
                  121.084,
                  122.208,
                  134.792,
                  120.083,
                  120.25
                ],
                "median_us": 120.875,
                "reward": 1.2020222632407604,
                "speedup": 1.2033753877973112
              },
              "children": [
                {
                  "node_id": "gen6_7577377d7122",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen6",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 12;\n\nif (base_idx >= N) return;\n\n// Load batch\nfloat g[12], u[12];\n#pragma unroll\nfor (uint i = 0; i < 12; i++) {\n    uint idx = base_idx + i;\n    if (idx < N) {\n        g[i] = (float)gate[idx];\n        u[i] = (float)up[idx];\n    }\n}\n\n// Compute batch\nfloat res[12];\n#pragma unroll\nfor (uint i = 0; i < 12; i++) {\n    float exp_val = metal::exp(-g[i]);\n    float sig = 1.0f / (1.0f + exp_val);\n    res[i] = g[i] * sig * u[i];\n}\n\n// Store batch\n#pragma unroll\nfor (uint i = 0; i < 12; i++) {\n    uint idx = base_idx + i;\n    if (idx < N) {\n        out[idx] = (T)res[i];\n    }\n}",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen4_72851fc52324",
                    "generation": 6,
                    "llm_reasoning": "Process 12 elements per thread with partial unrolling to balance ILP and register pressure, using computation-memory interleaving to hide latency."
                  },
                  "visit_count": 1,
                  "max_reward": 0.9569367830076908,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      132.167,
                      128.708,
                      132.292,
                      127.459,
                      126.959,
                      130.75,
                      127.0,
                      126.167,
                      127.583,
                      127.209,
                      127.458,
                      125.5,
                      186.75,
                      512.083,
                      253.291,
                      164.125,
                      134.75,
                      151.25,
                      165.166,
                      163.583
                    ],
                    "median_us": 132.167,
                    "reward": 0.9569367830076908,
                    "speedup": 1.1005621675607375
                  },
                  "children": []
                },
                {
                  "node_id": "gen6_8c161833e320",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen6",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 20;\n\n#pragma unroll\nfor (uint block = 0; block < 4; block++) {\n    uint offset = base_idx + block * 5;\n    \n    #pragma unroll\n    for (uint i = 0; i < 5; i++) {\n        uint idx = offset + i;\n        if (idx >= N) return;\n        \n        float g_val = (float)gate[idx];\n        float u_val = (float)up[idx];\n        \n        float exp_val = metal::exp(-g_val);\n        float sig = 1.0f / (1.0f + exp_val);\n        \n        out[idx] = (T)(g_val * sig * u_val);\n    }\n}",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen4_72851fc52324",
                    "generation": 6,
                    "llm_reasoning": "Use 20 elements per thread with blocked computation to maximize register utilization and reduce thread count, processing in 4x5 pattern."
                  },
                  "visit_count": 1,
                  "max_reward": 1.1304146172121183,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      127.208,
                      121.125,
                      122.792,
                      124.125,
                      120.208,
                      124.625,
                      122.917,
                      133.291,
                      121.958,
                      267.083,
                      124.916,
                      128.75,
                      125.0,
                      121.666,
                      120.542,
                      120.625,
                      123.292,
                      124.583,
                      124.542,
                      121.25
                    ],
                    "median_us": 124.125,
                    "reward": 1.1304146172121183,
                    "speedup": 1.1718670694864048
                  },
                  "children": []
                },
                {
                  "node_id": "gen6_0e04ec367479",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen6",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 24;\n\nif (base_idx >= N) return;\n\n// Triple-buffered load pattern\nfloat g0 = (float)gate[base_idx];\nfloat u0 = (float)up[base_idx];\nfloat g1 = (base_idx + 1 < N) ? (float)gate[base_idx + 1] : 0.0f;\nfloat u1 = (base_idx + 1 < N) ? (float)up[base_idx + 1] : 0.0f;\n\n#pragma unroll\nfor (uint i = 0; i < 24; i++) {\n    uint idx = base_idx + i;\n    if (idx >= N) return;\n    \n    // Prefetch two ahead\n    uint prefetch_idx = idx + 2;\n    float g2 = (prefetch_idx < N && i < 22) ? (float)gate[prefetch_idx] : 0.0f;\n    float u2 = (prefetch_idx < N && i < 22) ? (float)up[prefetch_idx] : 0.0f;\n    \n    // Compute with first buffer\n    float exp_val = metal::exp(-g0);\n    float sig = 1.0f / (1.0f + exp_val);\n    out[idx] = (T)(g0 * sig * u0);\n    \n    // Rotate buffers\n    g0 = g1; u0 = u1;\n    g1 = g2; u1 = u2;\n}",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen4_72851fc52324",
                    "generation": 6,
                    "llm_reasoning": "Process 24 elements per thread with triple-buffered loads to maximize memory bandwidth utilization and allow parallel computation."
                  },
                  "visit_count": 1,
                  "max_reward": 1.1158305553462216,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      138.25,
                      150.75,
                      135.333,
                      129.792,
                      134.333,
                      129.708,
                      125.875,
                      239.625,
                      129.916,
                      127.584,
                      125.625,
                      120.292,
                      121.834,
                      121.042,
                      119.5,
                      117.75,
                      116.583,
                      118.834,
                      120.958,
                      119.833
                    ],
                    "median_us": 125.875,
                    "reward": 1.1158305553462216,
                    "speedup": 1.1555749751737836
                  },
                  "children": []
                },
                {
                  "node_id": "gen6_fc9f9344b7d2",
                  "candidate": {
                    "spec": {
                      "name": "kk_glm_fused_swiglu_gen6",
                      "input_names": [
                        "gate",
                        "up"
                      ],
                      "output_names": [
                        "out"
                      ],
                      "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 32;\n\nif (base_idx >= N) return;\n\n#pragma unroll 4\nfor (uint outer = 0; outer < 4; outer++) {\n    uint block_base = base_idx + outer * 8;\n    \n    // Load 8-element block\n    float g_block[8], u_block[8];\n    #pragma unroll\n    for (uint i = 0; i < 8; i++) {\n        uint idx = block_base + i;\n        bool valid = (idx < N);\n        g_block[i] = valid ? (float)gate[idx] : 0.0f;\n        u_block[i] = valid ? (float)up[idx] : 0.0f;\n    }\n    \n    // Compute and store 8-element block\n    #pragma unroll\n    for (uint i = 0; i < 8; i++) {\n        uint idx = block_base + i;\n        if (idx >= N) return;\n        \n        float exp_val = metal::exp(-g_block[i]);\n        float sig = 1.0f / (1.0f + exp_val);\n        out[idx] = (T)(g_block[i] * sig * u_block[i]);\n    }\n}",
                      "header": "",
                      "threadgroup": [
                        256,
                        1,
                        1
                      ],
                      "template_params": [
                        [
                          "T",
                          "float32"
                        ]
                      ]
                    },
                    "parent_id": "gen4_72851fc52324",
                    "generation": 6,
                    "llm_reasoning": "Use 32 elements per thread aligned with SIMD width, with 4x8 blocking pattern to optimize for warp execution and minimize divergence."
                  },
                  "visit_count": 1,
                  "max_reward": 0.942700939485281,
                  "prior": 0.25,
                  "eval_result": {
                    "compiled": true,
                    "correct": true,
                    "compile_error": null,
                    "correctness_error": null,
                    "timings_us": [
                      146.0,
                      140.667,
                      170.875,
                      147.042,
                      141.541,
                      128.25,
                      127.667,
                      131.291,
                      128.041,
                      130.417,
                      137.375,
                      200.0,
                      543.709,
                      192.625,
                      148.084,
                      134.709,
                      132.167,
                      157.0,
                      138.375,
                      135.416
                    ],
                    "median_us": 140.667,
                    "reward": 0.942700939485281,
                    "speedup": 1.0340591609972487
                  },
                  "children": []
                }
              ]
            },
            {
              "node_id": "gen4_02025d2c92bd",
              "candidate": {
                "spec": {
                  "name": "kk_glm_fused_swiglu_gen4",
                  "input_names": [
                    "gate",
                    "up"
                  ],
                  "output_names": [
                    "out"
                  ],
                  "source": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\n#pragma unroll\nfor (uint i = 0; i < 8; i++) {\n    uint idx = base_idx + i;\n    if (idx >= N) return;\n    \n    float g_full = (float)gate[idx];\n    float u_full = (float)up[idx];\n    \n    // Use half precision for sigmoid computation\n    half g_h = half(g_full);\n    half exp_h = metal::exp(-g_h);\n    half sig_h = half(1.0f) / (half(1.0f) + exp_h);\n    \n    // Convert back to full precision for final multiply\n    float sig = float(sig_h);\n    out[idx] = (T)(g_full * sig * u_full);\n}",
                  "header": "",
                  "threadgroup": [
                    64,
                    1,
                    1
                  ],
                  "template_params": [
                    [
                      "T",
                      "float32"
                    ]
                  ]
                },
                "parent_id": "gen1_c937492aadcf",
                "generation": 4,
                "llm_reasoning": "Use mixed precision with half-precision intermediate computations for sigmoid, casting only final result to full precision to reduce register pressure and increase occupancy."
              },
              "visit_count": 1,
              "max_reward": 0.0,
              "prior": 0.25,
              "eval_result": {
                "compiled": true,
                "correct": false,
                "compile_error": null,
                "correctness_error": "\nNot equal to tolerance rtol=0.0001, atol=0.0001\nOutput 0 mismatch\nMismatched elements: 222 / 1536 (14.5%)\nFirst 5 mismatches are at indices:\n [5]: 0.322993665933609 (ACTUAL), 0.3228328227996826 (DESIRED)\n [14]: 0.5947136282920837 (ACTUAL), 0.5944989919662476 (DESIRED)\n [21]: -0.597710371017456 (ACTUAL), -0.5973654985427856 (DESIRED)\n [32]: 0.649368166923523 (ACTUAL), 0.6497625112533569 (DESIRED)\n [34]: -0.20737580955028534 (ACTUAL), -0.20720848441123962 (DESIRED)\nMax absolute difference among violations: 0.00176716\nMax relative difference among violations: 0.00108267\n ACTUAL: array([-0.069472, -0.044338,  0.239324, ...,  0.185067,  0.173667,\n       -0.655348], shape=(1536,), dtype=float32)\n DESIRED: array([-0.069489, -0.044313,  0.239378, ...,  0.185042,  0.173579,\n       -0.6558  ], shape=(1536,), dtype=float32)",
                "timings_us": [],
                "median_us": Infinity,
                "reward": 0.0,
                "speedup": 0.0
              },
              "children": []
            }
          ]
        }
      ]
    }
  },
  "eval_history": [],
  "candidate_sources": {
    "gen1_691dd8fd480f": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 4;\nif (idx >= N) return;\n\n// Vectorized load\nfloat4 g4 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 u4 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\n\n// Vectorized SwiGLU computation\nfloat4 sig4 = 1.0f / (1.0f + metal::exp(-g4));\nfloat4 result = g4 * sig4 * u4;\n\n// Vectorized store\nout[idx] = (T)result.x;\nout[idx+1] = (T)result.y;\nout[idx+2] = (T)result.z;\nout[idx+3] = (T)result.w;",
    "gen1_caf19c818f11": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 2;\nif (idx >= N) return;\n\n// Load two elements per thread\nfloat g0 = (float)gate[idx];\nfloat u0 = (float)up[idx];\nfloat g1 = (idx + 1 < N) ? (float)gate[idx+1] : 0.0f;\nfloat u1 = (idx + 1 < N) ? (float)up[idx+1] : 0.0f;\n\n// Compute sigmoid for both elements (interleaved for ILP)\nfloat exp0 = metal::exp(-g0);\nfloat exp1 = metal::exp(-g1);\nfloat sig0 = 1.0f / (1.0f + exp0);\nfloat sig1 = 1.0f / (1.0f + exp1);\n\n// Compute outputs\nfloat result0 = g0 * sig0 * u0;\nfloat result1 = g1 * sig1 * u1;\n\n// Store results\nout[idx] = (T)result0;\nif (idx + 1 < N) {\n    out[idx+1] = (T)result1;\n}",
    "gen1_4509efaa336b": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x;\nif (idx >= N) return;\n\nfloat g = (float)gate[idx];\nfloat u = (float)up[idx];\n\n// Use metal::fast::exp for faster approximation\nfloat neg_g = -g;\nfloat exp_val = metal::fast::exp(neg_g);\nfloat sig = metal::fast::divide(1.0f, 1.0f + exp_val);\n\n// Fused multiply: g * sig * u\nfloat result = g * sig;\nresult = result * u;\n\nout[idx] = (T)result;",
    "gen1_c937492aadcf": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\n#pragma unroll\nfor (uint i = 0; i < 8; i++) {\n    uint idx = base_idx + i;\n    if (idx >= N) return;\n    \n    float g = (float)gate[idx];\n    float u = (float)up[idx];\n    float exp_val = metal::exp(-g);\n    float sig = 1.0f / (1.0f + exp_val);\n    out[idx] = (T)(g * sig * u);\n}",
    "gen2_6f0ba48228ce": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 8;\nif (idx >= N) return;\n\n// Load 2x float4 = 8 elements per thread\nfloat4 g0 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 u0 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat4 g1 = (idx + 4 < N) ? float4(gate[idx+4], gate[idx+5], gate[idx+6], gate[idx+7]) : float4(0.0f);\nfloat4 u1 = (idx + 4 < N) ? float4(up[idx+4], up[idx+5], up[idx+6], up[idx+7]) : float4(0.0f);\n\n// Compute sigmoid for all 8 elements with interleaved operations\nfloat4 exp0 = metal::exp(-g0);\nfloat4 exp1 = metal::exp(-g1);\nfloat4 sig0 = 1.0f / (1.0f + exp0);\nfloat4 sig1 = 1.0f / (1.0f + exp1);\n\n// Compute SwiGLU outputs\nfloat4 result0 = g0 * sig0 * u0;\nfloat4 result1 = g1 * sig1 * u1;\n\n// Store all 8 results\nout[idx] = (T)result0.x;\nout[idx+1] = (T)result0.y;\nout[idx+2] = (T)result0.z;\nout[idx+3] = (T)result0.w;\nif (idx + 4 < N) {\n    out[idx+4] = (T)result1.x;\n    out[idx+5] = (T)result1.y;\n    out[idx+6] = (T)result1.z;\n    out[idx+7] = (T)result1.w;\n}",
    "gen2_f1fb1fc5f353": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 4;\nif (idx >= N) return;\n\n// Load 4 elements\nfloat g0 = (float)gate[idx];\nfloat u0 = (float)up[idx];\nfloat g1 = (idx + 1 < N) ? (float)gate[idx+1] : 0.0f;\nfloat u1 = (idx + 1 < N) ? (float)up[idx+1] : 0.0f;\nfloat g2 = (idx + 2 < N) ? (float)gate[idx+2] : 0.0f;\nfloat u2 = (idx + 2 < N) ? (float)up[idx+2] : 0.0f;\nfloat g3 = (idx + 3 < N) ? (float)gate[idx+3] : 0.0f;\nfloat u3 = (idx + 3 < N) ? (float)up[idx+3] : 0.0f;\n\n// Compute sigmoid using FMA for better precision\nfloat exp0 = metal::precise::exp(-g0);\nfloat exp1 = metal::precise::exp(-g1);\nfloat exp2 = metal::precise::exp(-g2);\nfloat exp3 = metal::precise::exp(-g3);\n\nfloat sig0 = metal::fma(-exp0, 1.0f / (1.0f + exp0), 1.0f / (1.0f + exp0));\nfloat sig1 = metal::fma(-exp1, 1.0f / (1.0f + exp1), 1.0f / (1.0f + exp1));\nfloat sig2 = metal::fma(-exp2, 1.0f / (1.0f + exp2), 1.0f / (1.0f + exp2));\nfloat sig3 = metal::fma(-exp3, 1.0f / (1.0f + exp3), 1.0f / (1.0f + exp3));\n\n// Compute outputs with FMA\nout[idx] = (T)metal::fma(g0 * sig0, u0, 0.0f);\nif (idx + 1 < N) out[idx+1] = (T)metal::fma(g1 * sig1, u1, 0.0f);\nif (idx + 2 < N) out[idx+2] = (T)metal::fma(g2 * sig2, u2, 0.0f);\nif (idx + 3 < N) out[idx+3] = (T)metal::fma(g3 * sig3, u3, 0.0f);",
    "gen2_42838abd9915": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 2;\nif (idx >= N) return;\n\n// Load two elements per thread\nfloat g0 = (float)gate[idx];\nfloat u0 = (float)up[idx];\nfloat g1 = (idx + 1 < N) ? (float)gate[idx+1] : 0.0f;\nfloat u1 = (idx + 1 < N) ? (float)up[idx+1] : 0.0f;\n\n// Fast sigmoid using tanh approximation\nfloat sig0 = 0.5f + 0.5f * metal::fast::tanh(0.5f * g0);\nfloat sig1 = 0.5f + 0.5f * metal::fast::tanh(0.5f * g1);\n\n// Compute SwiGLU outputs\nfloat result0 = g0 * sig0 * u0;\nfloat result1 = g1 * sig1 * u1;\n\n// Store results\nout[idx] = (T)result0;\nif (idx + 1 < N) {\n    out[idx+1] = (T)result1;\n}",
    "gen2_fc5d8e517439": "constexpr uint N = 1536;\nconstexpr uint TILE_SIZE = 128;\n\nthreadgroup float s_gate[TILE_SIZE];\nthreadgroup float s_up[TILE_SIZE];\n\nuint tid = thread_position_in_threadgroup.x;\nuint gid = threadgroup_position_in_grid.x;\nuint idx = gid * TILE_SIZE + tid;\n\n// Cooperative load into threadgroup memory\nif (idx < N) {\n    s_gate[tid] = (float)gate[idx];\n    s_up[tid] = (float)up[idx];\n}\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\n// Process from threadgroup memory\nif (idx < N) {\n    float g = s_gate[tid];\n    float u = s_up[tid];\n    \n    // Compute sigmoid\n    float exp_val = metal::exp(-g);\n    float sig = 1.0f / (1.0f + exp_val);\n    \n    // Compute and store result\n    out[idx] = (T)(g * sig * u);\n}",
    "gen3_e8f63dda0468": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 8;\nif (idx >= N) return;\n\n// Load 8 elements as two float4 vectors\nfloat4 g4_0 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 g4_1 = float4(gate[idx+4], gate[idx+5], gate[idx+6], gate[idx+7]);\nfloat4 u4_0 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat4 u4_1 = float4(up[idx+4], up[idx+5], up[idx+6], up[idx+7]);\n\n// Vectorized sigmoid computation\nfloat4 sig4_0 = 1.0f / (1.0f + metal::exp(-g4_0));\nfloat4 sig4_1 = 1.0f / (1.0f + metal::exp(-g4_1));\n\n// Vectorized SwiGLU\nfloat4 result_0 = g4_0 * sig4_0 * u4_0;\nfloat4 result_1 = g4_1 * sig4_1 * u4_1;\n\n// Store 8 elements\nout[idx] = (T)result_0.x;\nout[idx+1] = (T)result_0.y;\nout[idx+2] = (T)result_0.z;\nout[idx+3] = (T)result_0.w;\nout[idx+4] = (T)result_1.x;\nout[idx+5] = (T)result_1.y;\nout[idx+6] = (T)result_1.z;\nout[idx+7] = (T)result_1.w;",
    "gen3_51d6f39bb155": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 4;\nif (idx >= N) return;\n\n// Coefficients for polynomial sigmoid approximation\nconstexpr float a = 0.1875f;\nconstexpr float b = -0.0390625f;\nconstexpr float c = 0.00537109375f;\n\n// Vectorized load\nfloat4 g4 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 u4 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\n\n// Polynomial sigmoid: clamp input for stability\nfloat4 x = metal::clamp(g4, -4.0f, 4.0f);\nfloat4 x2 = x * x;\nfloat4 sig4 = 0.5f + x * (a + x2 * (b + x2 * c));\n\n// SwiGLU computation\nfloat4 result = g4 * sig4 * u4;\n\n// Vectorized store\nout[idx] = (T)result.x;\nout[idx+1] = (T)result.y;\nout[idx+2] = (T)result.z;\nout[idx+3] = (T)result.w;",
    "gen3_6a2852131e90": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 8;\nif (idx >= N) return;\n\n// Process 4 pairs (8 elements total) with explicit unrolling\nfloat2 g0 = float2(gate[idx], gate[idx+1]);\nfloat2 g1 = float2(gate[idx+2], gate[idx+3]);\nfloat2 g2 = float2(gate[idx+4], gate[idx+5]);\nfloat2 g3 = float2(gate[idx+6], gate[idx+7]);\n\nfloat2 u0 = float2(up[idx], up[idx+1]);\nfloat2 u1 = float2(up[idx+2], up[idx+3]);\nfloat2 u2 = float2(up[idx+4], up[idx+5]);\nfloat2 u3 = float2(up[idx+6], up[idx+7]);\n\n// Compute sigmoid for all pairs\nfloat2 sig0 = 1.0f / (1.0f + metal::exp(-g0));\nfloat2 sig1 = 1.0f / (1.0f + metal::exp(-g1));\nfloat2 sig2 = 1.0f / (1.0f + metal::exp(-g2));\nfloat2 sig3 = 1.0f / (1.0f + metal::exp(-g3));\n\n// SwiGLU computation\nfloat2 r0 = g0 * sig0 * u0;\nfloat2 r1 = g1 * sig1 * u1;\nfloat2 r2 = g2 * sig2 * u2;\nfloat2 r3 = g3 * sig3 * u3;\n\n// Store results\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y;\nout[idx+2] = (T)r1.x; out[idx+3] = (T)r1.y;\nout[idx+4] = (T)r2.x; out[idx+5] = (T)r2.y;\nout[idx+6] = (T)r3.x; out[idx+7] = (T)r3.y;",
    "gen3_6bb165b34655": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 4;\nif (idx >= N) return;\n\n// Load first pair\nfloat g0 = gate[idx];\nfloat u0 = up[idx];\n\n// Load second pair while computing first\nfloat g1 = gate[idx+1];\nfloat sig0 = 1.0f / (1.0f + metal::exp(-g0));\nfloat u1 = up[idx+1];\nfloat r0 = g0 * sig0 * u0;\n\n// Load third pair while computing second\nfloat g2 = gate[idx+2];\nfloat sig1 = 1.0f / (1.0f + metal::exp(-g1));\nfloat u2 = up[idx+2];\nfloat r1 = g1 * sig1 * u1;\n\n// Load fourth pair while computing third\nfloat g3 = gate[idx+3];\nfloat sig2 = 1.0f / (1.0f + metal::exp(-g2));\nfloat u3 = up[idx+3];\nfloat r2 = g2 * sig2 * u2;\n\n// Compute fourth while storing first\nout[idx] = (T)r0;\nfloat sig3 = 1.0f / (1.0f + metal::exp(-g3));\nout[idx+1] = (T)r1;\nfloat r3 = g3 * sig3 * u3;\n\n// Store remaining results\nout[idx+2] = (T)r2;\nout[idx+3] = (T)r3;",
    "gen4_dd79b7bce5f6": "constexpr uint N = 1536;\nuint simd_idx = thread_position_in_threadgroup.x;\nuint simd_base = thread_position_in_grid.x - simd_idx;\nuint elements_per_simd = 32;\n\nfor (uint base = simd_base * elements_per_simd; base < N; base += 32 * elements_per_simd) {\n    uint idx = base + simd_idx;\n    if (idx >= N) return;\n    \n    float g = (float)gate[idx];\n    float u = (float)up[idx];\n    \n    // Compute sigmoid with abs trick for stability\n    float abs_g = metal::abs(g);\n    float exp_val = metal::exp(-abs_g);\n    float sig_abs = 1.0f / (1.0f + exp_val);\n    float sig = (g >= 0.0f) ? sig_abs : (1.0f - sig_abs);\n    \n    out[idx] = (T)(g * sig * u);\n}",
    "gen4_f8604a6a25d1": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\nif (base_idx + 7 < N) {\n    // Fully vectorized path\n    float4 g0 = float4(gate[base_idx], gate[base_idx+1], gate[base_idx+2], gate[base_idx+3]);\n    float4 u0 = float4(up[base_idx], up[base_idx+1], up[base_idx+2], up[base_idx+3]);\n    float4 g1 = float4(gate[base_idx+4], gate[base_idx+5], gate[base_idx+6], gate[base_idx+7]);\n    float4 u1 = float4(up[base_idx+4], up[base_idx+5], up[base_idx+6], up[base_idx+7]);\n    \n    float4 exp0 = metal::exp(-g0);\n    float4 sig0 = 1.0f / (1.0f + exp0);\n    float4 result0 = g0 * sig0 * u0;\n    \n    float4 exp1 = metal::exp(-g1);\n    float4 sig1 = 1.0f / (1.0f + exp1);\n    float4 result1 = g1 * sig1 * u1;\n    \n    out[base_idx] = (T)result0.x;\n    out[base_idx+1] = (T)result0.y;\n    out[base_idx+2] = (T)result0.z;\n    out[base_idx+3] = (T)result0.w;\n    out[base_idx+4] = (T)result1.x;\n    out[base_idx+5] = (T)result1.y;\n    out[base_idx+6] = (T)result1.z;\n    out[base_idx+7] = (T)result1.w;\n} else {\n    // Scalar tail handling\n    #pragma unroll\n    for (uint i = 0; i < 8; i++) {\n        uint idx = base_idx + i;\n        if (idx >= N) return;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float exp_val = metal::exp(-g);\n        float sig = 1.0f / (1.0f + exp_val);\n        out[idx] = (T)(g * sig * u);\n    }\n}",
    "gen4_72851fc52324": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 16;\n\n// Prefetch first batch\nfloat g0 = (base_idx < N) ? (float)gate[base_idx] : 0.0f;\nfloat u0 = (base_idx < N) ? (float)up[base_idx] : 0.0f;\n\n#pragma unroll\nfor (uint i = 0; i < 16; i++) {\n    uint idx = base_idx + i;\n    if (idx >= N) return;\n    \n    // Prefetch next iteration\n    uint next_idx = idx + 1;\n    float g_next = (next_idx < N && i < 15) ? (float)gate[next_idx] : 0.0f;\n    float u_next = (next_idx < N && i < 15) ? (float)up[next_idx] : 0.0f;\n    \n    // Compute current\n    float exp_val = metal::exp(-g0);\n    float sig = 1.0f / (1.0f + exp_val);\n    out[idx] = (T)(g0 * sig * u0);\n    \n    // Swap buffers\n    g0 = g_next;\n    u0 = u_next;\n}",
    "gen4_02025d2c92bd": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\n#pragma unroll\nfor (uint i = 0; i < 8; i++) {\n    uint idx = base_idx + i;\n    if (idx >= N) return;\n    \n    float g_full = (float)gate[idx];\n    float u_full = (float)up[idx];\n    \n    // Use half precision for sigmoid computation\n    half g_h = half(g_full);\n    half exp_h = metal::exp(-g_h);\n    half sig_h = half(1.0f) / (half(1.0f) + exp_h);\n    \n    // Convert back to full precision for final multiply\n    float sig = float(sig_h);\n    out[idx] = (T)(g_full * sig * u_full);\n}",
    "gen5_c9e0f5899d32": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 16;\n\n// Prefetch all 16 gate values into registers\nfloat g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15;\nfloat u0, u1, u2, u3, u4, u5, u6, u7, u8, u9, u10, u11, u12, u13, u14, u15;\n\nif (base_idx < N) { g0 = (float)gate[base_idx]; u0 = (float)up[base_idx]; }\nif (base_idx + 1 < N) { g1 = (float)gate[base_idx + 1]; u1 = (float)up[base_idx + 1]; }\nif (base_idx + 2 < N) { g2 = (float)gate[base_idx + 2]; u2 = (float)up[base_idx + 2]; }\nif (base_idx + 3 < N) { g3 = (float)gate[base_idx + 3]; u3 = (float)up[base_idx + 3]; }\nif (base_idx + 4 < N) { g4 = (float)gate[base_idx + 4]; u4 = (float)up[base_idx + 4]; }\nif (base_idx + 5 < N) { g5 = (float)gate[base_idx + 5]; u5 = (float)up[base_idx + 5]; }\nif (base_idx + 6 < N) { g6 = (float)gate[base_idx + 6]; u6 = (float)up[base_idx + 6]; }\nif (base_idx + 7 < N) { g7 = (float)gate[base_idx + 7]; u7 = (float)up[base_idx + 7]; }\nif (base_idx + 8 < N) { g8 = (float)gate[base_idx + 8]; u8 = (float)up[base_idx + 8]; }\nif (base_idx + 9 < N) { g9 = (float)gate[base_idx + 9]; u9 = (float)up[base_idx + 9]; }\nif (base_idx + 10 < N) { g10 = (float)gate[base_idx + 10]; u10 = (float)up[base_idx + 10]; }\nif (base_idx + 11 < N) { g11 = (float)gate[base_idx + 11]; u11 = (float)up[base_idx + 11]; }\nif (base_idx + 12 < N) { g12 = (float)gate[base_idx + 12]; u12 = (float)up[base_idx + 12]; }\nif (base_idx + 13 < N) { g13 = (float)gate[base_idx + 13]; u13 = (float)up[base_idx + 13]; }\nif (base_idx + 14 < N) { g14 = (float)gate[base_idx + 14]; u14 = (float)up[base_idx + 14]; }\nif (base_idx + 15 < N) { g15 = (float)gate[base_idx + 15]; u15 = (float)up[base_idx + 15]; }\n\n// Compute all sigmoids with fast_exp and fused operations\nfloat s0 = g0 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g0));\nfloat s1 = g1 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g1));\nfloat s2 = g2 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g2));\nfloat s3 = g3 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g3));\nfloat s4 = g4 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g4));\nfloat s5 = g5 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g5));\nfloat s6 = g6 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g6));\nfloat s7 = g7 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g7));\nfloat s8 = g8 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g8));\nfloat s9 = g9 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g9));\nfloat s10 = g10 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g10));\nfloat s11 = g11 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g11));\nfloat s12 = g12 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g12));\nfloat s13 = g13 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g13));\nfloat s14 = g14 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g14));\nfloat s15 = g15 * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g15));\n\n// Final multiply with up values and write out\nif (base_idx < N) out[base_idx] = (T)(s0 * u0);\nif (base_idx + 1 < N) out[base_idx + 1] = (T)(s1 * u1);\nif (base_idx + 2 < N) out[base_idx + 2] = (T)(s2 * u2);\nif (base_idx + 3 < N) out[base_idx + 3] = (T)(s3 * u3);\nif (base_idx + 4 < N) out[base_idx + 4] = (T)(s4 * u4);\nif (base_idx + 5 < N) out[base_idx + 5] = (T)(s5 * u5);\nif (base_idx + 6 < N) out[base_idx + 6] = (T)(s6 * u6);\nif (base_idx + 7 < N) out[base_idx + 7] = (T)(s7 * u7);\nif (base_idx + 8 < N) out[base_idx + 8] = (T)(s8 * u8);\nif (base_idx + 9 < N) out[base_idx + 9] = (T)(s9 * u9);\nif (base_idx + 10 < N) out[base_idx + 10] = (T)(s10 * u10);\nif (base_idx + 11 < N) out[base_idx + 11] = (T)(s11 * u11);\nif (base_idx + 12 < N) out[base_idx + 12] = (T)(s12 * u12);\nif (base_idx + 13 < N) out[base_idx + 13] = (T)(s13 * u13);\nif (base_idx + 14 < N) out[base_idx + 14] = (T)(s14 * u14);\nif (base_idx + 15 < N) out[base_idx + 15] = (T)(s15 * u15);",
    "gen5_4ee8f74f7f50": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 12;\n\nif (base_idx + 11 >= N) {\n    // Scalar fallback for remainder\n    for (uint i = 0; i < 12 && base_idx + i < N; i++) {\n        uint idx = base_idx + i;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float sig = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g));\n        out[idx] = (T)(g * sig * u);\n    }\n    return;\n}\n\n// Load 4 float3 vectors (12 elements total)\nfloat3 g0 = float3((float)gate[base_idx], (float)gate[base_idx + 1], (float)gate[base_idx + 2]);\nfloat3 g1 = float3((float)gate[base_idx + 3], (float)gate[base_idx + 4], (float)gate[base_idx + 5]);\nfloat3 g2 = float3((float)gate[base_idx + 6], (float)gate[base_idx + 7], (float)gate[base_idx + 8]);\nfloat3 g3 = float3((float)gate[base_idx + 9], (float)gate[base_idx + 10], (float)gate[base_idx + 11]);\n\nfloat3 u0 = float3((float)up[base_idx], (float)up[base_idx + 1], (float)up[base_idx + 2]);\nfloat3 u1 = float3((float)up[base_idx + 3], (float)up[base_idx + 4], (float)up[base_idx + 5]);\nfloat3 u2 = float3((float)up[base_idx + 6], (float)up[base_idx + 7], (float)up[base_idx + 8]);\nfloat3 u3 = float3((float)up[base_idx + 9], (float)up[base_idx + 10], (float)up[base_idx + 11]);\n\n// Compute sigmoid and fused multiply\nfloat3 sig0 = 1.0f / (1.0f + metal::fast::exp(-g0));\nfloat3 sig1 = 1.0f / (1.0f + metal::fast::exp(-g1));\nfloat3 sig2 = 1.0f / (1.0f + metal::fast::exp(-g2));\nfloat3 sig3 = 1.0f / (1.0f + metal::fast::exp(-g3));\n\nfloat3 r0 = g0 * sig0 * u0;\nfloat3 r1 = g1 * sig1 * u1;\nfloat3 r2 = g2 * sig2 * u2;\nfloat3 r3 = g3 * sig3 * u3;\n\n// Store results\nout[base_idx] = (T)r0.x; out[base_idx + 1] = (T)r0.y; out[base_idx + 2] = (T)r0.z;\nout[base_idx + 3] = (T)r1.x; out[base_idx + 4] = (T)r1.y; out[base_idx + 5] = (T)r1.z;\nout[base_idx + 6] = (T)r2.x; out[base_idx + 7] = (T)r2.y; out[base_idx + 8] = (T)r2.z;\nout[base_idx + 9] = (T)r3.x; out[base_idx + 10] = (T)r3.y; out[base_idx + 11] = (T)r3.z;",
    "gen5_bcfe4498312f": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\nif (base_idx >= N) return;\n\n// First batch - load\nfloat g_curr[4], u_curr[4];\ng_curr[0] = (base_idx < N) ? (float)gate[base_idx] : 0.0f;\ng_curr[1] = (base_idx + 1 < N) ? (float)gate[base_idx + 1] : 0.0f;\ng_curr[2] = (base_idx + 2 < N) ? (float)gate[base_idx + 2] : 0.0f;\ng_curr[3] = (base_idx + 3 < N) ? (float)gate[base_idx + 3] : 0.0f;\n\nu_curr[0] = (base_idx < N) ? (float)up[base_idx] : 0.0f;\nu_curr[1] = (base_idx + 1 < N) ? (float)up[base_idx + 1] : 0.0f;\nu_curr[2] = (base_idx + 2 < N) ? (float)up[base_idx + 2] : 0.0f;\nu_curr[3] = (base_idx + 3 < N) ? (float)up[base_idx + 3] : 0.0f;\n\n// Second batch - prefetch while computing first\nfloat g_next[4], u_next[4];\ng_next[0] = (base_idx + 4 < N) ? (float)gate[base_idx + 4] : 0.0f;\ng_next[1] = (base_idx + 5 < N) ? (float)gate[base_idx + 5] : 0.0f;\ng_next[2] = (base_idx + 6 < N) ? (float)gate[base_idx + 6] : 0.0f;\ng_next[3] = (base_idx + 7 < N) ? (float)gate[base_idx + 7] : 0.0f;\n\n// Compute first batch\nfloat r0 = g_curr[0] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_curr[0])) * u_curr[0];\nfloat r1 = g_curr[1] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_curr[1])) * u_curr[1];\nfloat r2 = g_curr[2] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_curr[2])) * u_curr[2];\nfloat r3 = g_curr[3] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_curr[3])) * u_curr[3];\n\n// Load second batch up values while computing\nu_next[0] = (base_idx + 4 < N) ? (float)up[base_idx + 4] : 0.0f;\nu_next[1] = (base_idx + 5 < N) ? (float)up[base_idx + 5] : 0.0f;\nu_next[2] = (base_idx + 6 < N) ? (float)up[base_idx + 6] : 0.0f;\nu_next[3] = (base_idx + 7 < N) ? (float)up[base_idx + 7] : 0.0f;\n\n// Store first batch\nif (base_idx < N) out[base_idx] = (T)r0;\nif (base_idx + 1 < N) out[base_idx + 1] = (T)r1;\nif (base_idx + 2 < N) out[base_idx + 2] = (T)r2;\nif (base_idx + 3 < N) out[base_idx + 3] = (T)r3;\n\n// Compute and store second batch\nif (base_idx + 4 < N) {\n    float r4 = g_next[0] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_next[0])) * u_next[0];\n    out[base_idx + 4] = (T)r4;\n}\nif (base_idx + 5 < N) {\n    float r5 = g_next[1] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_next[1])) * u_next[1];\n    out[base_idx + 5] = (T)r5;\n}\nif (base_idx + 6 < N) {\n    float r6 = g_next[2] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_next[2])) * u_next[2];\n    out[base_idx + 6] = (T)r6;\n}\nif (base_idx + 7 < N) {\n    float r7 = g_next[3] * metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g_next[3])) * u_next[3];\n    out[base_idx + 7] = (T)r7;\n}",
    "gen5_5a1b14911781": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\nif (base_idx + 7 >= N) {\n    // Scalar fallback\n    for (uint i = 0; i < 8 && base_idx + i < N; i++) {\n        uint idx = base_idx + i;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float sig = 1.0f / (1.0f + metal::fast::exp(-g));\n        out[idx] = (T)(g * sig * u);\n    }\n    return;\n}\n\n// Load all 8 gate and up values\nfloat g0 = (float)gate[base_idx];\nfloat g1 = (float)gate[base_idx + 1];\nfloat g2 = (float)gate[base_idx + 2];\nfloat g3 = (float)gate[base_idx + 3];\nfloat g4 = (float)gate[base_idx + 4];\nfloat g5 = (float)gate[base_idx + 5];\nfloat g6 = (float)gate[base_idx + 6];\nfloat g7 = (float)gate[base_idx + 7];\n\nfloat u0 = (float)up[base_idx];\nfloat u1 = (float)up[base_idx + 1];\nfloat u2 = (float)up[base_idx + 2];\nfloat u3 = (float)up[base_idx + 3];\nfloat u4 = (float)up[base_idx + 4];\nfloat u5 = (float)up[base_idx + 5];\nfloat u6 = (float)up[base_idx + 6];\nfloat u7 = (float)up[base_idx + 7];\n\n// Compute all exp values in parallel\nfloat e0 = metal::fast::exp(-g0);\nfloat e1 = metal::fast::exp(-g1);\nfloat e2 = metal::fast::exp(-g2);\nfloat e3 = metal::fast::exp(-g3);\nfloat e4 = metal::fast::exp(-g4);\nfloat e5 = metal::fast::exp(-g5);\nfloat e6 = metal::fast::exp(-g6);\nfloat e7 = metal::fast::exp(-g7);\n\n// Compute denominators\nfloat d0 = 1.0f + e0;\nfloat d1 = 1.0f + e1;\nfloat d2 = 1.0f + e2;\nfloat d3 = 1.0f + e3;\nfloat d4 = 1.0f + e4;\nfloat d5 = 1.0f + e5;\nfloat d6 = 1.0f + e6;\nfloat d7 = 1.0f + e7;\n\n// Compute sigmoids using precise divide\nfloat s0 = metal::precise::divide(1.0f, d0);\nfloat s1 = metal::precise::divide(1.0f, d1);\nfloat s2 = metal::precise::divide(1.0f, d2);\nfloat s3 = metal::precise::divide(1.0f, d3);\nfloat s4 = metal::precise::divide(1.0f, d4);\nfloat s5 = metal::precise::divide(1.0f, d5);\nfloat s6 = metal::precise::divide(1.0f, d6);\nfloat s7 = metal::precise::divide(1.0f, d7);\n\n// Fused multiply: g * sig * u\nout[base_idx] = (T)(g0 * s0 * u0);\nout[base_idx + 1] = (T)(g1 * s1 * u1);\nout[base_idx + 2] = (T)(g2 * s2 * u2);\nout[base_idx + 3] = (T)(g3 * s3 * u3);\nout[base_idx + 4] = (T)(g4 * s4 * u4);\nout[base_idx + 5] = (T)(g5 * s5 * u5);\nout[base_idx + 6] = (T)(g6 * s6 * u6);\nout[base_idx + 7] = (T)(g7 * s7 * u7);",
    "gen6_7577377d7122": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 12;\n\nif (base_idx >= N) return;\n\n// Load batch\nfloat g[12], u[12];\n#pragma unroll\nfor (uint i = 0; i < 12; i++) {\n    uint idx = base_idx + i;\n    if (idx < N) {\n        g[i] = (float)gate[idx];\n        u[i] = (float)up[idx];\n    }\n}\n\n// Compute batch\nfloat res[12];\n#pragma unroll\nfor (uint i = 0; i < 12; i++) {\n    float exp_val = metal::exp(-g[i]);\n    float sig = 1.0f / (1.0f + exp_val);\n    res[i] = g[i] * sig * u[i];\n}\n\n// Store batch\n#pragma unroll\nfor (uint i = 0; i < 12; i++) {\n    uint idx = base_idx + i;\n    if (idx < N) {\n        out[idx] = (T)res[i];\n    }\n}",
    "gen6_8c161833e320": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 20;\n\n#pragma unroll\nfor (uint block = 0; block < 4; block++) {\n    uint offset = base_idx + block * 5;\n    \n    #pragma unroll\n    for (uint i = 0; i < 5; i++) {\n        uint idx = offset + i;\n        if (idx >= N) return;\n        \n        float g_val = (float)gate[idx];\n        float u_val = (float)up[idx];\n        \n        float exp_val = metal::exp(-g_val);\n        float sig = 1.0f / (1.0f + exp_val);\n        \n        out[idx] = (T)(g_val * sig * u_val);\n    }\n}",
    "gen6_0e04ec367479": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 24;\n\nif (base_idx >= N) return;\n\n// Triple-buffered load pattern\nfloat g0 = (float)gate[base_idx];\nfloat u0 = (float)up[base_idx];\nfloat g1 = (base_idx + 1 < N) ? (float)gate[base_idx + 1] : 0.0f;\nfloat u1 = (base_idx + 1 < N) ? (float)up[base_idx + 1] : 0.0f;\n\n#pragma unroll\nfor (uint i = 0; i < 24; i++) {\n    uint idx = base_idx + i;\n    if (idx >= N) return;\n    \n    // Prefetch two ahead\n    uint prefetch_idx = idx + 2;\n    float g2 = (prefetch_idx < N && i < 22) ? (float)gate[prefetch_idx] : 0.0f;\n    float u2 = (prefetch_idx < N && i < 22) ? (float)up[prefetch_idx] : 0.0f;\n    \n    // Compute with first buffer\n    float exp_val = metal::exp(-g0);\n    float sig = 1.0f / (1.0f + exp_val);\n    out[idx] = (T)(g0 * sig * u0);\n    \n    // Rotate buffers\n    g0 = g1; u0 = u1;\n    g1 = g2; u1 = u2;\n}",
    "gen6_fc9f9344b7d2": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 32;\n\nif (base_idx >= N) return;\n\n#pragma unroll 4\nfor (uint outer = 0; outer < 4; outer++) {\n    uint block_base = base_idx + outer * 8;\n    \n    // Load 8-element block\n    float g_block[8], u_block[8];\n    #pragma unroll\n    for (uint i = 0; i < 8; i++) {\n        uint idx = block_base + i;\n        bool valid = (idx < N);\n        g_block[i] = valid ? (float)gate[idx] : 0.0f;\n        u_block[i] = valid ? (float)up[idx] : 0.0f;\n    }\n    \n    // Compute and store 8-element block\n    #pragma unroll\n    for (uint i = 0; i < 8; i++) {\n        uint idx = block_base + i;\n        if (idx >= N) return;\n        \n        float exp_val = metal::exp(-g_block[i]);\n        float sig = 1.0f / (1.0f + exp_val);\n        out[idx] = (T)(g_block[i] * sig * u_block[i]);\n    }\n}",
    "gen7_f7fda877a68e": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 12;\nif (idx >= N) return;\n\n// Load 6 pairs (12 elements total)\nfloat2 g0 = float2(gate[idx], gate[idx+1]);\nfloat2 g1 = float2(gate[idx+2], gate[idx+3]);\nfloat2 g2 = float2(gate[idx+4], gate[idx+5]);\nfloat2 g3 = float2(gate[idx+6], gate[idx+7]);\nfloat2 g4 = float2(gate[idx+8], gate[idx+9]);\nfloat2 g5 = float2(gate[idx+10], gate[idx+11]);\n\nfloat2 u0 = float2(up[idx], up[idx+1]);\nfloat2 u1 = float2(up[idx+2], up[idx+3]);\nfloat2 u2 = float2(up[idx+4], up[idx+5]);\nfloat2 u3 = float2(up[idx+6], up[idx+7]);\nfloat2 u4 = float2(up[idx+8], up[idx+9]);\nfloat2 u5 = float2(up[idx+10], up[idx+11]);\n\n// Compute sigmoid for all pairs\nfloat2 sig0 = 1.0f / (1.0f + metal::exp(-g0));\nfloat2 sig1 = 1.0f / (1.0f + metal::exp(-g1));\nfloat2 sig2 = 1.0f / (1.0f + metal::exp(-g2));\nfloat2 sig3 = 1.0f / (1.0f + metal::exp(-g3));\nfloat2 sig4 = 1.0f / (1.0f + metal::exp(-g4));\nfloat2 sig5 = 1.0f / (1.0f + metal::exp(-g5));\n\n// SwiGLU computation\nfloat2 r0 = g0 * sig0 * u0;\nfloat2 r1 = g1 * sig1 * u1;\nfloat2 r2 = g2 * sig2 * u2;\nfloat2 r3 = g3 * sig3 * u3;\nfloat2 r4 = g4 * sig4 * u4;\nfloat2 r5 = g5 * sig5 * u5;\n\n// Store results\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y;\nout[idx+2] = (T)r1.x; out[idx+3] = (T)r1.y;\nout[idx+4] = (T)r2.x; out[idx+5] = (T)r2.y;\nout[idx+6] = (T)r3.x; out[idx+7] = (T)r3.y;\nout[idx+8] = (T)r4.x; out[idx+9] = (T)r4.y;\nout[idx+10] = (T)r5.x; out[idx+11] = (T)r5.y;",
    "gen7_95f040ff2f4c": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 10;\nif (idx >= N) return;\n\n// Prefetch first batch\nfloat g0 = gate[idx];\nfloat g1 = gate[idx+1];\nfloat u0 = up[idx];\nfloat u1 = up[idx+1];\n\n// Load and compute in batches\nfloat g2 = gate[idx+2];\nfloat g3 = gate[idx+3];\nfloat sig0 = 1.0f / (1.0f + metal::exp(-g0));\nfloat sig1 = 1.0f / (1.0f + metal::exp(-g1));\n\nfloat u2 = up[idx+2];\nfloat u3 = up[idx+3];\nfloat r0 = g0 * sig0 * u0;\nfloat r1 = g1 * sig1 * u1;\n\nfloat g4 = gate[idx+4];\nfloat g5 = gate[idx+5];\nfloat sig2 = 1.0f / (1.0f + metal::exp(-g2));\nfloat sig3 = 1.0f / (1.0f + metal::exp(-g3));\n\nfloat u4 = up[idx+4];\nfloat u5 = up[idx+5];\nfloat r2 = g2 * sig2 * u2;\nfloat r3 = g3 * sig3 * u3;\n\nfloat g6 = gate[idx+6];\nfloat g7 = gate[idx+7];\nfloat sig4 = 1.0f / (1.0f + metal::exp(-g4));\nfloat sig5 = 1.0f / (1.0f + metal::exp(-g5));\n\nfloat u6 = up[idx+6];\nfloat u7 = up[idx+7];\nfloat r4 = g4 * sig4 * u4;\nfloat r5 = g5 * sig5 * u5;\n\nfloat g8 = gate[idx+8];\nfloat g9 = gate[idx+9];\nfloat sig6 = 1.0f / (1.0f + metal::exp(-g6));\nfloat sig7 = 1.0f / (1.0f + metal::exp(-g7));\n\nfloat u8 = up[idx+8];\nfloat u9 = up[idx+9];\nfloat r6 = g6 * sig6 * u6;\nfloat r7 = g7 * sig7 * u7;\n\nfloat sig8 = 1.0f / (1.0f + metal::exp(-g8));\nfloat sig9 = 1.0f / (1.0f + metal::exp(-g9));\nfloat r8 = g8 * sig8 * u8;\nfloat r9 = g9 * sig9 * u9;\n\n// Store all results\nout[idx] = (T)r0; out[idx+1] = (T)r1;\nout[idx+2] = (T)r2; out[idx+3] = (T)r3;\nout[idx+4] = (T)r4; out[idx+5] = (T)r5;\nout[idx+6] = (T)r6; out[idx+7] = (T)r7;\nout[idx+8] = (T)r8; out[idx+9] = (T)r9;",
    "gen7_a29816f2305f": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 6;\nif (idx >= N) return;\n\n// Load float4 + float2\nfloat4 g_vec4 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat2 g_vec2 = float2(gate[idx+4], gate[idx+5]);\n\nfloat4 u_vec4 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat2 u_vec2 = float2(up[idx+4], up[idx+5]);\n\n// Compute sigmoid for float4\nfloat4 sig_vec4 = 1.0f / (1.0f + metal::exp(-g_vec4));\n\n// Compute sigmoid for float2\nfloat2 sig_vec2 = 1.0f / (1.0f + metal::exp(-g_vec2));\n\n// SwiGLU computation\nfloat4 r_vec4 = g_vec4 * sig_vec4 * u_vec4;\nfloat2 r_vec2 = g_vec2 * sig_vec2 * u_vec2;\n\n// Store results\nout[idx] = (T)r_vec4.x;\nout[idx+1] = (T)r_vec4.y;\nout[idx+2] = (T)r_vec4.z;\nout[idx+3] = (T)r_vec4.w;\nout[idx+4] = (T)r_vec2.x;\nout[idx+5] = (T)r_vec2.y;",
    "gen7_1f8d5ea4250d": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 8;\nif (idx >= N) return;\n\n// Process 4 pairs (8 elements total) with explicit unrolling\nfloat2 g0 = float2(gate[idx], gate[idx+1]);\nfloat2 g1 = float2(gate[idx+2], gate[idx+3]);\nfloat2 g2 = float2(gate[idx+4], gate[idx+5]);\nfloat2 g3 = float2(gate[idx+6], gate[idx+7]);\n\nfloat2 u0 = float2(up[idx], up[idx+1]);\nfloat2 u1 = float2(up[idx+2], up[idx+3]);\nfloat2 u2 = float2(up[idx+4], up[idx+5]);\nfloat2 u3 = float2(up[idx+6], up[idx+7]);\n\n// Compute sigmoid using fast approximation\nfloat2 sig0 = 1.0f / (1.0f + metal::fast::exp(-g0));\nfloat2 sig1 = 1.0f / (1.0f + metal::fast::exp(-g1));\nfloat2 sig2 = 1.0f / (1.0f + metal::fast::exp(-g2));\nfloat2 sig3 = 1.0f / (1.0f + metal::fast::exp(-g3));\n\n// SwiGLU computation\nfloat2 r0 = g0 * sig0 * u0;\nfloat2 r1 = g1 * sig1 * u1;\nfloat2 r2 = g2 * sig2 * u2;\nfloat2 r3 = g3 * sig3 * u3;\n\n// Store results\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y;\nout[idx+2] = (T)r1.x; out[idx+3] = (T)r1.y;\nout[idx+4] = (T)r2.x; out[idx+5] = (T)r2.y;\nout[idx+6] = (T)r3.x; out[idx+7] = (T)r3.y;",
    "gen8_4817124436f8": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 12;\nif (idx >= N) return;\n\n// Load 3x float4 = 12 elements with sequential pattern\nfloat4 g0 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 g1 = float4(gate[idx+4], gate[idx+5], gate[idx+6], gate[idx+7]);\nfloat4 g2 = (idx + 8 < N) ? float4(gate[idx+8], gate[idx+9], gate[idx+10], gate[idx+11]) : float4(0.0f);\n\nfloat4 u0 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat4 u1 = float4(up[idx+4], up[idx+5], up[idx+6], up[idx+7]);\nfloat4 u2 = (idx + 8 < N) ? float4(up[idx+8], up[idx+9], up[idx+10], up[idx+11]) : float4(0.0f);\n\n// Interleave exp computations to hide latency\nfloat4 exp0 = metal::exp(-g0);\nfloat4 exp1 = metal::exp(-g1);\nfloat4 sig0 = 1.0f / (1.0f + exp0);\nfloat4 exp2 = metal::exp(-g2);\nfloat4 sig1 = 1.0f / (1.0f + exp1);\nfloat4 sig2 = 1.0f / (1.0f + exp2);\n\n// Compute results with interleaved multiplies\nfloat4 r0 = g0 * sig0;\nr0 = r0 * u0;\nfloat4 r1 = g1 * sig1;\nr1 = r1 * u1;\nfloat4 r2 = g2 * sig2;\nr2 = r2 * u2;\n\n// Sequential stores for coalesced writes\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y; out[idx+2] = (T)r0.z; out[idx+3] = (T)r0.w;\nout[idx+4] = (T)r1.x; out[idx+5] = (T)r1.y; out[idx+6] = (T)r1.z; out[idx+7] = (T)r1.w;\nif (idx + 8 < N) {\n    out[idx+8] = (T)r2.x; out[idx+9] = (T)r2.y; out[idx+10] = (T)r2.z; out[idx+11] = (T)r2.w;\n}",
    "gen8_e5c3ac1e723b": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 16;\nif (idx >= N) return;\n\n// Phase 1: Process first 8 elements\nfloat4 g0 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 g1 = float4(gate[idx+4], gate[idx+5], gate[idx+6], gate[idx+7]);\nfloat4 u0 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat4 u1 = float4(up[idx+4], up[idx+5], up[idx+6], up[idx+7]);\n\nfloat4 sig0 = 1.0f / (1.0f + metal::exp(-g0));\nfloat4 sig1 = 1.0f / (1.0f + metal::exp(-g1));\nfloat4 r0 = g0 * sig0 * u0;\nfloat4 r1 = g1 * sig1 * u1;\n\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y; out[idx+2] = (T)r0.z; out[idx+3] = (T)r0.w;\nout[idx+4] = (T)r1.x; out[idx+5] = (T)r1.y; out[idx+6] = (T)r1.z; out[idx+7] = (T)r1.w;\n\n// Phase 2: Reuse registers for second 8 elements\nif (idx + 8 < N) {\n    g0 = float4(gate[idx+8], gate[idx+9], gate[idx+10], gate[idx+11]);\n    g1 = (idx + 12 < N) ? float4(gate[idx+12], gate[idx+13], gate[idx+14], gate[idx+15]) : float4(0.0f);\n    u0 = float4(up[idx+8], up[idx+9], up[idx+10], up[idx+11]);\n    u1 = (idx + 12 < N) ? float4(up[idx+12], up[idx+13], up[idx+14], up[idx+15]) : float4(0.0f);\n    \n    sig0 = 1.0f / (1.0f + metal::exp(-g0));\n    sig1 = 1.0f / (1.0f + metal::exp(-g1));\n    r0 = g0 * sig0 * u0;\n    r1 = g1 * sig1 * u1;\n    \n    out[idx+8] = (T)r0.x; out[idx+9] = (T)r0.y; out[idx+10] = (T)r0.z; out[idx+11] = (T)r0.w;\n    if (idx + 12 < N) {\n        out[idx+12] = (T)r1.x; out[idx+13] = (T)r1.y; out[idx+14] = (T)r1.z; out[idx+15] = (T)r1.w;\n    }\n}",
    "gen8_15edf4f24d9a": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 4;\nif (idx >= N) return;\n\n// Single float4 load per array - perfectly coalesced\nfloat4 g = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 u = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\n\n// Compute sigmoid with fused operations\nfloat4 exp_neg = metal::exp(-g);\nfloat4 sig = 1.0f / (1.0f + exp_neg);\n\n// Final result in one step\nfloat4 result = g * sig * u;\n\n// Coalesced stores\nout[idx] = (T)result.x;\nout[idx+1] = (T)result.y;\nout[idx+2] = (T)result.z;\nout[idx+3] = (T)result.w;",
    "gen8_bcd467625989": "constexpr uint N = 1536;\nuint idx = thread_position_in_grid.x * 16;\nif (idx >= N) return;\n\n// Load first batch as vectors\nfloat4 g0 = float4(gate[idx], gate[idx+1], gate[idx+2], gate[idx+3]);\nfloat4 u0 = float4(up[idx], up[idx+1], up[idx+2], up[idx+3]);\nfloat4 exp0 = metal::exp(-g0);\n\n// Load second batch while first exp completes\nfloat4 g1 = float4(gate[idx+4], gate[idx+5], gate[idx+6], gate[idx+7]);\nfloat4 u1 = float4(up[idx+4], up[idx+5], up[idx+6], up[idx+7]);\nfloat4 sig0 = 1.0f / (1.0f + exp0);\nfloat4 exp1 = metal::exp(-g1);\n\n// Continue pattern for third batch\nfloat4 g2 = (idx+8 < N) ? float4(gate[idx+8], gate[idx+9], gate[idx+10], gate[idx+11]) : float4(0.0f);\nfloat4 u2 = (idx+8 < N) ? float4(up[idx+8], up[idx+9], up[idx+10], up[idx+11]) : float4(0.0f);\nfloat4 r0 = g0 * sig0 * u0;\nfloat4 sig1 = 1.0f / (1.0f + exp1);\nfloat4 exp2 = metal::exp(-g2);\n\n// Fourth batch\nfloat4 g3 = (idx+12 < N) ? float4(gate[idx+12], gate[idx+13], gate[idx+14], gate[idx+15]) : float4(0.0f);\nfloat4 u3 = (idx+12 < N) ? float4(up[idx+12], up[idx+13], up[idx+14], up[idx+15]) : float4(0.0f);\nfloat4 r1 = g1 * sig1 * u1;\nfloat4 sig2 = 1.0f / (1.0f + exp2);\nfloat4 exp3 = metal::exp(-g3);\n\n// Complete computations\nfloat4 r2 = g2 * sig2 * u2;\nfloat4 sig3 = 1.0f / (1.0f + exp3);\nfloat4 r3 = g3 * sig3 * u3;\n\n// Store all results\nout[idx] = (T)r0.x; out[idx+1] = (T)r0.y; out[idx+2] = (T)r0.z; out[idx+3] = (T)r0.w;\nout[idx+4] = (T)r1.x; out[idx+5] = (T)r1.y; out[idx+6] = (T)r1.z; out[idx+7] = (T)r1.w;\nif (idx+8 < N) {\n    out[idx+8] = (T)r2.x; out[idx+9] = (T)r2.y; out[idx+10] = (T)r2.z; out[idx+11] = (T)r2.w;\n    if (idx+12 < N) {\n        out[idx+12] = (T)r3.x; out[idx+13] = (T)r3.y; out[idx+14] = (T)r3.z; out[idx+15] = (T)r3.w;\n    }\n}",
    "gen9_ea6ab2df8bc7": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\nif (base_idx + 7 >= N) {\n    for (uint i = 0; i < 8 && base_idx + i < N; i++) {\n        uint idx = base_idx + i;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float sig = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g));\n        out[idx] = (T)metal::fma(g * sig, u, 0.0f);\n    }\n    return;\n}\n\nfloat g0 = (float)gate[base_idx];\nfloat g1 = (float)gate[base_idx + 1];\nfloat g2 = (float)gate[base_idx + 2];\nfloat g3 = (float)gate[base_idx + 3];\nfloat g4 = (float)gate[base_idx + 4];\nfloat g5 = (float)gate[base_idx + 5];\nfloat g6 = (float)gate[base_idx + 6];\nfloat g7 = (float)gate[base_idx + 7];\n\nfloat u0 = (float)up[base_idx];\nfloat u1 = (float)up[base_idx + 1];\nfloat u2 = (float)up[base_idx + 2];\nfloat u3 = (float)up[base_idx + 3];\nfloat u4 = (float)up[base_idx + 4];\nfloat u5 = (float)up[base_idx + 5];\nfloat u6 = (float)up[base_idx + 6];\nfloat u7 = (float)up[base_idx + 7];\n\n// Compute reciprocals with fast path\nfloat s0 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g0));\nfloat s1 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g1));\nfloat s2 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g2));\nfloat s3 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g3));\nfloat s4 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g4));\nfloat s5 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g5));\nfloat s6 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g6));\nfloat s7 = metal::fast::divide(1.0f, 1.0f + metal::fast::exp(-g7));\n\n// FMA-optimized final multiply: fma(g*s, u, 0)\nout[base_idx] = (T)metal::fma(g0 * s0, u0, 0.0f);\nout[base_idx + 1] = (T)metal::fma(g1 * s1, u1, 0.0f);\nout[base_idx + 2] = (T)metal::fma(g2 * s2, u2, 0.0f);\nout[base_idx + 3] = (T)metal::fma(g3 * s3, u3, 0.0f);\nout[base_idx + 4] = (T)metal::fma(g4 * s4, u4, 0.0f);\nout[base_idx + 5] = (T)metal::fma(g5 * s5, u5, 0.0f);\nout[base_idx + 6] = (T)metal::fma(g6 * s6, u6, 0.0f);\nout[base_idx + 7] = (T)metal::fma(g7 * s7, u7, 0.0f);",
    "gen9_76ffc0830b76": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 12;\n\nif (base_idx >= N) return;\n\n// Prefetch first 4 elements\nfloat g0 = base_idx < N ? (float)gate[base_idx] : 0.0f;\nfloat u0 = base_idx < N ? (float)up[base_idx] : 0.0f;\nfloat g1 = base_idx + 1 < N ? (float)gate[base_idx + 1] : 0.0f;\nfloat u1 = base_idx + 1 < N ? (float)up[base_idx + 1] : 0.0f;\nfloat g2 = base_idx + 2 < N ? (float)gate[base_idx + 2] : 0.0f;\nfloat u2 = base_idx + 2 < N ? (float)up[base_idx + 2] : 0.0f;\nfloat g3 = base_idx + 3 < N ? (float)gate[base_idx + 3] : 0.0f;\nfloat u3 = base_idx + 3 < N ? (float)up[base_idx + 3] : 0.0f;\n\n// Compute first 4 while prefetching next 4\nfloat e0 = metal::fast::exp(-g0);\nfloat e1 = metal::fast::exp(-g1);\nfloat g4 = base_idx + 4 < N ? (float)gate[base_idx + 4] : 0.0f;\nfloat u4 = base_idx + 4 < N ? (float)up[base_idx + 4] : 0.0f;\nfloat e2 = metal::fast::exp(-g2);\nfloat e3 = metal::fast::exp(-g3);\nfloat g5 = base_idx + 5 < N ? (float)gate[base_idx + 5] : 0.0f;\nfloat u5 = base_idx + 5 < N ? (float)up[base_idx + 5] : 0.0f;\n\nfloat s0 = 1.0f / (1.0f + e0);\nfloat s1 = 1.0f / (1.0f + e1);\nfloat g6 = base_idx + 6 < N ? (float)gate[base_idx + 6] : 0.0f;\nfloat u6 = base_idx + 6 < N ? (float)up[base_idx + 6] : 0.0f;\nfloat s2 = 1.0f / (1.0f + e2);\nfloat s3 = 1.0f / (1.0f + e3);\nfloat g7 = base_idx + 7 < N ? (float)gate[base_idx + 7] : 0.0f;\nfloat u7 = base_idx + 7 < N ? (float)up[base_idx + 7] : 0.0f;\n\n// Store first 4 while computing next 4\nif (base_idx < N) out[base_idx] = (T)(g0 * s0 * u0);\nfloat e4 = metal::fast::exp(-g4);\nif (base_idx + 1 < N) out[base_idx + 1] = (T)(g1 * s1 * u1);\nfloat e5 = metal::fast::exp(-g5);\nif (base_idx + 2 < N) out[base_idx + 2] = (T)(g2 * s2 * u2);\nfloat e6 = metal::fast::exp(-g6);\nif (base_idx + 3 < N) out[base_idx + 3] = (T)(g3 * s3 * u3);\nfloat e7 = metal::fast::exp(-g7);\n\nfloat s4 = 1.0f / (1.0f + e4);\nfloat g8 = base_idx + 8 < N ? (float)gate[base_idx + 8] : 0.0f;\nfloat s5 = 1.0f / (1.0f + e5);\nfloat u8 = base_idx + 8 < N ? (float)up[base_idx + 8] : 0.0f;\nfloat s6 = 1.0f / (1.0f + e6);\nfloat g9 = base_idx + 9 < N ? (float)gate[base_idx + 9] : 0.0f;\nfloat s7 = 1.0f / (1.0f + e7);\nfloat u9 = base_idx + 9 < N ? (float)up[base_idx + 9] : 0.0f;\n\n// Store middle 4 while loading last 4\nif (base_idx + 4 < N) out[base_idx + 4] = (T)(g4 * s4 * u4);\nfloat g10 = base_idx + 10 < N ? (float)gate[base_idx + 10] : 0.0f;\nif (base_idx + 5 < N) out[base_idx + 5] = (T)(g5 * s5 * u5);\nfloat u10 = base_idx + 10 < N ? (float)up[base_idx + 10] : 0.0f;\nif (base_idx + 6 < N) out[base_idx + 6] = (T)(g6 * s6 * u6);\nfloat g11 = base_idx + 11 < N ? (float)gate[base_idx + 11] : 0.0f;\nif (base_idx + 7 < N) out[base_idx + 7] = (T)(g7 * s7 * u7);\nfloat u11 = base_idx + 11 < N ? (float)up[base_idx + 11] : 0.0f;\n\n// Compute and store last 4\nfloat e8 = metal::fast::exp(-g8);\nfloat e9 = metal::fast::exp(-g9);\nfloat e10 = metal::fast::exp(-g10);\nfloat e11 = metal::fast::exp(-g11);\n\nfloat s8 = 1.0f / (1.0f + e8);\nfloat s9 = 1.0f / (1.0f + e9);\nfloat s10 = 1.0f / (1.0f + e10);\nfloat s11 = 1.0f / (1.0f + e11);\n\nif (base_idx + 8 < N) out[base_idx + 8] = (T)(g8 * s8 * u8);\nif (base_idx + 9 < N) out[base_idx + 9] = (T)(g9 * s9 * u9);\nif (base_idx + 10 < N) out[base_idx + 10] = (T)(g10 * s10 * u10);\nif (base_idx + 11 < N) out[base_idx + 11] = (T)(g11 * s11 * u11);",
    "gen9_b92f3341cea2": "constexpr uint N = 1536;\nuint tid = thread_position_in_grid.x;\nuint lane_id = tid % 32;\nuint warp_base = (tid / 32) * 32 * 8;\nuint idx = warp_base + lane_id;\n\n// Each warp processes 256 elements (32 threads \u00d7 8 elements)\n#pragma unroll\nfor (uint i = 0; i < 8; i++) {\n    uint offset = i * 32;\n    uint global_idx = idx + offset;\n    \n    if (global_idx < N) {\n        float g = (float)gate[global_idx];\n        float u = (float)up[global_idx];\n        \n        // Compute with warp-synchronized pattern\n        float neg_g = -g;\n        float exp_val = metal::fast::exp(neg_g);\n        float denom = 1.0f + exp_val;\n        float sig = 1.0f / denom;\n        float result = g * sig * u;\n        \n        out[global_idx] = (T)result;\n    }\n}",
    "gen9_99c220809a01": "constexpr uint N = 1536;\nuint base_idx = thread_position_in_grid.x * 8;\n\nif (base_idx + 7 >= N) {\n    for (uint i = 0; i < 8 && base_idx + i < N; i++) {\n        uint idx = base_idx + i;\n        float g = (float)gate[idx];\n        float u = (float)up[idx];\n        float sig = 1.0f / (1.0f + metal::fast::exp(-g));\n        out[idx] = (T)(g * sig * u);\n    }\n    return;\n}\n\n// Load all in reverse order to optimize cache line fetch\nfloat u7 = (float)up[base_idx + 7];\nfloat g7 = (float)gate[base_idx + 7];\nfloat u6 = (float)up[base_idx + 6];\nfloat g6 = (float)gate[base_idx + 6];\nfloat u5 = (float)up[base_idx + 5];\nfloat g5 = (float)gate[base_idx + 5];\nfloat u4 = (float)up[base_idx + 4];\nfloat g4 = (float)gate[base_idx + 4];\nfloat u3 = (float)up[base_idx + 3];\nfloat g3 = (float)gate[base_idx + 3];\nfloat u2 = (float)up[base_idx + 2];\nfloat g2 = (float)gate[base_idx + 2];\nfloat u1 = (float)up[base_idx + 1];\nfloat g1 = (float)gate[base_idx + 1];\nfloat u0 = (float)up[base_idx];\nfloat g0 = (float)gate[base_idx];\n\n// Compute all sigmoids in parallel\nfloat s0 = 1.0f / (1.0f + metal::fast::exp(-g0));\nfloat s1 = 1.0f / (1.0f + metal::fast::exp(-g1));\nfloat s2 = 1.0f / (1.0f + metal::fast::exp(-g2));\nfloat s3 = 1.0f / (1.0f + metal::fast::exp(-g3));\nfloat s4 = 1.0f / (1.0f + metal::fast::exp(-g4));\nfloat s5 = 1.0f / (1.0f + metal::fast::exp(-g5));\nfloat s6 = 1.0f / (1.0f + metal::fast::exp(-g6));\nfloat s7 = 1.0f / (1.0f + metal::fast::exp(-g7));\n\n// Compute all products\nfloat r0 = g0 * s0 * u0;\nfloat r1 = g1 * s1 * u1;\nfloat r2 = g2 * s2 * u2;\nfloat r3 = g3 * s3 * u3;\nfloat r4 = g4 * s4 * u4;\nfloat r5 = g5 * s5 * u5;\nfloat r6 = g6 * s6 * u6;\nfloat r7 = g7 * s7 * u7;\n\n// Store in reverse order for write combining\nout[base_idx + 7] = (T)r7;\nout[base_idx + 6] = (T)r6;\nout[base_idx + 5] = (T)r5;\nout[base_idx + 4] = (T)r4;\nout[base_idx + 3] = (T)r3;\nout[base_idx + 2] = (T)r2;\nout[base_idx + 1] = (T)r1;\nout[base_idx] = (T)r0;",
    "gen10_7a3b9c3fa6db": "constexpr uint N = 1536;\nuint tid = thread_position_in_threadgroup.x;\nuint gid = thread_position_in_grid.x;\nconst uint ELEMS_PER_THREAD = 8;\nconst uint THREADS = 128;\n\nthreadgroup float s_gate[THREADS * ELEMS_PER_THREAD];\nthreadgroup float s_up[THREADS * ELEMS_PER_THREAD];\n\n// Coalesced load into threadgroup memory\nfor (uint i = 0; i < ELEMS_PER_THREAD; i++) {\n    uint idx = gid * ELEMS_PER_THREAD + i;\n    if (idx < N) {\n        s_gate[tid * ELEMS_PER_THREAD + i] = (float)gate[idx];\n        s_up[tid * ELEMS_PER_THREAD + i] = (float)up[idx];\n    }\n}\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\n// Compute from threadgroup memory\nfor (uint i = 0; i < ELEMS_PER_THREAD; i++) {\n    uint idx = gid * ELEMS_PER_THREAD + i;\n    if (idx < N) {\n        float g = s_gate[tid * ELEMS_PER_THREAD + i];\n        float u = s_up[tid * ELEMS_PER_THREAD + i];\n        \n        float abs_g = metal::abs(g);\n        float exp_val = metal::exp(-abs_g);\n        float sig_abs = 1.0f / (1.0f + exp_val);\n        float sig = (g >= 0.0f) ? sig_abs : (1.0f - sig_abs);\n        \n        out[idx] = (T)(g * sig * u);\n    }\n}",
    "gen10_6ac03140fadf": "constexpr uint N = 1536;\nuint tid = thread_position_in_grid.x;\nconst uint STRIDE = 48;\n\n// Process 32 strided elements to maximize cache reuse\nfloat g0, g1, g2, g3, g4, g5, g6, g7;\nfloat u0, u1, u2, u3, u4, u5, u6, u7;\nfloat r0, r1, r2, r3, r4, r5, r6, r7;\n\n#pragma unroll\nfor (uint batch = 0; batch < 4; batch++) {\n    uint idx0 = tid + (batch * 8 + 0) * STRIDE;\n    uint idx1 = tid + (batch * 8 + 1) * STRIDE;\n    uint idx2 = tid + (batch * 8 + 2) * STRIDE;\n    uint idx3 = tid + (batch * 8 + 3) * STRIDE;\n    uint idx4 = tid + (batch * 8 + 4) * STRIDE;\n    uint idx5 = tid + (batch * 8 + 5) * STRIDE;\n    uint idx6 = tid + (batch * 8 + 6) * STRIDE;\n    uint idx7 = tid + (batch * 8 + 7) * STRIDE;\n    \n    if (idx0 < N) { g0 = (float)gate[idx0]; u0 = (float)up[idx0]; }\n    if (idx1 < N) { g1 = (float)gate[idx1]; u1 = (float)up[idx1]; }\n    if (idx2 < N) { g2 = (float)gate[idx2]; u2 = (float)up[idx2]; }\n    if (idx3 < N) { g3 = (float)gate[idx3]; u3 = (float)up[idx3]; }\n    if (idx4 < N) { g4 = (float)gate[idx4]; u4 = (float)up[idx4]; }\n    if (idx5 < N) { g5 = (float)gate[idx5]; u5 = (float)up[idx5]; }\n    if (idx6 < N) { g6 = (float)gate[idx6]; u6 = (float)up[idx6]; }\n    if (idx7 < N) { g7 = (float)gate[idx7]; u7 = (float)up[idx7]; }\n    \n    // Parallel sigmoid computation\n    float a0 = metal::abs(g0); float e0 = metal::exp(-a0); float s0 = 1.0f / (1.0f + e0); r0 = g0 * ((g0 >= 0) ? s0 : (1.0f - s0)) * u0;\n    float a1 = metal::abs(g1); float e1 = metal::exp(-a1); float s1 = 1.0f / (1.0f + e1); r1 = g1 * ((g1 >= 0) ? s1 : (1.0f - s1)) * u1;\n    float a2 = metal::abs(g2); float e2 = metal::exp(-a2); float s2 = 1.0f / (1.0f + e2); r2 = g2 * ((g2 >= 0) ? s2 : (1.0f - s2)) * u2;\n    float a3 = metal::abs(g3); float e3 = metal::exp(-a3); float s3 = 1.0f / (1.0f + e3); r3 = g3 * ((g3 >= 0) ? s3 : (1.0f - s3)) * u3;\n    float a4 = metal::abs(g4); float e4 = metal::exp(-a4); float s4 = 1.0f / (1.0f + e4); r4 = g4 * ((g4 >= 0) ? s4 : (1.0f - s4)) * u4;\n    float a5 = metal::abs(g5); float e5 = metal::exp(-a5); float s5 = 1.0f / (1.0f + e5); r5 = g5 * ((g5 >= 0) ? s5 : (1.0f - s5)) * u5;\n    float a6 = metal::abs(g6); float e6 = metal::exp(-a6); float s6 = 1.0f / (1.0f + e6); r6 = g6 * ((g6 >= 0) ? s6 : (1.0f - s6)) * u6;\n    float a7 = metal::abs(g7); float e7 = metal::exp(-a7); float s7 = 1.0f / (1.0f + e7); r7 = g7 * ((g7 >= 0) ? s7 : (1.0f - s7)) * u7;\n    \n    if (idx0 < N) out[idx0] = (T)r0;\n    if (idx1 < N) out[idx1] = (T)r1;\n    if (idx2 < N) out[idx2] = (T)r2;\n    if (idx3 < N) out[idx3] = (T)r3;\n    if (idx4 < N) out[idx4] = (T)r4;\n    if (idx5 < N) out[idx5] = (T)r5;\n    if (idx6 < N) out[idx6] = (T)r6;\n    if (idx7 < N) out[idx7] = (T)r7;\n}",
    "gen10_29ad1a7654df": "constexpr uint N = 1536;\nuint gid = thread_position_in_grid.x;\nconst uint ELEMS = 16;\nuint base = gid * ELEMS;\n\nif (base >= N) return;\n\n// Pipeline stage 1: Load first 4\nfloat g0 = (base + 0 < N) ? (float)gate[base + 0] : 0.0f;\nfloat g1 = (base + 1 < N) ? (float)gate[base + 1] : 0.0f;\nfloat g2 = (base + 2 < N) ? (float)gate[base + 2] : 0.0f;\nfloat g3 = (base + 3 < N) ? (float)gate[base + 3] : 0.0f;\nfloat u0 = (base + 0 < N) ? (float)up[base + 0] : 0.0f;\nfloat u1 = (base + 1 < N) ? (float)up[base + 1] : 0.0f;\nfloat u2 = (base + 2 < N) ? (float)up[base + 2] : 0.0f;\nfloat u3 = (base + 3 < N) ? (float)up[base + 3] : 0.0f;\n\n// Compute first batch while loading next\nfloat a0 = metal::abs(g0), e0 = metal::exp(-a0), s0 = 1.0f / (1.0f + e0);\nfloat a1 = metal::abs(g1), e1 = metal::exp(-a1), s1 = 1.0f / (1.0f + e1);\nfloat g4 = (base + 4 < N) ? (float)gate[base + 4] : 0.0f;\nfloat g5 = (base + 5 < N) ? (float)gate[base + 5] : 0.0f;\nfloat a2 = metal::abs(g2), e2 = metal::exp(-a2), s2 = 1.0f / (1.0f + e2);\nfloat a3 = metal::abs(g3), e3 = metal::exp(-a3), s3 = 1.0f / (1.0f + e3);\nfloat u4 = (base + 4 < N) ? (float)up[base + 4] : 0.0f;\nfloat u5 = (base + 5 < N) ? (float)up[base + 5] : 0.0f;\n\nfloat r0 = g0 * ((g0 >= 0) ? s0 : (1.0f - s0)) * u0;\nfloat r1 = g1 * ((g1 >= 0) ? s1 : (1.0f - s1)) * u1;\nfloat g6 = (base + 6 < N) ? (float)gate[base + 6] : 0.0f;\nfloat g7 = (base + 7 < N) ? (float)gate[base + 7] : 0.0f;\nfloat r2 = g2 * ((g2 >= 0) ? s2 : (1.0f - s2)) * u2;\nfloat r3 = g3 * ((g3 >= 0) ? s3 : (1.0f - s3)) * u3;\nfloat u6 = (base + 6 < N) ? (float)up[base + 6] : 0.0f;\nfloat u7 = (base + 7 < N) ? (float)up[base + 7] : 0.0f;\n\n// Second batch\nfloat a4 = metal::abs(g4), e4 = metal::exp(-a4), s4 = 1.0f / (1.0f + e4);\nfloat a5 = metal::abs(g5), e5 = metal::exp(-a5), s5 = 1.0f / (1.0f + e5);\nfloat g8 = (base + 8 < N) ? (float)gate[base + 8] : 0.0f;\nfloat g9 = (base + 9 < N) ? (float)gate[base + 9] : 0.0f;\nfloat a6 = metal::abs(g6), e6 = metal::exp(-a6), s6 = 1.0f / (1.0f + e6);\nfloat a7 = metal::abs(g7), e7 = metal::exp(-a7), s7 = 1.0f / (1.0f + e7);\nfloat u8 = (base + 8 < N) ? (float)up[base + 8] : 0.0f;\nfloat u9 = (base + 9 < N) ? (float)up[base + 9] : 0.0f;\n\nfloat r4 = g4 * ((g4 >= 0) ? s4 : (1.0f - s4)) * u4;\nfloat r5 = g5 * ((g5 >= 0) ? s5 : (1.0f - s5)) * u5;\nfloat g10 = (base + 10 < N) ? (float)gate[base + 10] : 0.0f;\nfloat g11 = (base + 11 < N) ? (float)gate[base + 11] : 0.0f;\nfloat r6 = g6 * ((g6 >= 0) ? s6 : (1.0f - s6)) * u6;\nfloat r7 = g7 * ((g7 >= 0) ? s7 : (1.0f - s7)) * u7;\nfloat u10 = (base + 10 < N) ? (float)up[base + 10] : 0.0f;\nfloat u11 = (base + 11 < N) ? (float)up[base + 11] : 0.0f;\n\n// Third batch\nfloat a8 = metal::abs(g8), e8 = metal::exp(-a8), s8 = 1.0f / (1.0f + e8);\nfloat a9 = metal::abs(g9), e9 = metal::exp(-a9), s9 = 1.0f / (1.0f + e9);\nfloat g12 = (base + 12 < N) ? (float)gate[base + 12] : 0.0f;\nfloat g13 = (base + 13 < N) ? (float)gate[base + 13] : 0.0f;\nfloat a10 = metal::abs(g10), e10 = metal::exp(-a10), s10 = 1.0f / (1.0f + e10);\nfloat a11 = metal::abs(g11), e11 = metal::exp(-a11), s11 = 1.0f / (1.0f + e11);\nfloat u12 = (base + 12 < N) ? (float)up[base + 12] : 0.0f;\nfloat u13 = (base + 13 < N) ? (float)up[base + 13] : 0.0f;\n\nfloat r8 = g8 * ((g8 >= 0) ? s8 : (1.0f - s8)) * u8;\nfloat r9 = g9 * ((g9 >= 0) ? s9 : (1.0f - s9)) * u9;\nfloat g14 = (base + 14 < N) ? (float)gate[base + 14] : 0.0f;\nfloat g15 = (base + 15 < N) ? (float)gate[base + 15] : 0.0f;\nfloat r10 = g10 * ((g10 >= 0) ? s10 : (1.0f - s10)) * u10;\nfloat r11 = g11 * ((g11 >= 0) ? s11 : (1.0f - s11)) * u11;\nfloat u14 = (base + 14 < N) ? (float)up[base + 14] : 0.0f;\nfloat u15 = (base + 15 < N) ? (float)up[base + 15] : 0.0f;\n\n// Fourth batch\nfloat a12 = metal::abs(g12), e12 = metal::exp(-a12), s12 = 1.0f / (1.0f + e12);\nfloat a13 = metal::abs(g13), e13 = metal::exp(-a13), s13 = 1.0f / (1.0f + e13);\nfloat a14 = metal::abs(g14), e14 = metal::exp(-a14), s14 = 1.0f / (1.0f + e14);\nfloat a15 = metal::abs(g15), e15 = metal::exp(-a15), s15 = 1.0f / (1.0f + e15);\n\nfloat r12 = g12 * ((g12 >= 0) ? s12 : (1.0f - s12)) * u12;\nfloat r13 = g13 * ((g13 >= 0) ? s13 : (1.0f - s13)) * u13;\nfloat r14 = g14 * ((g14 >= 0) ? s14 : (1.0f - s14)) * u14;\nfloat r15 = g15 * ((g15 >= 0) ? s15 : (1.0f - s15)) * u15;\n\n// Coalesced stores\nif (base + 0 < N) out[base + 0] = (T)r0;\nif (base + 1 < N) out[base + 1] = (T)r1;\nif (base + 2 < N) out[base + 2] = (T)r2;\nif (base + 3 < N) out[base + 3] = (T)r3;\nif (base + 4 < N) out[base + 4] = (T)r4;\nif (base + 5 < N) out[base + 5] = (T)r5;\nif (base + 6 < N) out[base + 6] = (T)r6;\nif (base + 7 < N) out[base + 7] = (T)r7;\nif (base + 8 < N) out[base + 8] = (T)r8;\nif (base + 9 < N) out[base + 9] = (T)r9;\nif (base + 10 < N) out[base + 10] = (T)r10;\nif (base + 11 < N) out[base + 11] = (T)r11;\nif (base + 12 < N) out[base + 12] = (T)r12;\nif (base + 13 < N) out[base + 13] = (T)r13;\nif (base + 14 < N) out[base + 14] = (T)r14;\nif (base + 15 < N) out[base + 15] = (T)r15;",
    "gen10_a96408771138": "constexpr uint N = 1536;\nuint gid = thread_position_in_grid.x;\nconst uint ELEMS = 12;\nuint base = gid * ELEMS;\n\n#pragma unroll\nfor (uint i = 0; i < ELEMS; i++) {\n    uint idx = base + i;\n    if (idx >= N) return;\n    \n    float g = (float)gate[idx];\n    float u = (float)up[idx];\n    \n    // Optimized sigmoid: use rcp for division\n    float abs_g = metal::abs(g);\n    float neg_abs = -abs_g;\n    float exp_val = metal::exp(neg_abs);\n    float one_plus_exp = metal::fma(exp_val, 1.0f, 1.0f);\n    float sig_abs = metal::precise::divide(1.0f, one_plus_exp);\n    \n    // Branch-free sign correction\n    float sign_mask = (g >= 0.0f) ? 1.0f : -1.0f;\n    float sig = metal::fma(sign_mask, sig_abs, (sign_mask < 0.0f) ? 1.0f : 0.0f);\n    \n    // Fused result computation\n    float result = g * sig * u;\n    out[idx] = (T)result;\n}"
  }
}