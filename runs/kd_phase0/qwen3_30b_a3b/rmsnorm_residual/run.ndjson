{"candidate_id": "rmsnorm_residual_e4be3954505f6f8a", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.045917, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.001440922190201729, "dtype": "float16", "gbps_est": 0.2978165393014473, "latency_us": 139.39600000000002, "p10_us": 132.0, "p90_us": 152.875, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.14166882836143535, "latency_us": 144.5625, "max_abs_err": 0.00390625, "max_rel_err": 0.001440922190201729, "p10_us": 132.166, "p90_us": 152.875, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4284479031560744}, {"baseline_us": 217.8545, "gbps_est": 0.2692021206677475, "latency_us": 136.938, "max_abs_err": 0.001953125, "max_rel_err": 0.000864304235090752, "p10_us": 132.708, "p90_us": 143.917, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5908988009172036}, {"baseline_us": 195.1045, "gbps_est": 0.48257866887515904, "latency_us": 144.29149999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0009737098344693282, "p10_us": 129.042, "p90_us": 158.708, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.352155185856409}], "reference_latency_us": 201.9375, "speedup_vs_ref": 1.448660650233866}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_a77098ece6039e6e", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.033208, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009578544061302681, "dtype": "float16", "gbps_est": 0.284959062110915, "latency_us": 148.375, "p10_us": 136.208, "p90_us": 164.542, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.13993467892917175, "latency_us": 146.35399999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.0009149130832570906, "p10_us": 136.208, "p90_us": 148.875, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.410962460882518}, {"baseline_us": 217.8545, "gbps_est": 0.26648642591996874, "latency_us": 138.33350000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0009523809523809524, "p10_us": 134.834, "p90_us": 157.792, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5748499098193856}, {"baseline_us": 195.1045, "gbps_est": 0.44845608148360444, "latency_us": 155.2705, "max_abs_err": 0.001953125, "max_rel_err": 0.0009578544061302681, "p10_us": 142.041, "p90_us": 185.042, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.256545834527486}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.3917438921651222}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_544401a2e05792b8", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.025417, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009699321047526673, "dtype": "float16", "gbps_est": 0.33545403238148336, "latency_us": 124.25, "p10_us": 118.917, "p90_us": 151.5, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.14003418803418805, "latency_us": 146.25, "max_abs_err": 0.0009765625, "max_rel_err": 0.0009057971014492754, "p10_us": 131.208, "p90_us": 165.916, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.411965811965812}, {"baseline_us": 217.8545, "gbps_est": 0.30534502894913407, "latency_us": 120.729, "max_abs_err": 0.00390625, "max_rel_err": 0.0009699321047526673, "p10_us": 118.375, "p90_us": 121.542, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.8044918785047503}, {"baseline_us": 195.1045, "gbps_est": 0.560982880161128, "latency_us": 124.125, "max_abs_err": 0.001953125, "max_rel_err": 0.0009689922480620155, "p10_us": 118.375, "p90_us": 130.917, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5718388721047332}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.6619718309859155}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_472cdcb08e2db15d", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.024042, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009727626459143969, "dtype": "float16", "gbps_est": 0.3322930234757078, "latency_us": 127.0625, "p10_us": 120.75, "p90_us": 148.417, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.145873101797772, "latency_us": 140.39600000000002, "max_abs_err": 0.0009765625, "max_rel_err": 0.0009541984732824427, "p10_us": 129.666, "p90_us": 148.417, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4708396250605429}, {"baseline_us": 217.8545, "gbps_est": 0.30299219587972037, "latency_us": 121.6665, "max_abs_err": 0.001953125, "max_rel_err": 0.0009727626459143969, "p10_us": 120.125, "p90_us": 123.333, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.79058738436628}, {"baseline_us": 195.1045, "gbps_est": 0.548013772749631, "latency_us": 127.0625, "max_abs_err": 0.0009765625, "max_rel_err": 0.0009049773755656109, "p10_us": 122.375, "p90_us": 187.125, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5355002459419578}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.6251844564682736}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_a0667b918a02f1ad", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.026833, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009652509652509653, "dtype": "float16", "gbps_est": 0.3331831238954306, "latency_us": 125.4585, "p10_us": 123.291, "p90_us": 147.666, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.1633232452520226, "latency_us": 125.3955, "max_abs_err": 0.0009765625, "max_rel_err": 0.0008764241893076249, "p10_us": 122.875, "p90_us": 134.292, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.6467895578389975}, {"baseline_us": 217.8545, "gbps_est": 0.2940791677967995, "latency_us": 125.354, "max_abs_err": 0.001953125, "max_rel_err": 0.0009633911368015414, "p10_us": 123.375, "p90_us": 125.666, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.7379142269093926}, {"baseline_us": 195.1045, "gbps_est": 0.5421469586374696, "latency_us": 128.4375, "max_abs_err": 0.00390625, "max_rel_err": 0.0009652509652509653, "p10_us": 122.584, "p90_us": 212.25, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.519061800486618}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.645962609149639}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_d6959400a3811a21", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.022208, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009689922480620155, "dtype": "float16", "gbps_est": 0.32991710845827354, "latency_us": 127.4375, "p10_us": 120.791, "p90_us": 143.959, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.15799421407907427, "latency_us": 129.625, "max_abs_err": 0.001953125, "max_rel_err": 0.0009689922480620155, "p10_us": 124.0, "p90_us": 191.709, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.5930568948891033}, {"baseline_us": 217.8545, "gbps_est": 0.3034074074074074, "latency_us": 121.5, "max_abs_err": 0.001953125, "max_rel_err": 0.0009337068160597573, "p10_us": 119.291, "p90_us": 125.791, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.7930411522633745}, {"baseline_us": 195.1045, "gbps_est": 0.5283497038883389, "latency_us": 131.79149999999998, "max_abs_err": 0.0009765625, "max_rel_err": 0.0008802816901408451, "p10_us": 121.916, "p90_us": 135.167, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4804027573857192}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.6204021579205492}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_7374411585263db3", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.021125, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009718172983479105, "dtype": "float16", "gbps_est": 0.33151320033699255, "latency_us": 125.958, "p10_us": 122.208, "p90_us": 136.958, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.16605450285000772, "latency_us": 123.333, "max_abs_err": 0.001953125, "max_rel_err": 0.0009416195856873823, "p10_us": 120.375, "p90_us": 182.792, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.674328849537431}, {"baseline_us": 217.8545, "gbps_est": 0.2749341825585645, "latency_us": 134.083, "max_abs_err": 0.00390625, "max_rel_err": 0.0009718172983479105, "p10_us": 125.375, "p90_us": 136.958, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.6247734612143225}, {"baseline_us": 195.1045, "gbps_est": 0.5535509156024055, "latency_us": 125.7915, "max_abs_err": 0.001953125, "max_rel_err": 0.0009478672985781991, "p10_us": 123.75, "p90_us": 127.458, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5510149731897624}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.6394353673446704}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_006d2b315ce8ae94", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.021958, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009737098344693282, "dtype": "float16", "gbps_est": 0.321536588197414, "latency_us": 129.625, "p10_us": 119.542, "p90_us": 138.917, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.16243203908520942, "latency_us": 126.0835, "max_abs_err": 0.001953125, "max_rel_err": 0.0009643201542912247, "p10_us": 117.334, "p90_us": 135.583, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.6378035190964717}, {"baseline_us": 217.8545, "gbps_est": 0.2971405541561713, "latency_us": 124.0625, "max_abs_err": 0.001953125, "max_rel_err": 0.0009389671361502347, "p10_us": 120.958, "p90_us": 133.75, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.7560060453400503}, {"baseline_us": 195.1045, "gbps_est": 0.5050371713508612, "latency_us": 137.875, "max_abs_err": 0.00390625, "max_rel_err": 0.0009737098344693282, "p10_us": 123.666, "p90_us": 138.958, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4150825022665459}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.5930568948891033}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_b5466501d920cc8b", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.017625, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009718172983479105, "dtype": "float16", "gbps_est": 0.31993443625555096, "latency_us": 132.91649999999998, "p10_us": 123.375, "p90_us": 155.833, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.15215001040087966, "latency_us": 134.60399999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.000949667616334283, "p10_us": 120.667, "p90_us": 188.5, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.5341297435440255}, {"baseline_us": 217.8545, "gbps_est": 0.2706448960413485, "latency_us": 136.208, "max_abs_err": 0.001953125, "max_rel_err": 0.0009049773755656109, "p10_us": 126.417, "p90_us": 137.292, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5994251438975684}, {"baseline_us": 195.1045, "gbps_est": 0.5370084023244247, "latency_us": 129.66649999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.0009718172983479105, "p10_us": 124.375, "p90_us": 140.917, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5046638877427865}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.5536069637704877}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 1}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_63005cf76643acef", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.018291, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.000975609756097561, "dtype": "float16", "gbps_est": 0.31840912259827714, "latency_us": 135.95850000000002, "p10_us": 120.584, "p90_us": 139.542, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.14860824891881694, "latency_us": 137.812, "max_abs_err": 0.00048828125, "max_rel_err": 0.000966183574879227, "p10_us": 129.125, "p90_us": 155.708, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4984181348503758}, {"baseline_us": 217.8545, "gbps_est": 0.2954047350981437, "latency_us": 124.7915, "max_abs_err": 0.001953125, "max_rel_err": 0.000970873786407767, "p10_us": 120.083, "p90_us": 133.708, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.7457479075097262}, {"baseline_us": 195.1045, "gbps_est": 0.5112143837778708, "latency_us": 136.209, "max_abs_err": 0.001953125, "max_rel_err": 0.000975609756097561, "p10_us": 124.542, "p90_us": 137.417, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4323906643467024}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.518845824277261}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_0d1c5f657896a9a5", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v2_u4_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 4;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.021458, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.001183431952662722, "dtype": "float16", "gbps_est": 0.3049213028391488, "latency_us": 138.7505, "p10_us": 133.875, "p90_us": 148.458, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.14116057704899954, "latency_us": 145.083, "max_abs_err": 0.001953125, "max_rel_err": 0.0008051529790660225, "p10_us": 136.042, "p90_us": 146.875, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4233232012020705}, {"baseline_us": 217.8545, "gbps_est": 0.25812956894378625, "latency_us": 142.812, "max_abs_err": 0.001953125, "max_rel_err": 0.0009633911368015414, "p10_us": 131.208, "p90_us": 148.542, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5254635464806878}, {"baseline_us": 195.1045, "gbps_est": 0.5154737625246606, "latency_us": 135.08350000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.001183431952662722, "p10_us": 133.792, "p90_us": 138.667, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4443251766499978}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.4882829251065763}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_006d2b315ce8ae94", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 4, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_d3f9b2385783f2aa", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.017, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009551098376313276, "dtype": "float16", "gbps_est": 0.29858377353793825, "latency_us": 142.77100000000002, "p10_us": 130.375, "p90_us": 183.25, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.14901318781264208, "latency_us": 137.4375, "max_abs_err": 0.0009765625, "max_rel_err": 0.0009541984732824427, "p10_us": 121.125, "p90_us": 171.833, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.5025011368804002}, {"baseline_us": 217.8545, "gbps_est": 0.26339236273609673, "latency_us": 139.95850000000002, "max_abs_err": 0.001953125, "max_rel_err": 0.0009551098376313276, "p10_us": 132.916, "p90_us": 183.25, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.556564981762451}, {"baseline_us": 195.1045, "gbps_est": 0.483345770065076, "latency_us": 144.0625, "max_abs_err": 0.001953125, "max_rel_err": 0.0009523809523809524, "p10_us": 132.875, "p90_us": 157.834, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.3543045553145336}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.4463721624139354}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_a77098ece6039e6e", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_2a06462f2651e036", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v4_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.0195, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009746588693957114, "dtype": "float16", "gbps_est": 0.32358702931283934, "latency_us": 133.8535, "p10_us": 121.334, "p90_us": 143.25, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.1525034998361779, "latency_us": 134.292, "max_abs_err": 6.103515625e-05, "max_rel_err": 0.0008203445447087777, "p10_us": 123.709, "p90_us": 136.542, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.537693980281774}, {"baseline_us": 217.8545, "gbps_est": 0.30190657144729083, "latency_us": 122.104, "max_abs_err": 0.001953125, "max_rel_err": 0.0009746588693957114, "p10_us": 119.125, "p90_us": 143.25, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.784171689707135}, {"baseline_us": 195.1045, "gbps_est": 0.5163510166550492, "latency_us": 134.85399999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0009587727708533077, "p10_us": 130.667, "p90_us": 144.208, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4467831877437822}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.5427314190514256}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_e4be3954505f6f8a", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 4}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_a62e8f2fe01c67f2", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.019042, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009689922480620155, "dtype": "float16", "gbps_est": 0.3367725809673399, "latency_us": 125.1255, "p10_us": 121.125, "p90_us": 136.291, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.16552303825295606, "latency_us": 123.729, "max_abs_err": 0.001953125, "max_rel_err": 0.0009433962264150943, "p10_us": 120.875, "p90_us": 129.916, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.6689700878532923}, {"baseline_us": 217.8545, "gbps_est": 0.2917032640949555, "latency_us": 126.375, "max_abs_err": 0.001953125, "max_rel_err": 0.0009689922480620155, "p10_us": 123.542, "p90_us": 134.958, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.7238733926805143}, {"baseline_us": 195.1045, "gbps_est": 0.5530914405541083, "latency_us": 125.896, "max_abs_err": 0.001953125, "max_rel_err": 0.0009514747859181732, "p10_us": 119.625, "p90_us": 147.041, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.549727552900807}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.6503430555722054}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_c5e3775236e1486c", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v1_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.01625, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009615384615384616, "dtype": "float16", "gbps_est": 0.30333471519047683, "latency_us": 138.54149999999998, "p10_us": 133.791, "p90_us": 158.209, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.1327895531968696, "latency_us": 154.22899999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.0009225092250922509, "p10_us": 149.75, "p90_us": 164.542, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.3389181023024206}, {"baseline_us": 217.8545, "gbps_est": 0.27164205500044214, "latency_us": 135.708, "max_abs_err": 0.00390625, "max_rel_err": 0.0009615384615384616, "p10_us": 132.167, "p90_us": 137.75, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.60531803578271}, {"baseline_us": 195.1045, "gbps_est": 0.5055725373741188, "latency_us": 137.72899999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.0009606147934678194, "p10_us": 134.0, "p90_us": 139.875, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4165825643110748}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.4905281089059959}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_006d2b315ce8ae94", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 1}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_770b93dedbf4178c", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v2_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.025375, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0009765625, "dtype": "float16", "gbps_est": 0.301865960672878, "latency_us": 136.10399999999998, "p10_us": 126.75, "p90_us": 164.125, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.14892325144251226, "latency_us": 137.5205, "max_abs_err": 0.001953125, "max_rel_err": 0.0009727626459143969, "p10_us": 125.875, "p90_us": 249.042, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.5015943077577525}, {"baseline_us": 217.8545, "gbps_est": 0.27617724069988275, "latency_us": 133.4795, "max_abs_err": 0.001953125, "max_rel_err": 0.0009671179883945841, "p10_us": 125.417, "p90_us": 135.166, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.6321195389554202}, {"baseline_us": 195.1045, "gbps_est": 0.48049738987623913, "latency_us": 144.91649999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 134.375, "p90_us": 147.583, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.346323572540049}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.5172221242579207}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_e4be3954505f6f8a", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:22-0600"}
{"candidate_id": "rmsnorm_residual_6c0648e4c6a2aec5", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.026959, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.000975609756097561, "dtype": "float16", "gbps_est": 0.3120461246559585, "latency_us": 126.6665, "p10_us": 123.5, "p90_us": 172.875, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.16227116240189846, "latency_us": 126.2085, "max_abs_err": 0.001953125, "max_rel_err": 0.0009157509157509158, "p10_us": 123.5, "p90_us": 127.375, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.6361813982417983}, {"baseline_us": 217.8545, "gbps_est": 0.28140458015267183, "latency_us": 131.0, "max_abs_err": 0.001953125, "max_rel_err": 0.000975609756097561, "p10_us": 102.875, "p90_us": 216.333, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.6630114503816793}, {"baseline_us": 195.1045, "gbps_est": 0.4924626314133052, "latency_us": 141.3955, "max_abs_err": 0.001953125, "max_rel_err": 0.0009727626459143969, "p10_us": 118.208, "p90_us": 158.667, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.3798494294372876}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.6302653029806617}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:23-0600"}
{"candidate_id": "rmsnorm_residual_b448f0bd33a97cf3", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v4_u4_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 4;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.018875, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009671179883945841, "dtype": "float16", "gbps_est": 0.28421273451303836, "latency_us": 146.875, "p10_us": 140.667, "p90_us": 177.916, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.12972288202692003, "latency_us": 157.875, "max_abs_err": 0.001953125, "max_rel_err": 0.0008896797153024911, "p10_us": 138.375, "p90_us": 180.042, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.3079968329374505}, {"baseline_us": 217.8545, "gbps_est": 0.24734050583226824, "latency_us": 149.04149999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.0009671179883945841, "p10_us": 140.542, "p90_us": 165.833, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.4617036194616937}, {"baseline_us": 195.1045, "gbps_est": 0.4755748156799269, "latency_us": 146.41649999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0009569377990430622, "p10_us": 145.917, "p90_us": 147.041, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.332530828151199}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.4059574468085105}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_a62e8f2fe01c67f2", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 4, "use_simd": false, "vec_width": 4}, "ts": "2026-02-09T19:12:23-0600"}
{"candidate_id": "rmsnorm_residual_5faa7484fddec673", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v4_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.030083, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009727626459143969, "dtype": "float16", "gbps_est": 0.29458353393041015, "latency_us": 142.91649999999998, "p10_us": 133.875, "p90_us": 226.708, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.14134324392406944, "latency_us": 144.8955, "max_abs_err": 0.0009765625, "max_rel_err": 0.0009328358208955224, "p10_us": 131.417, "p90_us": 242.708, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.425165032730485}, {"baseline_us": 217.8545, "gbps_est": 0.25933990172042026, "latency_us": 142.1455, "max_abs_err": 0.00390625, "max_rel_err": 0.0009718172983479105, "p10_us": 131.209, "p90_us": 163.667, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5326162277384792}, {"baseline_us": 195.1045, "gbps_est": 0.4830674561467407, "latency_us": 144.1455, "max_abs_err": 0.00390625, "max_rel_err": 0.0009727626459143969, "p10_us": 134.875, "p90_us": 151.292, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.353524737157941}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.444899644197836}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_a62e8f2fe01c67f2", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 4}, "ts": "2026-02-09T19:12:23-0600"}
{"candidate_id": "rmsnorm_residual_12d960ba12b9a904", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.029875, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009699321047526673, "dtype": "float16", "gbps_est": 0.26261480793567415, "latency_us": 156.375, "p10_us": 148.959, "p90_us": 181.541, "per_shape": [{"baseline_us": 206.5, "gbps_est": 0.12955219726346287, "latency_us": 158.083, "max_abs_err": 0.00390625, "max_rel_err": 0.000931098696461825, "p10_us": 147.875, "p90_us": 161.334, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.3062758171340372}, {"baseline_us": 217.8545, "gbps_est": 0.23760844623773736, "latency_us": 155.14600000000002, "max_abs_err": 0.001953125, "max_rel_err": 0.0009699321047526673, "p10_us": 146.833, "p90_us": 158.5, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.4041902466064222}, {"baseline_us": 195.1045, "gbps_est": 0.4206837803058222, "latency_us": 165.52100000000002, "max_abs_err": 0.001953125, "max_rel_err": 0.000968054211035818, "p10_us": 154.0, "p90_us": 265.167, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.178729587182291}], "reference_latency_us": 206.5, "speedup_vs_ref": 1.3205435651478816}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_472cdcb08e2db15d", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:23-0600"}
