{
  "schema_version": "2",
  "runtime": {
    "mlx_version": "0.30.6.dev20260208+185b06d9",
    "device_name": "Apple M4 Max",
    "device_arch": "applegpu_g16s"
  },
  "entries": [
    {
      "key": {
        "op_name": "swiglu",
        "mlx_version": "0.30.6.dev20260208+185b06d9",
        "device_arch": "applegpu_g16s",
        "device_name": "Apple M4 Max",
        "dtype": "float16",
        "shape_signature": {
          "rows": 128,
          "D": 1536,
          "N": 196608
        }
      },
      "candidate_id": "swiglu_e79b57774f9d99c2",
      "func_name": "kk_kd_swiglu_n196608_tg128_v2_u1_fast1",
      "metal_source": "constexpr uint N = 196608;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr bool FAST_SIGMOID = true;\n\nuint tid = thread_position_in_grid.x;\nuint base = tid * VEC * UNROLL;\n\n#pragma unroll\nfor (uint u = 0; u < UNROLL; ++u) {\n    uint idx0 = base + u * VEC;\n    if (idx0 >= N) {\n        continue;\n    }\n\n    #pragma unroll\n    for (uint v = 0; v < VEC; ++v) {\n        uint idx = idx0 + v;\n        if (idx >= N) {\n            continue;\n        }\n\n        float g = (float)gate[idx];\n        float upv = (float)up[idx];\n        float sig;\n        if (FAST_SIGMOID) {\n            sig = kk_sigmoid(g);\n        } else {\n            sig = 1.0f / (1.0f + metal::exp(-g));\n        }\n        out[idx] = (T)(g * sig * upv);\n    }\n}\n",
      "inputs_spec": [
        {
          "name": "gate",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        },
        {
          "name": "up",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        }
      ],
      "outputs_spec": [
        {
          "name": "out",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        }
      ],
      "template_params": {
        "vec_width": 2,
        "unroll": 1,
        "fast_sigmoid": true
      },
      "launch_params": {
        "threadgroup_x": 128,
        "launch_kind": "swiglu_flat",
        "vec_width": 2,
        "unroll": 1
      },
      "source_hash": "299fcfaa43eab15032de60da82a02a263704893647cda1d2cc0b2111b920c300",
      "metrics": {
        "latency_us": 179.125,
        "speedup_vs_ref": 1.264480111653873,
        "correctness_max_abs_err": 0.0,
        "correctness_max_rel_err": 0.0
      }
    },
    {
      "key": {
        "op_name": "swiglu",
        "mlx_version": "0.30.6.dev20260208+185b06d9",
        "device_arch": "applegpu_g16s",
        "device_name": "Apple M4 Max",
        "dtype": "float16",
        "shape_signature": {
          "rows": 256,
          "D": 1536,
          "N": 393216
        }
      },
      "candidate_id": "swiglu_e79b57774f9d99c2",
      "func_name": "kk_kd_swiglu_n196608_tg128_v2_u1_fast1",
      "metal_source": "constexpr uint N = 196608;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr bool FAST_SIGMOID = true;\n\nuint tid = thread_position_in_grid.x;\nuint base = tid * VEC * UNROLL;\n\n#pragma unroll\nfor (uint u = 0; u < UNROLL; ++u) {\n    uint idx0 = base + u * VEC;\n    if (idx0 >= N) {\n        continue;\n    }\n\n    #pragma unroll\n    for (uint v = 0; v < VEC; ++v) {\n        uint idx = idx0 + v;\n        if (idx >= N) {\n            continue;\n        }\n\n        float g = (float)gate[idx];\n        float upv = (float)up[idx];\n        float sig;\n        if (FAST_SIGMOID) {\n            sig = kk_sigmoid(g);\n        } else {\n            sig = 1.0f / (1.0f + metal::exp(-g));\n        }\n        out[idx] = (T)(g * sig * upv);\n    }\n}\n",
      "inputs_spec": [
        {
          "name": "gate",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        },
        {
          "name": "up",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        }
      ],
      "outputs_spec": [
        {
          "name": "out",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        }
      ],
      "template_params": {
        "vec_width": 2,
        "unroll": 1,
        "fast_sigmoid": true
      },
      "launch_params": {
        "threadgroup_x": 128,
        "launch_kind": "swiglu_flat",
        "vec_width": 2,
        "unroll": 1
      },
      "source_hash": "299fcfaa43eab15032de60da82a02a263704893647cda1d2cc0b2111b920c300",
      "metrics": {
        "latency_us": 179.125,
        "speedup_vs_ref": 1.264480111653873,
        "correctness_max_abs_err": 0.0,
        "correctness_max_rel_err": 0.0
      }
    },
    {
      "key": {
        "op_name": "swiglu",
        "mlx_version": "0.30.6.dev20260208+185b06d9",
        "device_arch": "applegpu_g16s",
        "device_name": "Apple M4 Max",
        "dtype": "float16",
        "shape_signature": {
          "rows": 512,
          "D": 1536,
          "N": 786432
        }
      },
      "candidate_id": "swiglu_e79b57774f9d99c2",
      "func_name": "kk_kd_swiglu_n196608_tg128_v2_u1_fast1",
      "metal_source": "constexpr uint N = 196608;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr bool FAST_SIGMOID = true;\n\nuint tid = thread_position_in_grid.x;\nuint base = tid * VEC * UNROLL;\n\n#pragma unroll\nfor (uint u = 0; u < UNROLL; ++u) {\n    uint idx0 = base + u * VEC;\n    if (idx0 >= N) {\n        continue;\n    }\n\n    #pragma unroll\n    for (uint v = 0; v < VEC; ++v) {\n        uint idx = idx0 + v;\n        if (idx >= N) {\n            continue;\n        }\n\n        float g = (float)gate[idx];\n        float upv = (float)up[idx];\n        float sig;\n        if (FAST_SIGMOID) {\n            sig = kk_sigmoid(g);\n        } else {\n            sig = 1.0f / (1.0f + metal::exp(-g));\n        }\n        out[idx] = (T)(g * sig * upv);\n    }\n}\n",
      "inputs_spec": [
        {
          "name": "gate",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        },
        {
          "name": "up",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        }
      ],
      "outputs_spec": [
        {
          "name": "out",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        }
      ],
      "template_params": {
        "vec_width": 2,
        "unroll": 1,
        "fast_sigmoid": true
      },
      "launch_params": {
        "threadgroup_x": 128,
        "launch_kind": "swiglu_flat",
        "vec_width": 2,
        "unroll": 1
      },
      "source_hash": "299fcfaa43eab15032de60da82a02a263704893647cda1d2cc0b2111b920c300",
      "metrics": {
        "latency_us": 179.125,
        "speedup_vs_ref": 1.264480111653873,
        "correctness_max_abs_err": 0.0,
        "correctness_max_rel_err": 0.0
      }
    },
    {
      "key": {
        "op_name": "swiglu",
        "mlx_version": "0.30.6.dev20260208+185b06d9",
        "device_arch": "applegpu_g16s",
        "device_name": "Apple M4 Max",
        "dtype": "float16",
        "shape_signature": {
          "rows": 1024,
          "D": 1536,
          "N": 1572864
        }
      },
      "candidate_id": "swiglu_e79b57774f9d99c2",
      "func_name": "kk_kd_swiglu_n196608_tg128_v2_u1_fast1",
      "metal_source": "constexpr uint N = 196608;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr bool FAST_SIGMOID = true;\n\nuint tid = thread_position_in_grid.x;\nuint base = tid * VEC * UNROLL;\n\n#pragma unroll\nfor (uint u = 0; u < UNROLL; ++u) {\n    uint idx0 = base + u * VEC;\n    if (idx0 >= N) {\n        continue;\n    }\n\n    #pragma unroll\n    for (uint v = 0; v < VEC; ++v) {\n        uint idx = idx0 + v;\n        if (idx >= N) {\n            continue;\n        }\n\n        float g = (float)gate[idx];\n        float upv = (float)up[idx];\n        float sig;\n        if (FAST_SIGMOID) {\n            sig = kk_sigmoid(g);\n        } else {\n            sig = 1.0f / (1.0f + metal::exp(-g));\n        }\n        out[idx] = (T)(g * sig * upv);\n    }\n}\n",
      "inputs_spec": [
        {
          "name": "gate",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        },
        {
          "name": "up",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        }
      ],
      "outputs_spec": [
        {
          "name": "out",
          "dtype": "float16",
          "shape": [
            196608
          ],
          "strides": "contiguous"
        }
      ],
      "template_params": {
        "vec_width": 2,
        "unroll": 1,
        "fast_sigmoid": true
      },
      "launch_params": {
        "threadgroup_x": 128,
        "launch_kind": "swiglu_flat",
        "vec_width": 2,
        "unroll": 1
      },
      "source_hash": "299fcfaa43eab15032de60da82a02a263704893647cda1d2cc0b2111b920c300",
      "metrics": {
        "latency_us": 179.125,
        "speedup_vs_ref": 1.264480111653873,
        "correctness_max_abs_err": 0.0,
        "correctness_max_rel_err": 0.0
      }
    }
  ]
}