{"candidate_id": "rmsnorm_residual_96eaf3a799e17b29", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.576916, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0029069767441860465, "dtype": "float16", "gbps_est": 45.6860173089404, "latency_us": 162.20850000000002, "p10_us": 153.041, "p90_us": 188.75, "per_shape": [{"baseline_us": 231.625, "gbps_est": 13.713122189663837, "latency_us": 153.22899999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0020161290322580645, "p10_us": 150.667, "p90_us": 157.416, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5116263892605186}, {"baseline_us": 290.64599999999996, "gbps_est": 25.297890737744673, "latency_us": 165.95850000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 157.042, "p90_us": 191.042, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.751317347409141}, {"baseline_us": 406.83299999999997, "gbps_est": 52.99260615627467, "latency_us": 158.375, "max_abs_err": 0.0078125, "max_rel_err": 0.001091703056768559, "p10_us": 154.375, "p90_us": 171.917, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.568795580110497}, {"baseline_us": 600.312, "gbps_est": 90.74045015207841, "latency_us": 184.9375, "max_abs_err": 0.00390625, "max_rel_err": 0.0029069767441860465, "p10_us": 175.166, "p90_us": 195.167, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.2460263602568435}], "reference_latency_us": 397.22950000000003, "speedup_vs_ref": 2.4488821485927064}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_efb7abf5f90288b7", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.034875, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0018552875695732839, "dtype": "float16", "gbps_est": 47.874520680975266, "latency_us": 163.72899999999998, "p10_us": 146.959, "p90_us": 184.125, "per_shape": [{"baseline_us": 231.625, "gbps_est": 13.984965108269193, "latency_us": 150.2505, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 135.959, "p90_us": 220.584, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5415922076798414}, {"baseline_us": 290.64599999999996, "gbps_est": 28.141767909509845, "latency_us": 149.1875, "max_abs_err": 0.00390625, "max_rel_err": 0.000980392156862745, "p10_us": 147.041, "p90_us": 164.5, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.948192710515291}, {"baseline_us": 406.83299999999997, "gbps_est": 51.687168591224015, "latency_us": 162.375, "max_abs_err": 0.00390625, "max_rel_err": 0.0018552875695732839, "p10_us": 146.959, "p90_us": 176.917, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.505515011547344}, {"baseline_us": 600.312, "gbps_est": 97.68418111489801, "latency_us": 171.79149999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0015128593040847202, "p10_us": 164.458, "p90_us": 177.375, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.4944220173873566}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.129980027973053}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_9fb2437335e855ee", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.033083, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0035971223021582736, "dtype": "float16", "gbps_est": 50.05409365344832, "latency_us": 152.04149999999998, "p10_us": 133.833, "p90_us": 181.791, "per_shape": [{"baseline_us": 231.625, "gbps_est": 15.485936434822664, "latency_us": 135.6875, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 133.084, "p90_us": 186.458, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.7070474435743896}, {"baseline_us": 290.64599999999996, "gbps_est": 29.10089034140729, "latency_us": 144.2705, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 126.625, "p90_us": 146.167, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.0145906474296544}, {"baseline_us": 406.83299999999997, "gbps_est": 53.77060355514836, "latency_us": 156.08350000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0035971223021582736, "p10_us": 146.208, "p90_us": 170.458, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.6065086956661014}, {"baseline_us": 600.312, "gbps_est": 101.85894428241495, "latency_us": 164.7505, "max_abs_err": 0.0078125, "max_rel_err": 0.0018248175182481751, "p10_us": 158.333, "p90_us": 175.0, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.643764358833509}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.2937125718964886}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_e4ef568da100c168", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.040542, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.002173913043478261, "dtype": "float16", "gbps_est": 45.690536913930906, "latency_us": 166.45850000000002, "p10_us": 141.834, "p90_us": 185.5, "per_shape": [{"baseline_us": 231.625, "gbps_est": 14.43948296122209, "latency_us": 145.52100000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 136.292, "p90_us": 158.792, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.591694669497873}, {"baseline_us": 290.64599999999996, "gbps_est": 25.11192523364486, "latency_us": 167.1875, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 146.167, "p90_us": 179.5, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.7384433644859811}, {"baseline_us": 406.83299999999997, "gbps_est": 51.78012567596331, "latency_us": 162.08350000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0018796992481203006, "p10_us": 148.791, "p90_us": 172.334, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.510021069387075}, {"baseline_us": 600.312, "gbps_est": 91.43061378489335, "latency_us": 183.54149999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.002173913043478261, "p10_us": 175.667, "p90_us": 186.167, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.270715342306781}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.095053722098901}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_f385a0b77fd7ac03", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.0325, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0021929824561403508, "dtype": "float16", "gbps_est": 49.96615327881051, "latency_us": 153.1875, "p10_us": 135.042, "p90_us": 172.958, "per_shape": [{"baseline_us": 231.625, "gbps_est": 14.404491532104652, "latency_us": 145.8745, "max_abs_err": 0.0078125, "max_rel_err": 0.0013568521031207597, "p10_us": 134.208, "p90_us": 177.458, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5878374904455541}, {"baseline_us": 290.64599999999996, "gbps_est": 30.469112865768697, "latency_us": 137.792, "max_abs_err": 0.00390625, "max_rel_err": 0.0021929824561403508, "p10_us": 129.584, "p90_us": 148.417, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.1093096841616346}, {"baseline_us": 406.83299999999997, "gbps_est": 53.27314159488641, "latency_us": 157.541, "max_abs_err": 0.00390625, "max_rel_err": 0.0012376237623762376, "p10_us": 147.833, "p90_us": 193.875, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.5823944243085926}, {"baseline_us": 600.312, "gbps_est": 101.71786712248228, "latency_us": 164.97899999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 158.125, "p90_us": 171.292, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.6387176549742697}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.276553243574051}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_5474f82bb7757b69", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.033417, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0017857142857142857, "dtype": "float16", "gbps_est": 47.07467217362296, "latency_us": 156.7495, "p10_us": 126.291, "p90_us": 189.375, "per_shape": [{"baseline_us": 231.625, "gbps_est": 15.999390861398126, "latency_us": 131.333, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 122.25, "p90_us": 171.75, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.7636466082401225}, {"baseline_us": 290.64599999999996, "gbps_est": 29.092420961455176, "latency_us": 144.3125, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 133.417, "p90_us": 150.5, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.014004330879168}, {"baseline_us": 406.83299999999997, "gbps_est": 52.16910023310024, "latency_us": 160.875, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 149.375, "p90_us": 176.583, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.5288764568764566}, {"baseline_us": 600.312, "gbps_est": 91.03777663853829, "latency_us": 184.33350000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0017857142857142857, "p10_us": 162.584, "p90_us": 191.041, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.2566625165800027}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.224820493845275}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_4144d2f97a190b25", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.03225, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0015313935681470138, "dtype": "float16", "gbps_est": 50.33900224687908, "latency_us": 152.8745, "p10_us": 127.167, "p90_us": 175.958, "per_shape": [{"baseline_us": 231.625, "gbps_est": 16.21533522657118, "latency_us": 129.584, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 121.291, "p90_us": 179.625, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.7874506111865662}, {"baseline_us": 290.64599999999996, "gbps_est": 30.095949476883597, "latency_us": 139.5005, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 128.292, "p90_us": 145.208, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.083476403310382}, {"baseline_us": 406.83299999999997, "gbps_est": 54.52020462850183, "latency_us": 153.9375, "max_abs_err": 0.0078125, "max_rel_err": 0.0015313935681470138, "p10_us": 141.75, "p90_us": 182.875, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.642845310596833}, {"baseline_us": 600.312, "gbps_est": 100.52451965555973, "latency_us": 166.9375, "max_abs_err": 0.00390625, "max_rel_err": 0.0013280212483399733, "p10_us": 153.792, "p90_us": 175.292, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.596028453762636}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.2812143294009135}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_3d9e4da0b8a43ea6", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.026875, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0012755102040816326, "dtype": "float16", "gbps_est": 48.82046712329362, "latency_us": 162.25, "p10_us": 130.959, "p90_us": 182.042, "per_shape": [{"baseline_us": 231.625, "gbps_est": 15.739685393258428, "latency_us": 133.5, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 126.417, "p90_us": 155.5, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.7350187265917603}, {"baseline_us": 290.64599999999996, "gbps_est": 31.46341920374708, "latency_us": 133.4375, "max_abs_err": 0.00390625, "max_rel_err": 0.001004016064257028, "p10_us": 131.916, "p90_us": 151.708, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.1781433255269316}, {"baseline_us": 406.83299999999997, "gbps_est": 46.85938895837056, "latency_us": 179.10399999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0012755102040816326, "p10_us": 167.417, "p90_us": 187.417, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.271490307307486}, {"baseline_us": 600.312, "gbps_est": 101.2193749377984, "latency_us": 165.79149999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 160.834, "p90_us": 172.083, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.620885268545131}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.149395993836672}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_6fd59815735eb35b", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.032791, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0015552099533437014, "dtype": "float16", "gbps_est": 48.05678974900213, "latency_us": 165.20850000000002, "p10_us": 127.667, "p90_us": 189.708, "per_shape": [{"baseline_us": 231.625, "gbps_est": 15.80628490832158, "latency_us": 132.9375, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 125.209, "p90_us": 134.583, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.7423601316408086}, {"baseline_us": 290.64599999999996, "gbps_est": 30.136455320034745, "latency_us": 139.313, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 127.625, "p90_us": 189.708, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.0862805337621038}, {"baseline_us": 406.83299999999997, "gbps_est": 49.23605452353506, "latency_us": 170.45850000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.0015552099533437014, "p10_us": 165.125, "p90_us": 180.166, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.3866982286010963}, {"baseline_us": 600.312, "gbps_est": 97.04836424411712, "latency_us": 172.917, "max_abs_err": 0.0078125, "max_rel_err": 0.0014492753623188406, "p10_us": 161.333, "p90_us": 208.667, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.4716771630319747}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.1109053105621074}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_439aa7830bf0627e", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.030541, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0017241379310344827, "dtype": "float16", "gbps_est": 49.609279628697195, "latency_us": 157.937, "p10_us": 132.75, "p90_us": 232.292, "per_shape": [{"baseline_us": 231.625, "gbps_est": 15.351583561643835, "latency_us": 136.875, "max_abs_err": 0.0078125, "max_rel_err": 0.0012048192771084338, "p10_us": 127.208, "p90_us": 164.417, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.6922374429223743}, {"baseline_us": 290.64599999999996, "gbps_est": 27.314128087022148, "latency_us": 153.708, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 149.208, "p90_us": 232.292, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.8908970255289248}, {"baseline_us": 406.83299999999997, "gbps_est": 53.237827911358075, "latency_us": 157.6455, "max_abs_err": 0.0078125, "max_rel_err": 0.0009852216748768472, "p10_us": 145.875, "p90_us": 183.417, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.580682607495932}, {"baseline_us": 600.312, "gbps_est": 102.53357895476472, "latency_us": 163.66649999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0017241379310344827, "p10_us": 162.0, "p90_us": 224.083, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.6678978288165265}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.208092467249599}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_b373cc82e0571f30", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v2_u4_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 4;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.0295, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.007751937984496124, "dtype": "float16", "gbps_est": 47.505851709921316, "latency_us": 159.687, "p10_us": 132.917, "p90_us": 237.375, "per_shape": [{"baseline_us": 231.625, "gbps_est": 15.552818569398392, "latency_us": 135.10399999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0025252525252525255, "p10_us": 130.25, "p90_us": 163.25, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.7144200023685459}, {"baseline_us": 290.64599999999996, "gbps_est": 28.039992252669826, "latency_us": 149.72899999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.00510204081632653, "p10_us": 137.292, "p90_us": 196.167, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.9411470055900995}, {"baseline_us": 406.83299999999997, "gbps_est": 53.26604130437542, "latency_us": 157.562, "max_abs_err": 0.0078125, "max_rel_err": 0.0010351966873706005, "p10_us": 149.125, "p90_us": 164.875, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.5820502405402315}, {"baseline_us": 600.312, "gbps_est": 93.16455471324161, "latency_us": 180.1255, "max_abs_err": 0.00390625, "max_rel_err": 0.007751937984496124, "p10_us": 163.166, "p90_us": 296.0, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.332743004183195}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.183894117868079}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_3d9e4da0b8a43ea6", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 4, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_b1a972cd3e0e4eb0", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v1_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.029208, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.005952380952380952, "dtype": "float16", "gbps_est": 45.655652604478995, "latency_us": 162.95850000000002, "p10_us": 150.041, "p90_us": 192.208, "per_shape": [{"baseline_us": 231.625, "gbps_est": 13.644423232392104, "latency_us": 154.0005, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 145.417, "p90_us": 167.833, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5040535582676682}, {"baseline_us": 290.64599999999996, "gbps_est": 27.325238942891264, "latency_us": 153.6455, "max_abs_err": 0.0078125, "max_rel_err": 0.0053475935828877, "p10_us": 148.042, "p90_us": 166.167, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.891666205648717}, {"baseline_us": 406.83299999999997, "gbps_est": 50.66650568078916, "latency_us": 165.64600000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.002369668246445498, "p10_us": 153.542, "p90_us": 225.084, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.4560387814978926}, {"baseline_us": 600.312, "gbps_est": 90.98644256184345, "latency_us": 184.4375, "max_abs_err": 0.0078125, "max_rel_err": 0.005952380952380952, "p10_us": 172.375, "p90_us": 190.333, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.2548261606235176}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.140050994578374}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_9fb2437335e855ee", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 1}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_8fe75929551945a4", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v4_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.030916, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.001937984496124031, "dtype": "float16", "gbps_est": 49.72323420534783, "latency_us": 154.4375, "p10_us": 123.542, "p90_us": 181.875, "per_shape": [{"baseline_us": 231.625, "gbps_est": 16.621627714736604, "latency_us": 126.4165, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 120.833, "p90_us": 128.5, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.832237089304007}, {"baseline_us": 290.64599999999996, "gbps_est": 30.557041533383558, "latency_us": 137.3955, "max_abs_err": 0.00390625, "max_rel_err": 0.0014992503748125937, "p10_us": 131.333, "p90_us": 181.542, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.115396792471369}, {"baseline_us": 406.83299999999997, "gbps_est": 53.09754400172085, "latency_us": 158.062, "max_abs_err": 0.0078125, "max_rel_err": 0.001937984496124031, "p10_us": 150.584, "p90_us": 164.083, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.5738824005769882}, {"baseline_us": 600.312, "gbps_est": 98.61672357155031, "latency_us": 170.167, "max_abs_err": 0.0078125, "max_rel_err": 0.0013003901170351106, "p10_us": 154.375, "p90_us": 207.042, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.5277815322594863}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.258127074059085}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_9fb2437335e855ee", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 4}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_9c80e02fae5cc00b", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v4_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.027666, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.001579778830963665, "dtype": "float16", "gbps_est": 48.30396225989698, "latency_us": 141.9375, "p10_us": 126.125, "p90_us": 197.917, "per_shape": [{"baseline_us": 231.625, "gbps_est": 16.605208567940164, "latency_us": 126.5415, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 122.083, "p90_us": 128.083, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.8304271721134964}, {"baseline_us": 290.64599999999996, "gbps_est": 32.45666929511264, "latency_us": 129.35399999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0013550135501355014, "p10_us": 127.75, "p90_us": 136.417, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.2469038452618397}, {"baseline_us": 406.83299999999997, "gbps_est": 53.921918719140606, "latency_us": 155.6455, "max_abs_err": 0.00390625, "max_rel_err": 0.0010834236186348862, "p10_us": 144.5, "p90_us": 163.084, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.61384363826773}, {"baseline_us": 600.312, "gbps_est": 90.2320524573945, "latency_us": 185.9795, "max_abs_err": 0.0078125, "max_rel_err": 0.001579778830963665, "p10_us": 151.292, "p90_us": 222.166, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.227839627485825}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.4569933949801848}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_96eaf3a799e17b29", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 4}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_3fb8d765e6b2a090", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.02925, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0026041666666666665, "dtype": "float16", "gbps_est": 45.82367291531353, "latency_us": 164.8545, "p10_us": 127.625, "p90_us": 192.042, "per_shape": [{"baseline_us": 231.625, "gbps_est": 14.625873115862085, "latency_us": 143.66649999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 126.166, "p90_us": 167.75, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.612240849467343}, {"baseline_us": 290.64599999999996, "gbps_est": 31.375245212517513, "latency_us": 133.8125, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 124.5, "p90_us": 140.042, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.1720392340028023}, {"baseline_us": 406.83299999999997, "gbps_est": 47.232945480126624, "latency_us": 177.6875, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 159.959, "p90_us": 185.666, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.289598311642631}, {"baseline_us": 600.312, "gbps_est": 90.0606278527479, "latency_us": 186.33350000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.0026041666666666665, "p10_us": 164.0, "p90_us": 233.958, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.221707315109736}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.115438159103937}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_f385a0b77fd7ac03", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_55d8f6592567dd05", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v1_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.0265, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.002570694087403599, "dtype": "float16", "gbps_est": 41.047087015377244, "latency_us": 196.64600000000002, "p10_us": 143.75, "p90_us": 252.917, "per_shape": [{"baseline_us": 231.625, "gbps_est": 12.894374948223012, "latency_us": 162.95850000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 142.041, "p90_us": 180.5, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.4213741535421593}, {"baseline_us": 290.64599999999996, "gbps_est": 28.91708996986655, "latency_us": 145.1875, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 128.416, "p90_us": 286.167, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.0018665518725784}, {"baseline_us": 406.83299999999997, "gbps_est": 42.267316336166196, "latency_us": 198.5625, "max_abs_err": 0.0078125, "max_rel_err": 0.002570694087403599, "p10_us": 193.125, "p90_us": 202.125, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.048891406987724}, {"baseline_us": 600.312, "gbps_est": 80.10956680725322, "latency_us": 209.4795, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 188.833, "p90_us": 374.334, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.8657314916256724}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 1.7734380562025158}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_5474f82bb7757b69", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_624c4a01eb8b306a", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v4_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.032459, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0018796992481203006, "dtype": "float16", "gbps_est": 47.314875654964894, "latency_us": 162.7705, "p10_us": 148.083, "p90_us": 181.167, "per_shape": [{"baseline_us": 231.625, "gbps_est": 13.48397322775022, "latency_us": 155.833, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 139.458, "p90_us": 179.042, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.4863668157578946}, {"baseline_us": 290.64599999999996, "gbps_est": 27.451826569110153, "latency_us": 152.937, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 147.25, "p90_us": 157.584, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.9004295886541513}, {"baseline_us": 406.83299999999997, "gbps_est": 47.15558577135505, "latency_us": 177.97899999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 172.084, "p90_us": 186.0, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.285848330421005}, {"baseline_us": 600.312, "gbps_est": 101.16811705164416, "latency_us": 165.8755, "max_abs_err": 0.00390625, "max_rel_err": 0.0018796992481203006, "p10_us": 159.0, "p90_us": 171.917, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.6190516381261855}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.1425227544303174}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_96eaf3a799e17b29", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 4}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_5f0a06a469a04339", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v1_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.032416, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0019193857965451055, "dtype": "float16", "gbps_est": 45.784123271689246, "latency_us": 170.333, "p10_us": 146.125, "p90_us": 195.125, "per_shape": [{"baseline_us": 231.625, "gbps_est": 14.314458553599652, "latency_us": 146.792, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 140.875, "p90_us": 195.125, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5779129652842117}, {"baseline_us": 290.64599999999996, "gbps_est": 26.446697469913293, "latency_us": 158.7495, "max_abs_err": 0.0078125, "max_rel_err": 0.0013175230566534915, "p10_us": 150.375, "p90_us": 183.791, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.8308467113282243}, {"baseline_us": 406.83299999999997, "gbps_est": 51.42982152432018, "latency_us": 163.1875, "max_abs_err": 0.00390625, "max_rel_err": 0.0011862396204033216, "p10_us": 153.667, "p90_us": 184.125, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.4930402144772117}, {"baseline_us": 600.312, "gbps_est": 90.94551553892387, "latency_us": 184.5205, "max_abs_err": 0.00390625, "max_rel_err": 0.0019193857965451055, "p10_us": 181.25, "p90_us": 192.417, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.2533620925588216}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.047398331503584}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_b373cc82e0571f30", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_66abd3cdeb4d8d71", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v1_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.027417, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0016260162601626016, "dtype": "float16", "gbps_est": 49.71903016266527, "latency_us": 152.083, "p10_us": 126.0, "p90_us": 176.708, "per_shape": [{"baseline_us": 231.625, "gbps_est": 16.06053518607691, "latency_us": 130.833, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 111.083, "p90_us": 176.209, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.7703866761443978}, {"baseline_us": 290.64599999999996, "gbps_est": 32.76275795872661, "latency_us": 128.1455, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 123.291, "p90_us": 131.0, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.268093690375393}, {"baseline_us": 406.83299999999997, "gbps_est": 53.23765905890413, "latency_us": 157.64600000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.001402524544179523, "p10_us": 142.833, "p90_us": 163.334, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.58067442244015}, {"baseline_us": 600.312, "gbps_est": 96.81516844695342, "latency_us": 173.33350000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0016260162601626016, "p10_us": 161.542, "p90_us": 181.0, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.4633351314085274}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.293086669779002}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_f385a0b77fd7ac03", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 1}, "ts": "2026-02-09T19:12:10-0600"}
{"candidate_id": "rmsnorm_residual_9ee604c83d384850", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v4_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.0295, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.005813953488372093, "dtype": "float16", "gbps_est": 49.618780478320055, "latency_us": 142.0625, "p10_us": 125.875, "p90_us": 184.292, "per_shape": [{"baseline_us": 231.625, "gbps_est": 16.116954937679772, "latency_us": 130.375, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 125.041, "p90_us": 139.167, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.7766059443911792}, {"baseline_us": 290.64599999999996, "gbps_est": 32.305821880915374, "latency_us": 129.958, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 124.375, "p90_us": 138.791, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.236461010480309}, {"baseline_us": 406.83299999999997, "gbps_est": 53.1323353918909, "latency_us": 157.95850000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0019342359767891683, "p10_us": 141.75, "p90_us": 177.0, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 2.5755688994261146}, {"baseline_us": 600.312, "gbps_est": 96.92000970279418, "latency_us": 173.14600000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.005813953488372093, "p10_us": 158.792, "p90_us": 195.375, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 3.467085580954801}], "reference_latency_us": 348.73949999999996, "speedup_vs_ref": 2.4548315002199734}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_5474f82bb7757b69", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 4}, "ts": "2026-02-09T19:12:10-0600"}
