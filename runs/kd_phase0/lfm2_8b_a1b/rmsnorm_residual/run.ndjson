{"candidate_id": "rmsnorm_residual_e4be3954505f6f8a", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.04125, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.001440922190201729, "dtype": "float16", "gbps_est": 0.3089736998991284, "latency_us": 136.1875, "p10_us": 129.625, "p90_us": 164.0, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.14218124637691223, "latency_us": 144.04149999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.001440922190201729, "p10_us": 129.625, "p90_us": 168.792, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.3615867649253863}, {"baseline_us": 201.4375, "gbps_est": 0.27570423720257126, "latency_us": 133.70850000000002, "max_abs_err": 0.001953125, "max_rel_err": 0.000864304235090752, "p10_us": 126.875, "p90_us": 147.917, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5065422168373737}, {"baseline_us": 200.5625, "gbps_est": 0.5090356161179016, "latency_us": 136.792, "max_abs_err": 0.00390625, "max_rel_err": 0.0009737098344693282, "p10_us": 129.625, "p90_us": 164.0, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4661858880636294}], "reference_latency_us": 200.4795, "speedup_vs_ref": 1.4720844424047728}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_a77098ece6039e6e", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.03175, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009578544061302681, "dtype": "float16", "gbps_est": 0.28406189206298305, "latency_us": 147.9995, "p10_us": 137.292, "p90_us": 179.292, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.13693272043460095, "latency_us": 149.5625, "max_abs_err": 0.001953125, "max_rel_err": 0.0009149130832570906, "p10_us": 143.625, "p90_us": 151.625, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.311324697033013}, {"baseline_us": 201.4375, "gbps_est": 0.2678184176017378, "latency_us": 137.6455, "max_abs_err": 0.00390625, "max_rel_err": 0.0009523809523809524, "p10_us": 132.833, "p90_us": 138.625, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.4634514023342573}, {"baseline_us": 200.5625, "gbps_est": 0.4474345381526104, "latency_us": 155.625, "max_abs_err": 0.001953125, "max_rel_err": 0.0009578544061302681, "p10_us": 145.458, "p90_us": 275.125, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.2887550200803213}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.3551566052588015}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_544401a2e05792b8", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.024667, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009699321047526673, "dtype": "float16", "gbps_est": 0.3082758142302581, "latency_us": 137.6045, "p10_us": 125.416, "p90_us": 141.417, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.15125944909949665, "latency_us": 135.3965, "max_abs_err": 0.0009765625, "max_rel_err": 0.0009057971014492754, "p10_us": 121.416, "p90_us": 222.375, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4485234108710343}, {"baseline_us": 201.4375, "gbps_est": 0.26761524500907446, "latency_us": 137.75, "max_abs_err": 0.00390625, "max_rel_err": 0.0009699321047526673, "p10_us": 125.167, "p90_us": 141.083, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.4623411978221417}, {"baseline_us": 200.5625, "gbps_est": 0.5059527485822032, "latency_us": 137.6255, "max_abs_err": 0.001953125, "max_rel_err": 0.0009689922480620155, "p10_us": 125.708, "p90_us": 140.291, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4573062404859565}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.4575286418685436}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_472cdcb08e2db15d", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.020333, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009727626459143969, "dtype": "float16", "gbps_est": 0.3047506710466137, "latency_us": 139.47899999999998, "p10_us": 132.0, "p90_us": 157.625, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.14443743101666887, "latency_us": 141.79149999999998, "max_abs_err": 0.0009765625, "max_rel_err": 0.0009541984732824427, "p10_us": 135.458, "p90_us": 150.333, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.3831929276437587}, {"baseline_us": 201.4375, "gbps_est": 0.278656305747891, "latency_us": 132.292, "max_abs_err": 0.001953125, "max_rel_err": 0.0009727626459143969, "p10_us": 131.375, "p90_us": 134.667, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5226733286971246}, {"baseline_us": 200.5625, "gbps_est": 0.4911582763752812, "latency_us": 141.77100000000002, "max_abs_err": 0.0009765625, "max_rel_err": 0.0009049773755656109, "p10_us": 132.792, "p90_us": 198.958, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.414693414026846}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.4379404784949708}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_a0667b918a02f1ad", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.023, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009652509652509653, "dtype": "float16", "gbps_est": 0.31788331621373045, "latency_us": 136.89600000000002, "p10_us": 121.792, "p90_us": 143.625, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.15226765799256506, "latency_us": 134.5, "max_abs_err": 0.0009765625, "max_rel_err": 0.0008764241893076249, "p10_us": 123.667, "p90_us": 182.792, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.45817843866171}, {"baseline_us": 201.4375, "gbps_est": 0.26916182639266634, "latency_us": 136.95850000000002, "max_abs_err": 0.001953125, "max_rel_err": 0.0009633911368015414, "p10_us": 135.458, "p90_us": 137.834, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.4707922472865866}, {"baseline_us": 200.5625, "gbps_est": 0.5322204642559599, "latency_us": 130.833, "max_abs_err": 0.00390625, "max_rel_err": 0.0009652509652509653, "p10_us": 120.166, "p90_us": 141.791, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5329656890845582}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.4650720254791958}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_d6959400a3811a21", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.024291, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009689922480620155, "dtype": "float16", "gbps_est": 0.33219401684201516, "latency_us": 125.5625, "p10_us": 123.667, "p90_us": 171.709, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.1555941333110477, "latency_us": 131.6245, "max_abs_err": 0.001953125, "max_rel_err": 0.0009689922480620155, "p10_us": 112.667, "p90_us": 155.792, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4900341501772085}, {"baseline_us": 201.4375, "gbps_est": 0.2947646176911545, "latency_us": 125.0625, "max_abs_err": 0.001953125, "max_rel_err": 0.0009337068160597573, "p10_us": 123.667, "p90_us": 127.958, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.6106946526736632}, {"baseline_us": 200.5625, "gbps_est": 0.5462232995238432, "latency_us": 127.479, "max_abs_err": 0.0009765625, "max_rel_err": 0.0008802816901408451, "p10_us": 124.666, "p90_us": 235.625, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.573298347178751}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.5973120955699354}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_7374411585263db3", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.024, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009718172983479105, "dtype": "float16", "gbps_est": 0.29672757952977125, "latency_us": 142.042, "p10_us": 134.667, "p90_us": 151.667, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.1402941518985608, "latency_us": 145.97899999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.0009416195856873823, "p10_us": 134.208, "p90_us": 154.583, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.3435151631399038}, {"baseline_us": 201.4375, "gbps_est": 0.259377308707124, "latency_us": 142.125, "max_abs_err": 0.00390625, "max_rel_err": 0.0009718172983479105, "p10_us": 141.167, "p90_us": 142.667, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.4173262972735268}, {"baseline_us": 200.5625, "gbps_est": 0.490511277983629, "latency_us": 141.958, "max_abs_err": 0.001953125, "max_rel_err": 0.0009478672985781991, "p10_us": 130.209, "p90_us": 143.334, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4128298510827146}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.4119943397023416}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_006d2b315ce8ae94", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.020375, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009737098344693282, "dtype": "float16", "gbps_est": 0.31465694332604305, "latency_us": 134.5625, "p10_us": 125.75, "p90_us": 179.292, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.145377107364685, "latency_us": 140.875, "max_abs_err": 0.001953125, "max_rel_err": 0.0009643201542912247, "p10_us": 121.417, "p90_us": 156.25, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.3921916592724046}, {"baseline_us": 201.4375, "gbps_est": 0.2746351384574124, "latency_us": 134.22899999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.0009389671361502347, "p10_us": 125.75, "p90_us": 139.875, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5007002957632107}, {"baseline_us": 200.5625, "gbps_est": 0.5239585841560318, "latency_us": 132.89600000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0009737098344693282, "p10_us": 125.625, "p90_us": 179.292, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5091688237418732}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.4904784022294473}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_63005cf76643acef", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.021334, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.000975609756097561, "dtype": "float16", "gbps_est": 0.3303940073603589, "latency_us": 127.042, "p10_us": 120.5, "p90_us": 138.208, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.15091225277802342, "latency_us": 135.708, "max_abs_err": 0.00048828125, "max_rel_err": 0.000966183574879227, "p10_us": 125.5, "p90_us": 236.875, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4451985144575117}, {"baseline_us": 201.4375, "gbps_est": 0.2911756342611608, "latency_us": 126.604, "max_abs_err": 0.001953125, "max_rel_err": 0.000970873786407767, "p10_us": 124.5, "p90_us": 130.125, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5910832201194276}, {"baseline_us": 200.5625, "gbps_est": 0.5490941350418925, "latency_us": 126.8125, "max_abs_err": 0.001953125, "max_rel_err": 0.000975609756097561, "p10_us": 120.125, "p90_us": 135.625, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5815672745194678}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.5787101903307568}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_17b6b039a2360e82", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.018458, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009624639076034649, "dtype": "float16", "gbps_est": 0.33419997606025587, "latency_us": 127.0, "p10_us": 119.625, "p90_us": 172.834, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.15333645297145532, "latency_us": 133.5625, "max_abs_err": 0.001953125, "max_rel_err": 0.0009569377990430622, "p10_us": 116.291, "p90_us": 197.833, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4684136640149743}, {"baseline_us": 201.4375, "gbps_est": 0.29146225277614163, "latency_us": 126.4795, "max_abs_err": 0.001953125, "max_rel_err": 0.0009624639076034649, "p10_us": 120.916, "p90_us": 128.375, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5926494016816954}, {"baseline_us": 200.5625, "gbps_est": 0.5578012224331707, "latency_us": 124.833, "max_abs_err": 0.001953125, "max_rel_err": 0.0009514747859181732, "p10_us": 119.334, "p90_us": 172.834, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.6066464796968751}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.579232283464567}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 1}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_0d1c5f657896a9a5", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v2_u4_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 4;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.020917, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.001183431952662722, "dtype": "float16", "gbps_est": 0.3000117185748014, "latency_us": 135.60399999999998, "p10_us": 131.25, "p90_us": 157.5, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.14973934532905367, "latency_us": 136.77100000000002, "max_abs_err": 0.001953125, "max_rel_err": 0.0008051529790660225, "p10_us": 133.583, "p90_us": 145.916, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.433966264778352}, {"baseline_us": 201.4375, "gbps_est": 0.2786141846544531, "latency_us": 132.312, "max_abs_err": 0.001953125, "max_rel_err": 0.0009633911368015414, "p10_us": 129.208, "p90_us": 132.959, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5224431646411511}, {"baseline_us": 200.5625, "gbps_est": 0.47168162574089756, "latency_us": 147.625, "max_abs_err": 0.00390625, "max_rel_err": 0.001183431952662722, "p10_us": 130.375, "p90_us": 244.75, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.3585944115156647}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.4790308545470636}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_006d2b315ce8ae94", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 4, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_12d960ba12b9a904", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.019542, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009624639076034649, "dtype": "float16", "gbps_est": 0.2974585789052006, "latency_us": 142.458, "p10_us": 136.583, "p90_us": 186.875, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.1452265974571163, "latency_us": 141.02100000000002, "max_abs_err": 0.001953125, "max_rel_err": 0.0009505703422053232, "p10_us": 127.291, "p90_us": 149.25, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.3907503137830535}, {"baseline_us": 201.4375, "gbps_est": 0.2590738027218773, "latency_us": 142.29149999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.0007052186177715092, "p10_us": 140.125, "p90_us": 147.125, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.415667836799809}, {"baseline_us": 200.5625, "gbps_est": 0.4880753365366082, "latency_us": 142.66649999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0009624639076034649, "p10_us": 140.666, "p90_us": 188.833, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4058135581934093}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.4078710918305746}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_472cdcb08e2db15d", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_a62e8f2fe01c67f2", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.018667, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009689922480620155, "dtype": "float16", "gbps_est": 0.3283065568316148, "latency_us": 129.16649999999998, "p10_us": 122.75, "p90_us": 169.041, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.1589395750228942, "latency_us": 128.85399999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.0009433962264150943, "p10_us": 107.708, "p90_us": 189.166, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.5220714917658746}, {"baseline_us": 201.4375, "gbps_est": 0.27561869158878505, "latency_us": 133.75, "max_abs_err": 0.001953125, "max_rel_err": 0.0009689922480620155, "p10_us": 128.25, "p90_us": 139.208, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5060747663551401}, {"baseline_us": 200.5625, "gbps_est": 0.5503614038831652, "latency_us": 126.5205, "max_abs_err": 0.001953125, "max_rel_err": 0.0009514747859181732, "p10_us": 124.709, "p90_us": 129.208, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5852174153595662}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.5527439390244375}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_2e58f6828a2c7547", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u4_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 4;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.020209, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.000975609756097561, "dtype": "float16", "gbps_est": 0.3341335559809533, "latency_us": 126.25, "p10_us": 120.375, "p90_us": 132.583, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.1636214018071856, "latency_us": 125.167, "max_abs_err": 0.00390625, "max_rel_err": 0.0009737098344693282, "p10_us": 117.959, "p90_us": 140.167, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.5669066127653455}, {"baseline_us": 201.4375, "gbps_est": 0.2865081431452632, "latency_us": 128.66649999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.000975609756097561, "p10_us": 124.333, "p90_us": 132.583, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5655784528218302}, {"baseline_us": 200.5625, "gbps_est": 0.552271122990411, "latency_us": 126.083, "max_abs_err": 0.00390625, "max_rel_err": 0.000968054211035818, "p10_us": 122.541, "p90_us": 128.625, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5907180190826677}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.5886138613861387}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_544401a2e05792b8", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 4, "use_simd": false, "vec_width": 1}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_aff3eca59171ecf1", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v4_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.016875, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.000975609756097561, "dtype": "float16", "gbps_est": 0.3233019079396454, "latency_us": 131.375, "p10_us": 125.291, "p90_us": 181.917, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.1555439100154177, "latency_us": 131.667, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 125.291, "p90_us": 147.708, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4895531910045796}, {"baseline_us": 201.4375, "gbps_est": 0.2797591266634034, "latency_us": 131.7705, "max_abs_err": 0.001953125, "max_rel_err": 0.0009624639076034649, "p10_us": 129.0, "p90_us": 201.542, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.5286995192398907}, {"baseline_us": 200.5625, "gbps_est": 0.5346026871401152, "latency_us": 130.25, "max_abs_err": 0.001953125, "max_rel_err": 0.0009689922480620155, "p10_us": 125.083, "p90_us": 135.166, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.539827255278311}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.5266412940057088}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_d6959400a3811a21", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 4}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_88a4cee4a6ab55f7", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.018541, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.000966183574879227, "dtype": "float16", "gbps_est": 0.321283247049029, "latency_us": 131.04149999999998, "p10_us": 121.875, "p90_us": 165.416, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.14883288276503592, "latency_us": 137.60399999999998, "max_abs_err": 0.0009765625, "max_rel_err": 0.000966183574879227, "p10_us": 123.166, "p90_us": 175.25, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.425285602162728}, {"baseline_us": 201.4375, "gbps_est": 0.2967423065467805, "latency_us": 124.229, "max_abs_err": 0.0009765625, "max_rel_err": 0.0009000900090009, "p10_us": 115.417, "p90_us": 133.0, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.6215014207632679}, {"baseline_us": 200.5625, "gbps_est": 0.5182745518352705, "latency_us": 134.3535, "max_abs_err": 0.00390625, "max_rel_err": 0.0009587727708533077, "p10_us": 123.834, "p90_us": 138.125, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4927969870528122}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.5305265889050417}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_a0667b918a02f1ad", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_b5466501d920cc8b", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.019333, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009746588693957114, "dtype": "float16", "gbps_est": 0.32500971614983026, "latency_us": 129.45850000000002, "p10_us": 124.042, "p90_us": 155.292, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.15151683294307397, "latency_us": 135.16649999999998, "max_abs_err": 0.001953125, "max_rel_err": 0.0009746588693957114, "p10_us": 107.541, "p90_us": 197.959, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4509882256328308}, {"baseline_us": 201.4375, "gbps_est": 0.27151700848122384, "latency_us": 135.7705, "max_abs_err": 0.001953125, "max_rel_err": 0.0009596928982725527, "p10_us": 125.375, "p90_us": 142.958, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.4836617674678962}, {"baseline_us": 200.5625, "gbps_est": 0.5519953070251931, "latency_us": 126.146, "max_abs_err": 0.001953125, "max_rel_err": 0.0009727626459143969, "p10_us": 124.042, "p90_us": 129.417, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5899235806129406}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.54924164886817}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_051b7d857c6e5f31", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 1}, "ts": "2026-02-09T19:12:37-0600"}
{"candidate_id": "rmsnorm_residual_b448f0bd33a97cf3", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v4_u4_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 4;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.01775, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009765625, "dtype": "float16", "gbps_est": 0.3250223280666369, "latency_us": 129.875, "p10_us": 127.625, "p90_us": 143.041, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.1564110984672018, "latency_us": 130.937, "max_abs_err": 3.0517578125e-05, "max_rel_err": 0.0006191950464396285, "p10_us": 128.166, "p90_us": 141.375, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.49785774838281}, {"baseline_us": 201.4375, "gbps_est": 0.27843741502764435, "latency_us": 132.39600000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0009149130832570906, "p10_us": 126.5, "p90_us": 144.208, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.521477234961781}, {"baseline_us": 200.5625, "gbps_est": 0.5402184707050646, "latency_us": 128.89600000000002, "max_abs_err": 0.001953125, "max_rel_err": 0.0009765625, "p10_us": 126.292, "p90_us": 132.0, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.5560025136544189}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.5442733397497594}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_a62e8f2fe01c67f2", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 4, "use_simd": false, "vec_width": 4}, "ts": "2026-02-09T19:12:38-0600"}
{"candidate_id": "rmsnorm_residual_d3f9b2385783f2aa", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.018917, "correctness_max_abs_err": 0.001953125, "correctness_max_rel_err": 0.0009737098344693282, "dtype": "float16", "gbps_est": 0.31063107547029334, "latency_us": 136.188, "p10_us": 129.75, "p90_us": 144.542, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.14622043730477466, "latency_us": 140.0625, "max_abs_err": 0.0009765625, "max_rel_err": 0.0008298755186721991, "p10_us": 128.833, "p90_us": 144.542, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4002677376171353}, {"baseline_us": 201.4375, "gbps_est": 0.2704374140302614, "latency_us": 136.3125, "max_abs_err": 0.001953125, "max_rel_err": 0.0009737098344693282, "p10_us": 129.208, "p90_us": 154.959, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.477762494268684}, {"baseline_us": 200.5625, "gbps_est": 0.5152353750758439, "latency_us": 135.14600000000002, "max_abs_err": 0.001953125, "max_rel_err": 0.0009652509652509653, "p10_us": 133.875, "p90_us": 140.042, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 1.4840431829280925}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.4726884894410668}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_a77098ece6039e6e", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T19:12:38-0600"}
{"candidate_id": "rmsnorm_residual_5faa7484fddec673", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.7, "bytes_moved_est": 20480.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v4_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.01675, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0009671179883945841, "dtype": "float16", "gbps_est": 0.38215933014130865, "latency_us": 123.7295, "p10_us": 98.125, "p90_us": 144.834, "per_shape": [{"baseline_us": 196.125, "gbps_est": 0.15231465470758634, "latency_us": 134.45850000000002, "max_abs_err": 0.001953125, "max_rel_err": 0.0008896797153024911, "p10_us": 123.083, "p90_us": 172.458, "shape": {"D": 2048, "rows": 1}, "speedup_vs_ref": 1.4586284987561215}, {"baseline_us": 201.4375, "gbps_est": 0.29624510296333506, "latency_us": 124.4375, "max_abs_err": 0.001953125, "max_rel_err": 0.0009671179883945841, "p10_us": 103.792, "p90_us": 131.125, "shape": {"D": 2048, "rows": 2}, "speedup_vs_ref": 1.6187845303867403}, {"baseline_us": 200.5625, "gbps_est": 0.6979182327530045, "latency_us": 99.771, "max_abs_err": 0.00390625, "max_rel_err": 0.0009569377990430622, "p10_us": 97.125, "p90_us": 107.0, "shape": {"D": 2048, "rows": 4}, "speedup_vs_ref": 2.0102284230888734}], "reference_latency_us": 200.5625, "speedup_vs_ref": 1.62097559595731}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 1}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [1, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [1, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_a62e8f2fe01c67f2", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 4}, "ts": "2026-02-09T19:12:38-0600"}
