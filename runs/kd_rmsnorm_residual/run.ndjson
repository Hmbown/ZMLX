{"candidate_id": "rmsnorm_residual_96eaf3a799e17b29", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.047334, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0029069767441860465, "dtype": "float16", "gbps_est": 42.69424176729824, "latency_us": 176.8955, "p10_us": 166.458, "p90_us": 218.333, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 11.878470622486157, "latency_us": 176.8955, "max_abs_err": 0.00390625, "max_rel_err": 0.0020161290322580645, "p10_us": 164.625, "p90_us": 205.209, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.4630813107173444}, {"baseline_us": 307.9375, "gbps_est": 24.039485587989418, "latency_us": 174.64600000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 163.708, "p90_us": 183.5, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.7632095782325388}, {"baseline_us": 310.4375, "gbps_est": 48.718172873475154, "latency_us": 172.2705, "max_abs_err": 0.0078125, "max_rel_err": 0.001091703056768559, "p10_us": 159.833, "p90_us": 192.417, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.8020351714309764}, {"baseline_us": 463.91700000000003, "gbps_est": 86.14083798524221, "latency_us": 194.8125, "max_abs_err": 0.00390625, "max_rel_err": 0.0029069767441860465, "p10_us": 184.041, "p90_us": 218.333, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.3813512993262753}], "reference_latency_us": 310.66650000000004, "speedup_vs_ref": 1.7562148273980969}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T18:48:12-0600"}
{"candidate_id": "rmsnorm_residual_efb7abf5f90288b7", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.034167, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0018552875695732839, "dtype": "float16", "gbps_est": 43.51872410289735, "latency_us": 175.79149999999998, "p10_us": 156.0, "p90_us": 232.333, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 12.393708914926435, "latency_us": 169.54149999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 159.208, "p90_us": 177.542, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5265436486052089}, {"baseline_us": 307.9375, "gbps_est": 26.1820721653342, "latency_us": 160.35399999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.000980392156862745, "p10_us": 154.375, "p90_us": 204.667, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.9203605772228944}, {"baseline_us": 310.4375, "gbps_est": 46.77764091474052, "latency_us": 179.417, "max_abs_err": 0.00390625, "max_rel_err": 0.0018552875695732839, "p10_us": 156.0, "p90_us": 195.458, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.7302568875859032}, {"baseline_us": 463.91700000000003, "gbps_est": 88.72147441658824, "latency_us": 189.14600000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0015128593040847202, "p10_us": 168.125, "p90_us": 328.0, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.452692628974443}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.7588307739566476}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T18:48:12-0600"}
{"candidate_id": "rmsnorm_residual_9fb2437335e855ee", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.032042, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0035971223021582736, "dtype": "float16", "gbps_est": 42.0398660606582, "latency_us": 176.41649999999998, "p10_us": 148.375, "p90_us": 242.708, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 13.709364459030082, "latency_us": 153.27100000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 150.542, "p90_us": 173.458, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.688594058889157}, {"baseline_us": 307.9375, "gbps_est": 28.067266777418627, "latency_us": 149.58350000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 142.083, "p90_us": 156.916, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.0586328037517503}, {"baseline_us": 310.4375, "gbps_est": 44.870692144010434, "latency_us": 187.042, "max_abs_err": 0.00390625, "max_rel_err": 0.0035971223021582736, "p10_us": 176.875, "p90_us": 279.958, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.6597208113685695}, {"baseline_us": 463.91700000000003, "gbps_est": 81.51214086217365, "latency_us": 205.875, "max_abs_err": 0.0078125, "max_rel_err": 0.0018248175182481751, "p10_us": 183.042, "p90_us": 266.458, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.2533916211293263}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.7525996717994066}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 2}, "ts": "2026-02-09T18:48:12-0600"}
{"candidate_id": "rmsnorm_residual_e4ef568da100c168", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.0305, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.002173913043478261, "dtype": "float16", "gbps_est": 43.2920391159582, "latency_us": 180.2705, "p10_us": 160.125, "p90_us": 251.083, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 12.853281298266756, "latency_us": 163.4795, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 150.75, "p90_us": 282.625, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5831495692120419}, {"baseline_us": 307.9375, "gbps_est": 24.787601476014764, "latency_us": 169.375, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 150.292, "p90_us": 250.292, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.818081180811808}, {"baseline_us": 310.4375, "gbps_est": 45.607316556262596, "latency_us": 184.02100000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0018796992481203006, "p10_us": 166.708, "p90_us": 239.667, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.6869677917194232}, {"baseline_us": 463.91700000000003, "gbps_est": 89.91995713328868, "latency_us": 186.625, "max_abs_err": 0.0078125, "max_rel_err": 0.002173913043478261, "p10_us": 177.75, "p90_us": 196.166, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.485824514400536}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.7151308727717514}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T18:48:12-0600"}
{"candidate_id": "rmsnorm_residual_f385a0b77fd7ac03", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.035334, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0021929824561403508, "dtype": "float16", "gbps_est": 42.5193225697781, "latency_us": 185.85399999999998, "p10_us": 136.25, "p90_us": 257.5, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 15.049224709042077, "latency_us": 139.625, "max_abs_err": 0.0078125, "max_rel_err": 0.0013568521031207597, "p10_us": 132.0, "p90_us": 192.542, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.8536257833482543}, {"baseline_us": 307.9375, "gbps_est": 25.902698300567295, "latency_us": 162.08350000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0021929824561403508, "p10_us": 149.625, "p90_us": 257.5, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.8998695117023015}, {"baseline_us": 310.4375, "gbps_est": 45.157510734232254, "latency_us": 185.85399999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0012376237623762376, "p10_us": 167.875, "p90_us": 192.125, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.6703299364016917}, {"baseline_us": 463.91700000000003, "gbps_est": 83.96785653527076, "latency_us": 199.85399999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 191.333, "p90_us": 241.375, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.321279534059864}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.6636042269738613}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T18:48:12-0600"}
{"candidate_id": "rmsnorm_residual_5474f82bb7757b69", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v2_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.033417, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0017857142857142857, "dtype": "float16", "gbps_est": 41.671350631296235, "latency_us": 180.77100000000002, "p10_us": 155.708, "p90_us": 233.291, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 12.752535336922154, "latency_us": 164.77100000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 152.959, "p90_us": 206.541, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.570740603625638}, {"baseline_us": 307.9375, "gbps_est": 21.594874920595732, "latency_us": 194.41649999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 166.375, "p90_us": 266.25, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.583906201376941}, {"baseline_us": 310.4375, "gbps_est": 48.32641779958196, "latency_us": 173.667, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 166.583, "p90_us": 189.334, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.7875445536572867}, {"baseline_us": 463.91700000000003, "gbps_est": 84.0115744680851, "latency_us": 199.75, "max_abs_err": 0.00390625, "max_rel_err": 0.0017857142857142857, "p10_us": 180.75, "p90_us": 246.458, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.322488110137672}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.7103821962593557}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T18:48:12-0600"}
{"candidate_id": "rmsnorm_residual_4144d2f97a190b25", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.036125, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0015313935681470138, "dtype": "float16", "gbps_est": 42.305637958091985, "latency_us": 181.3745, "p10_us": 151.25, "p90_us": 240.792, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 13.713122189663837, "latency_us": 153.22899999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 147.667, "p90_us": 187.042, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.689056901761416}, {"baseline_us": 307.9375, "gbps_est": 26.752050975706894, "latency_us": 156.9375, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 151.25, "p90_us": 161.125, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.9621664675428117}, {"baseline_us": 310.4375, "gbps_est": 44.66687068077735, "latency_us": 187.8955, "max_abs_err": 0.0078125, "max_rel_err": 0.0015313935681470138, "p10_us": 181.0, "p90_us": 217.25, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.6521816648083643}, {"baseline_us": 463.91700000000003, "gbps_est": 84.09050798621986, "latency_us": 199.5625, "max_abs_err": 0.00390625, "max_rel_err": 0.0013280212483399733, "p10_us": 171.917, "p90_us": 265.833, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.3246702160977137}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.7046911225117092}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T18:48:12-0600"}
{"candidate_id": "rmsnorm_residual_3d9e4da0b8a43ea6", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.035083, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0012755102040816326, "dtype": "float16", "gbps_est": 45.86298132212654, "latency_us": 160.1875, "p10_us": 125.292, "p90_us": 264.208, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 16.464235063663075, "latency_us": 127.625, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 122.0, "p90_us": 137.458, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 2.027913809990206}, {"baseline_us": 307.9375, "gbps_est": 29.833119566260095, "latency_us": 140.7295, "max_abs_err": 0.00390625, "max_rel_err": 0.001004016064257028, "p10_us": 125.292, "p90_us": 306.583, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.188151737908541}, {"baseline_us": 310.4375, "gbps_est": 51.46261884249479, "latency_us": 163.08350000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.0012755102040816326, "p10_us": 148.167, "p90_us": 186.792, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.9035494087384681}, {"baseline_us": 463.91700000000003, "gbps_est": 85.69195181608819, "latency_us": 195.833, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 166.041, "p90_us": 264.208, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.3689419045819653}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.9301599687865783}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 0, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T18:48:12-0600"}
{"candidate_id": "rmsnorm_residual_e47c59531effe390", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v1_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.03725, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0034482758620689655, "dtype": "float16", "gbps_est": 36.73664512655267, "latency_us": 210.375, "p10_us": 148.125, "p90_us": 332.833, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 9.116873988519561, "latency_us": 230.47899999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 170.875, "p90_us": 257.0, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.1229331088732597}, {"baseline_us": 307.9375, "gbps_est": 28.279861780020074, "latency_us": 148.459, "max_abs_err": 0.00390625, "max_rel_err": 0.0013605442176870747, "p10_us": 144.75, "p90_us": 151.958, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 2.074225880546144}, {"baseline_us": 310.4375, "gbps_est": 40.28900810081008, "latency_us": 208.3125, "max_abs_err": 0.0078125, "max_rel_err": 0.0011135857461024498, "p10_us": 181.833, "p90_us": 350.792, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.4902490249024902}, {"baseline_us": 463.91700000000003, "gbps_est": 69.26083663686097, "latency_us": 242.29149999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0034482758620689655, "p10_us": 209.25, "p90_us": 332.833, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 1.9147060462294387}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.4696969696969697}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 1}, "ts": "2026-02-09T18:48:12-0600"}
{"candidate_id": "rmsnorm_residual_9bad2cf80208bd17", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v1_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.032334, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.01, "dtype": "float16", "gbps_est": 41.28256614165541, "latency_us": 186.1875, "p10_us": 164.25, "p90_us": 254.709, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 10.638099240080802, "latency_us": 197.52100000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 155.541, "p90_us": 254.709, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.3103037145417449}, {"baseline_us": 307.9375, "gbps_est": 25.043245887167007, "latency_us": 167.64600000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.0021551724137931034, "p10_us": 161.333, "p90_us": 184.125, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.836831776481395}, {"baseline_us": 310.4375, "gbps_est": 45.07662437059416, "latency_us": 186.1875, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 177.208, "p90_us": 213.917, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.6673380328969454}, {"baseline_us": 463.91700000000003, "gbps_est": 84.37229506877966, "latency_us": 198.89600000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.01, "p10_us": 178.708, "p90_us": 218.375, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.3324601801946745}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.660624370594159}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T18:48:12-0600"}
{"candidate_id": "rmsnorm_residual_9c80e02fae5cc00b", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v4_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.032875, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.001579778830963665, "dtype": "float16", "gbps_est": 39.17697408223096, "latency_us": 197.625, "p10_us": 161.75, "p90_us": 229.917, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 12.709148478680968, "latency_us": 165.33350000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 157.959, "p90_us": 176.833, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5653966074630972}, {"baseline_us": 307.9375, "gbps_est": 20.446736650376096, "latency_us": 205.33350000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.0013550135501355014, "p10_us": 157.875, "p90_us": 217.125, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.4996943995987015}, {"baseline_us": 310.4375, "gbps_est": 43.090221568461345, "latency_us": 194.7705, "max_abs_err": 0.00390625, "max_rel_err": 0.0010834236186348862, "p10_us": 168.125, "p90_us": 229.917, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.5938630336729638}, {"baseline_us": 463.91700000000003, "gbps_est": 80.46178963140545, "latency_us": 208.5625, "max_abs_err": 0.0078125, "max_rel_err": 0.001579778830963665, "p10_us": 198.25, "p90_us": 218.167, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.22435480970932}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.564516129032258}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_96eaf3a799e17b29", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 4}, "ts": "2026-02-09T18:48:13-0600"}
{"candidate_id": "rmsnorm_residual_624c4a01eb8b306a", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v4_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.036083, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0034602076124567475, "dtype": "float16", "gbps_est": 39.16172342423324, "latency_us": 184.1875, "p10_us": 160.958, "p90_us": 230.25, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 12.927415683331077, "latency_us": 162.542, "max_abs_err": 0.00390625, "max_rel_err": 0.0009746588693957114, "p10_us": 157.292, "p90_us": 176.375, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5922807643562895}, {"baseline_us": 307.9375, "gbps_est": 24.74501448429714, "latency_us": 169.66649999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 165.584, "p90_us": 178.667, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.8149575785437906}, {"baseline_us": 310.4375, "gbps_est": 42.48577640647662, "latency_us": 197.54149999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0034602076124567475, "p10_us": 168.625, "p90_us": 214.5, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.5715052280153792}, {"baseline_us": 463.91700000000003, "gbps_est": 76.48868712282813, "latency_us": 219.39600000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.0010787486515641855, "p10_us": 203.291, "p90_us": 264.875, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.114518952031942}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.678656260604004}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_96eaf3a799e17b29", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 4}, "ts": "2026-02-09T18:48:13-0600"}
{"candidate_id": "rmsnorm_residual_2af6a34090a419c7", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.125}, "func_name": "kk_kd_rmsnorm_res_d2048_tg128_v4_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 128}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 128;\nconstexpr uint VEC = 4;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.032, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.004347826086956522, "dtype": "float16", "gbps_est": 39.744482407287016, "latency_us": 192.3745, "p10_us": 148.833, "p90_us": 272.0, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 13.341257142857145, "latency_us": 157.5, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 148.292, "p90_us": 187.083, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.6432539682539682}, {"baseline_us": 307.9375, "gbps_est": 27.207128392061566, "latency_us": 154.3125, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 145.542, "p90_us": 221.208, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.9955447549615228}, {"baseline_us": 310.4375, "gbps_est": 40.61814547645608, "latency_us": 206.6245, "max_abs_err": 0.0078125, "max_rel_err": 0.0010438413361169101, "p10_us": 172.5, "p90_us": 266.584, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.5024234783387256}, {"baseline_us": 463.91700000000003, "gbps_est": 77.81139861777328, "latency_us": 215.66649999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.004347826086956522, "p10_us": 202.416, "p90_us": 308.125, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.151085124486186}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.6072166529347705}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_4144d2f97a190b25", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 4}, "ts": "2026-02-09T18:48:13-0600"}
{"candidate_id": "rmsnorm_residual_439aa7830bf0627e", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u2_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.031792, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0017241379310344827, "dtype": "float16", "gbps_est": 41.14709339963258, "latency_us": 189.813, "p10_us": 161.583, "p90_us": 222.208, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 12.970626633868417, "latency_us": 162.0005, "max_abs_err": 0.0078125, "max_rel_err": 0.0012048192771084338, "p10_us": 155.542, "p90_us": 164.791, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5976030938176118}, {"baseline_us": 307.9375, "gbps_est": 24.657164167709123, "latency_us": 170.27100000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 165.75, "p90_us": 181.833, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.8085140746222197}, {"baseline_us": 310.4375, "gbps_est": 41.77625792385631, "latency_us": 200.8965, "max_abs_err": 0.0078125, "max_rel_err": 0.0009852216748768472, "p10_us": 188.709, "p90_us": 219.0, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.5452608681584796}, {"baseline_us": 463.91700000000003, "gbps_est": 85.18432487309646, "latency_us": 197.0, "max_abs_err": 0.00390625, "max_rel_err": 0.0017241379310344827, "p10_us": 190.917, "p90_us": 222.708, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.3549086294416246}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.628905817831234}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_cccf5a8c63779dce", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T18:48:13-0600"}
{"candidate_id": "rmsnorm_residual_90378efe31aefe36", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.0625}, "func_name": "kk_kd_rmsnorm_res_d2048_tg64_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 64}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 64;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.034792, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.00205761316872428, "dtype": "float16", "gbps_est": 41.70590380614656, "latency_us": 182.54149999999998, "p10_us": 161.0, "p90_us": 252.917, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 11.962970975712514, "latency_us": 175.64600000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 159.833, "p90_us": 281.875, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.4734892909602266}, {"baseline_us": 307.9375, "gbps_est": 23.750569240908412, "latency_us": 176.7705, "max_abs_err": 0.00390625, "max_rel_err": 0.00205761316872428, "p10_us": 160.584, "p90_us": 202.292, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.742018606045692}, {"baseline_us": 310.4375, "gbps_est": 46.42739827571423, "latency_us": 180.7705, "max_abs_err": 0.0078125, "max_rel_err": 0.0017391304347826088, "p10_us": 163.75, "p90_us": 216.416, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.7173017721364936}, {"baseline_us": 463.91700000000003, "gbps_est": 84.68267673225108, "latency_us": 198.167, "max_abs_err": 0.0078125, "max_rel_err": 0.001182033096926714, "p10_us": 179.959, "p90_us": 252.917, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.3410406374421573}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.693792918322683}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_efb7abf5f90288b7", "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T18:48:13-0600"}
{"candidate_id": "rmsnorm_residual_cccf5a8c63779dce", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v1_u1_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.036542, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0018796992481203006, "dtype": "float16", "gbps_est": 40.22187195303529, "latency_us": 188.1255, "p10_us": 160.459, "p90_us": 263.458, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 12.822260869565218, "latency_us": 163.875, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 156.584, "p90_us": 185.666, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.5793287566742944}, {"baseline_us": 307.9375, "gbps_est": 24.88250389678123, "latency_us": 168.72899999999998, "max_abs_err": 0.0078125, "max_rel_err": 0.0009765625, "p10_us": 164.833, "p90_us": 191.333, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.825041931144024}, {"baseline_us": 310.4375, "gbps_est": 43.60310578529142, "latency_us": 192.4795, "max_abs_err": 0.00390625, "max_rel_err": 0.00145985401459854, "p10_us": 182.833, "p90_us": 221.75, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.6128340940204022}, {"baseline_us": 463.91700000000003, "gbps_est": 79.57961726050328, "latency_us": 210.8745, "max_abs_err": 0.0078125, "max_rel_err": 0.0018796992481203006, "p10_us": 198.458, "p90_us": 265.959, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.1999672791162515}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.6435172265322884}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": null, "seed": 0, "status": "benchmarked", "step": 1, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T18:48:13-0600"}
{"candidate_id": "rmsnorm_residual_302da93503d48525", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.5}, "func_name": "kk_kd_rmsnorm_res_d2048_tg512_v1_u4_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 512}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 512;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 4;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.040125, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.007407407407407408, "dtype": "float16", "gbps_est": 43.612906300492895, "latency_us": 175.79149999999998, "p10_us": 150.708, "p90_us": 255.875, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 12.934099890433222, "latency_us": 162.458, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 150.291, "p90_us": 184.875, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.593104063819572}, {"baseline_us": 307.9375, "gbps_est": 26.898422959505645, "latency_us": 156.08350000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 144.375, "p90_us": 192.0, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.9729023247172184}, {"baseline_us": 310.4375, "gbps_est": 47.5565238825126, "latency_us": 176.4785, "max_abs_err": 0.00390625, "max_rel_err": 0.002207505518763797, "p10_us": 169.0, "p90_us": 269.542, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.759066968497579}, {"baseline_us": 463.91700000000003, "gbps_est": 87.0625784695201, "latency_us": 192.75, "max_abs_err": 0.0078125, "max_rel_err": 0.007407407407407408, "p10_us": 180.291, "p90_us": 211.791, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.406832684824903}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.7588307739566476}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_e4ef568da100c168", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 4, "use_simd": false, "vec_width": 1}, "ts": "2026-02-09T18:48:13-0600"}
{"candidate_id": "rmsnorm_residual_3fb8d765e6b2a090", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v2_u2_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 2;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.0365, "correctness_max_abs_err": 0.00390625, "correctness_max_rel_err": 0.0024154589371980675, "dtype": "float16", "gbps_est": 42.20711143822535, "latency_us": 176.1875, "p10_us": 155.042, "p90_us": 208.708, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 13.332411193842816, "latency_us": 157.6045, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 150.291, "p90_us": 165.875, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.6421644052041662}, {"baseline_us": 307.9375, "gbps_est": 24.099857354836303, "latency_us": 174.20850000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0014749262536873156, "p10_us": 166.375, "p90_us": 179.0, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.7676376296219758}, {"baseline_us": 310.4375, "gbps_est": 45.57648164087637, "latency_us": 184.1455, "max_abs_err": 0.00390625, "max_rel_err": 0.0013698630136986301, "p10_us": 166.666, "p90_us": 217.125, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.685827239872818}, {"baseline_us": 463.91700000000003, "gbps_est": 85.8196955633459, "latency_us": 195.54149999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0024154589371980675, "p10_us": 185.209, "p90_us": 204.875, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.3724733624320162}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.754877616175949}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_f385a0b77fd7ac03", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 2, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T18:48:13-0600"}
{"candidate_id": "rmsnorm_residual_b600ea0810a9af0c", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v2_u1_simd0", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 2;\nconstexpr uint UNROLL = 1;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = false;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.03575, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.0033783783783783786, "dtype": "float16", "gbps_est": 41.8578061974053, "latency_us": 167.58350000000002, "p10_us": 156.334, "p90_us": 246.541, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 13.047826032960346, "latency_us": 161.042, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 152.125, "p90_us": 190.209, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.6071118093416623}, {"baseline_us": 307.9375, "gbps_est": 25.68802848786696, "latency_us": 163.438, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 156.334, "p90_us": 259.083, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.8841242550692008}, {"baseline_us": 310.4375, "gbps_est": 50.51402982918637, "latency_us": 166.14600000000002, "max_abs_err": 0.00390625, "max_rel_err": 0.0033783783783783786, "p10_us": 153.792, "p90_us": 169.625, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.8684620755239365}, {"baseline_us": 463.91700000000003, "gbps_est": 78.18134043960754, "latency_us": 214.64600000000002, "max_abs_err": 0.0078125, "max_rel_err": 0.001893939393939394, "p10_us": 197.292, "p90_us": 306.291, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.161312113899164}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.8449757881891713}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_9c80e02fae5cc00b", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 1, "use_simd": false, "vec_width": 2}, "ts": "2026-02-09T18:48:13-0600"}
{"candidate_id": "rmsnorm_residual_1c171a133044a311", "event": "evaluation", "features": {"arithmetic_intensity_est": 0.8732943469785575, "bytes_moved_est": 2101248.0, "launch_occupancy_proxy": 0.25}, "func_name": "kk_kd_rmsnorm_res_d2048_tg256_v1_u4_simd1", "inputs_spec": [{"dtype": "float16", "name": "inp", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "residual", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "weight", "shape": [2048], "strides": "contiguous"}], "launch_params": {"launch_kind": "rmsnorm_residual_rows_tg", "threadgroup_x": 256}, "metal_source": "constexpr uint D = 2048;\nconstexpr uint TG = 256;\nconstexpr uint VEC = 1;\nconstexpr uint UNROLL = 4;\nconstexpr float EPS = 1e-06f;\nconstexpr bool USE_SIMD = true;\n\nuint gid = thread_position_in_grid.x;\nuint tid = thread_position_in_threadgroup.x;\nuint row = gid / TG;\nuint base = row * D;\n\nthreadgroup float reduce_buf[TG];\n\nfloat sumsq = 0.0f;\nuint start = tid * VEC;\nuint step = TG * VEC;\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float x = (float)inp[base + idx] + (float)residual[base + idx];\n                updated_res[base + idx] = (T)x;\n                sumsq += x * x;\n            }\n        }\n    }\n}\n\nif (USE_SIMD) {\n    KK_SIMD_REDUCE_SUM(reduce_buf, sumsq, tid, TG);\n} else {\n    reduce_buf[tid] = sumsq;\n    threadgroup_barrier(mem_flags::mem_threadgroup);\n    for (uint stride = TG / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) {\n            reduce_buf[tid] += reduce_buf[tid + stride];\n        }\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n    }\n}\n\nfloat inv = metal::rsqrt(reduce_buf[0] / (float)D + EPS);\nthreadgroup_barrier(mem_flags::mem_threadgroup);\n\nfor (uint j0 = start; j0 < D; j0 += step * UNROLL) {\n    #pragma unroll\n    for (uint u = 0; u < UNROLL; ++u) {\n        uint j = j0 + u * step;\n        if (j >= D) {\n            continue;\n        }\n        #pragma unroll\n        for (uint v = 0; v < VEC; ++v) {\n            uint idx = j + v;\n            if (idx < D) {\n                float vres = (float)updated_res[base + idx];\n                float w = (float)weight[idx];\n                out[base + idx] = (T)(vres * inv * w);\n            }\n        }\n    }\n}\n", "metrics": {"compile_time_ms": 0.033458, "correctness_max_abs_err": 0.0078125, "correctness_max_rel_err": 0.001336898395721925, "dtype": "float16", "gbps_est": 45.15712159473674, "latency_us": 169.0625, "p10_us": 139.834, "p90_us": 222.583, "per_shape": [{"baseline_us": 258.8125, "gbps_est": 13.715001827580805, "latency_us": 153.208, "max_abs_err": 0.00390625, "max_rel_err": 0.000975609756097561, "p10_us": 137.583, "p90_us": 228.833, "shape": {"D": 2048, "rows": 128}, "speedup_vs_ref": 1.6892884183593546}, {"baseline_us": 307.9375, "gbps_est": 26.99215321955877, "latency_us": 155.54149999999998, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 145.042, "p90_us": 161.042, "shape": {"D": 2048, "rows": 256}, "speedup_vs_ref": 1.979777101288081}, {"baseline_us": 310.4375, "gbps_est": 46.46466860991389, "latency_us": 180.6255, "max_abs_err": 0.00390625, "max_rel_err": 0.0009765625, "p10_us": 163.459, "p90_us": 222.583, "shape": {"D": 2048, "rows": 512}, "speedup_vs_ref": 1.7186803635145649}, {"baseline_us": 463.91700000000003, "gbps_est": 93.45666272189351, "latency_us": 179.5625, "max_abs_err": 0.0078125, "max_rel_err": 0.001336898395721925, "p10_us": 162.167, "p90_us": 192.625, "shape": {"D": 2048, "rows": 1024}, "speedup_vs_ref": 2.5835962408632094}], "reference_latency_us": 309.1875, "speedup_vs_ref": 1.8288354898336414}, "notes": {"dtype": "float16", "shape_signature": {"D": 2048, "rows": 128}, "shape_suite": "glm_flash_small"}, "op_name": "rmsnorm_residual", "outputs_spec": [{"dtype": "float16", "name": "out", "shape": [128, 2048], "strides": "contiguous"}, {"dtype": "float16", "name": "updated_res", "shape": [128, 2048], "strides": "contiguous"}], "parent_id": "rmsnorm_residual_3d9e4da0b8a43ea6", "seed": 0, "status": "benchmarked", "step": 2, "template_params": {"eps": 1e-06, "unroll": 4, "use_simd": true, "vec_width": 1}, "ts": "2026-02-09T18:48:13-0600"}
